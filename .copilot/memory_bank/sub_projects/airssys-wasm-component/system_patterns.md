# airssys-wasm-component System Patterns

## Macro Development Patterns

### Serde-Inspired Architecture Pattern
**Pattern**: Separate core traits from procedural macro implementation
**Implementation**:
```rust
// Core crate: airssys-wasm (traits only)
pub trait Component {
    type Config: ComponentConfig;
    type Operation: ComponentOperation;
    type Result: ComponentResult;
    
    fn init(&mut self, config: Self::Config) -> Result<(), ComponentError>;
    fn execute(&mut self, operation: Self::Operation) -> Result<Self::Result, ComponentError>;
}

// Macro crate: airssys-wasm-component (macros only)
#[proc_macro_attribute]
pub fn component(args: TokenStream, input: TokenStream) -> TokenStream {
    // Generate Component trait implementation + WASM exports
}
```

**Benefits**:
- Optional macro dependency for performance-conscious users
- Faster compilation for core types
- Clear separation of concerns
- Industry-proven pattern

### CosmWasm-Inspired Developer Experience Pattern
**Pattern**: Eliminate low-level complexity through high-level macros
**Implementation**:
```rust
// What developers write (clean):
#[component(name = "my-processor")]
pub struct MyProcessor {
    state: ProcessorState,
}

impl Component for MyProcessor {
    fn execute(&mut self, operation: MyOperation) -> Result<MyResult, ComponentError> {
        // Clean business logic only
    }
}

// What macros generate (hidden):
#[no_mangle]
pub extern "C" fn component_execute(ptr: *const u8, len: usize) -> u64 {
    // All WASM complexity handled automatically
}
```

**Benefits**:
- Zero extern "C" exposure for developers
- Focus on business logic, not WASM internals
- Familiar pattern from CosmWasm ecosystem
- Reduced learning curve and development time

## Code Generation Patterns

### Static Instance Management Pattern
**Pattern**: Single static instance with synchronized initialization
**Implementation**:
```rust
// Generated by #[component] macro
static mut COMPONENT_INSTANCE: Option<MyComponent> = None;
static COMPONENT_INIT_ONCE: std::sync::Once = std::sync::Once::new();

pub extern "C" fn component_init(config_ptr: *const u8, config_len: usize) -> u64 {
    COMPONENT_INIT_ONCE.call_once(|| {
        unsafe {
            COMPONENT_INSTANCE = Some(MyComponent::default());
        }
    });
    
    // Initialize with config
    unsafe {
        COMPONENT_INSTANCE.as_mut().unwrap().init(config)
    }
}
```

**Benefits**:
- Thread-safe initialization
- Single component instance per WASM module
- Proper lifecycle management
- Memory efficiency

### Result Encoding Pattern
**Pattern**: Encode results as u64 with pointer and length information
**Implementation**:
```rust
// Generated encoding functions
fn encode_success<T: Serialize>(value: &T) -> u64 {
    let bytes = multicodec::encode(value).unwrap();
    let ptr = bytes.as_ptr() as u64;
    let len = bytes.len() as u64;
    std::mem::forget(bytes); // Prevent deallocation
    (ptr << 32) | len
}

fn encode_error(message: &str) -> u64 {
    let error_bytes = format!(r#"{{"error":"{}"}}"#, message).into_bytes();
    let ptr = error_bytes.as_ptr() as u64;
    let len = error_bytes.len() as u64;
    std::mem::forget(error_bytes);
    (ptr << 32) | len | 0x8000000000000000 // Error flag
}
```

**Benefits**:
- Efficient data transfer across WASM boundary
- Clear error/success distinction
- Compatible with any WASM runtime
- Minimal marshalling overhead

### Memory Management Pattern
**Pattern**: Explicit allocation/deallocation exports for WASM hosts
**Implementation**:
```rust
// Generated memory management
#[no_mangle]
pub extern "C" fn allocate(size: usize) -> *mut u8 {
    let layout = std::alloc::Layout::from_size_align(size, 1).unwrap();
    unsafe { std::alloc::alloc(layout) }
}

#[no_mangle]
pub extern "C" fn deallocate(ptr: *mut u8, size: usize) {
    let layout = std::alloc::Layout::from_size_align(size, 1).unwrap();
    unsafe { std::alloc::dealloc(ptr, layout) }
}
```

**Benefits**:
- Host-controlled memory management
- No memory leaks across WASM boundary
- Standard WASM memory allocation pattern
- Compatible with all WASM runtimes

## Serialization Patterns

### Multicodec Integration Pattern
**Pattern**: Automatic multicodec serialization for all component data
**Implementation**:
```rust
// Generated serialization code
impl ComponentOperation for MyOperation {
    fn operation_type() -> &'static str {
        "MyOperation"
    }
}

impl MulticodecEncode for MyOperation {
    fn encode(&self) -> Result<Vec<u8>, MulticodecError> {
        // Automatic implementation via derive macro
    }
}

impl MulticodecDecode for MyOperation {
    fn decode(data: &[u8]) -> Result<Self, MulticodecError> {
        // Automatic implementation via derive macro
    }
}
```

**Benefits**:
- Self-describing data with format metadata
- Language-agnostic serialization
- Forward/backward compatibility
- Automatic implementation via derive macros

### Type-Safe Message Pattern
**Pattern**: Strongly-typed message enums with automatic trait implementations
**Implementation**:
```rust
#[derive(ComponentOperation, Serialize, Deserialize)]
pub enum MyOperation {
    ProcessData { data: Vec<u8> },
    GetStatus,
    Shutdown,
}

#[derive(ComponentResult, Serialize, Deserialize)]
pub enum MyResult {
    DataProcessed { result: String },
    Status { active: bool },
    Shutdown,
}
```

**Benefits**:
- Compile-time type safety
- Exhaustive pattern matching
- Automatic serialization
- Clear API documentation

## Error Handling Patterns

### Comprehensive Error Transformation Pattern
**Pattern**: Transform component errors into WASM-compatible encoded results
**Implementation**:
```rust
// Generated error handling
pub extern "C" fn component_execute(ptr: *const u8, len: usize) -> u64 {
    let operation = match decode_operation(ptr, len) {
        Ok(op) => op,
        Err(e) => return encode_error(&format!("Decode failed: {}", e)),
    };
    
    let result = unsafe {
        COMPONENT_INSTANCE.as_mut().unwrap().execute(operation)
    };
    
    match result {
        Ok(result) => encode_success(&result),
        Err(e) => encode_error(&format!("Execute failed: {}", e)),
    }
}
```

**Benefits**:
- Robust error propagation across WASM boundary
- No panics in generated code
- Descriptive error messages
- Graceful degradation

### Result Type Pattern
**Pattern**: Use Result types consistently throughout component API
**Implementation**:
```rust
// Component trait methods always return Results
impl Component for MyProcessor {
    fn init(&mut self, config: Self::Config) -> Result<(), ComponentError> {
        config.validate()?;
        // Initialization logic
        Ok(())
    }
    
    fn execute(&mut self, operation: Self::Operation) -> Result<Self::Result, ComponentError> {
        // Business logic with error handling
        match operation {
            MyOperation::ProcessData { data } => {
                let result = self.process_data(data)?;
                Ok(MyResult::DataProcessed { result })
            }
        }
    }
}
```

**Benefits**:
- Explicit error handling
- Composable error propagation
- Type-safe error information
- Consistent API patterns

## Testing Patterns

### UI Testing Pattern
**Pattern**: Use trybuild for compile-time macro behavior validation
**Implementation**:
```rust
// tests/ui/valid_component.rs
use airssys_wasm_component::component;

#[component(name = "test")]
pub struct TestComponent;

// tests/ui/invalid_component.rs
use airssys_wasm_component::component;

#[component] // Missing required name
pub struct InvalidComponent;

// tests/ui.rs
#[test]
fn ui() {
    let t = trybuild::TestCases::new();
    t.pass("tests/ui/valid_component.rs");
    t.compile_fail("tests/ui/invalid_component.rs");
}
```

**Benefits**:
- Validate macro expansion at compile time
- Test error message quality
- Catch edge cases and regressions
- Document expected macro behavior

### Integration Testing Pattern
**Pattern**: Test macro-generated code with actual WASM compilation
**Implementation**:
```rust
#[test]
fn test_generated_component() {
    // Create test component using macros
    // Compile to WASM
    // Load in WASM runtime
    // Test component functionality
    // Validate correct behavior
}
```

**Benefits**:
- End-to-end validation
- Real WASM runtime testing
- Performance validation
- Integration verification

## Documentation Patterns

### Example-Driven Documentation Pattern
**Pattern**: Lead with practical examples, explain details after
**Implementation**:
```rust
//! # Quick Start
//! 
//! ```rust
//! use airssys_wasm_component::{component, ComponentOperation};
//! 
//! #[derive(ComponentOperation)]
//! pub enum MyOperation {
//!     Process { data: String },
//! }
//! 
//! #[component(name = "my-processor")]
//! pub struct MyProcessor;
//! 
//! impl Component for MyProcessor {
//!     // Implementation
//! }
//! ```
//! 
//! This generates all necessary WASM exports automatically!
```

**Benefits**:
- Immediate practical value
- Copy-paste friendly examples
- Progressive complexity
- Clear value proposition

### Error Message Documentation Pattern
**Pattern**: Document common errors and their solutions
**Implementation**:
```rust
/// # Common Errors
/// 
/// - **Missing component name**: `#[component]` requires a name parameter
///   ```rust,compile_fail
///   #[component] // Error: missing name
///   pub struct MyComponent;
///   ```
///   
///   Solution: Add name parameter
///   ```rust
///   #[component(name = "my-component")]
///   pub struct MyComponent;
///   ```
```

**Benefits**:
- Proactive error resolution
- Improved developer experience
- Reduced support burden
- Clear troubleshooting guidance

---

**Pattern Status**: Complete architectural patterns defined
**Next Application**: Implement patterns in core macro development