//! Integration tests for #[executor] macro with real airssys-osl types
//!
//! These tests verify that the #[executor] macro correctly generates
//! OSExecutor trait implementations for all supported operation types.

#![cfg(feature = "macros")]

use airssys_osl::core::executor::OSExecutor;
use airssys_osl::prelude::*;

// =============================================================================
// Test 1: Single Filesystem Operation
// =============================================================================

#[derive(Debug)]
struct FileReadExecutor;

#[executor]
impl FileReadExecutor {
    async fn file_read(
        &self,
        operation: FileReadOperation,
        context: &ExecutionContext,
    ) -> OSResult<ExecutionResult> {
        let _ = (operation, context);
        Ok(ExecutionResult::success(b"test file content".to_vec()))
    }
}

#[tokio::test]
async fn test_macro_with_file_read_operation() {
    let executor = FileReadExecutor;
    let operation = FileReadOperation::new("/tmp/test.txt");
    let context = ExecutionContext::new(SecurityContext::new("test-user".to_string()));

    // Verify the trait methods are implemented by the macro
    assert_eq!(executor.name(), "FileReadExecutor");
    assert_eq!(
        executor.supported_operation_types(),
        vec![OperationType::Filesystem]
    );

    // Verify execute method is available (generated by macro)
    let result = executor.execute(operation, &context).await;
    assert!(result.is_ok(), "Execution should succeed");

    if let Ok(exec_result) = result {
        assert_eq!(exec_result.output, b"test file content");
    }
}

// =============================================================================
// Test 2: Single Process Operation
// =============================================================================

#[derive(Debug)]
struct ProcessSpawnExecutor;

#[executor]
impl ProcessSpawnExecutor {
    async fn process_spawn(
        &self,
        operation: ProcessSpawnOperation,
        context: &ExecutionContext,
    ) -> OSResult<ExecutionResult> {
        let _ = (operation, context);
        Ok(ExecutionResult::success(b"process spawned".to_vec()))
    }
}

#[tokio::test]
async fn test_macro_with_process_spawn_operation() {
    let executor = ProcessSpawnExecutor;
    let operation = ProcessSpawnOperation::new("echo".to_string());
    let context = ExecutionContext::new(SecurityContext::new("test-user".to_string()));

    // Verify trait methods are implemented by the macro
    assert_eq!(executor.name(), "ProcessSpawnExecutor");
    assert_eq!(
        executor.supported_operation_types(),
        vec![OperationType::Process]
    );

    // Verify execute method works
    let result = executor.execute(operation, &context).await;
    assert!(result.is_ok(), "Process spawn should succeed");
}

// =============================================================================
// Test 3: Single Network Operation
// =============================================================================

#[derive(Debug)]
struct NetworkConnectExecutor;

#[executor]
impl NetworkConnectExecutor {
    async fn network_connect(
        &self,
        operation: NetworkConnectOperation,
        context: &ExecutionContext,
    ) -> OSResult<ExecutionResult> {
        let _ = (operation, context);
        Ok(ExecutionResult::success(b"connected".to_vec()))
    }
}

#[tokio::test]
async fn test_macro_with_network_connect_operation() {
    let executor = NetworkConnectExecutor;
    let operation = NetworkConnectOperation::new("127.0.0.1:8080".to_string());
    let context = ExecutionContext::new(SecurityContext::new("test-user".to_string()));

    // Verify trait methods are implemented by the macro
    assert_eq!(executor.name(), "NetworkConnectExecutor");
    assert_eq!(
        executor.supported_operation_types(),
        vec![OperationType::Network]
    );

    // Verify execute method works
    let result = executor.execute(operation, &context).await;
    assert!(result.is_ok(), "Network connect should succeed");
}
