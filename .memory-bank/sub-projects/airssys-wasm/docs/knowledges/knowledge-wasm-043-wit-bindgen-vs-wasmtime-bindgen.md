# wit_bindgen vs wasmtime::component::bindgen! - Guest vs Host Bindgen

**Document ID:** KNOWLEDGE-WASM-043  
**Created:** 2026-01-16  
**Updated:** 2026-01-16  
**Category:** architecture  
**Maturity:** stable  

## Overview

This document explains the critical differences between `wit_bindgen::generate!` and `wasmtime::component::bindgen!`, clarifying when to use each macro for WebAssembly Component Model development. The key distinction: **`wit_bindgen` is for guests (WASM components), `wasmtime::component::bindgen!` is for hosts (Rust runtimes)**.

---

## Context

### Problem Statement

During WASM-TASK-034 implementation, there was confusion about which bindgen macro to use for host-side bindings. The lib.rs comments referenced `wit_bindgen::generate!`, but the actual code used `wasmtime::component::bindgen!`. This led to documentation drift and confusion about the correct approach.

**Root Cause:** The two macros serve fundamentally different purposes (guest vs host), but their similar names and overlapping functionality made the distinction unclear.

### Scope

This knowledge applies to:
- All host-side WIT binding generation in airssys-wasm
- All guest-side binding generation for WASM components
- Understanding when to use which tool in the WebAssembly Component Model ecosystem

### Prerequisites

- Understanding of WebAssembly Component Model concepts
- Familiarity with WIT (WebAssembly Interface Types) syntax
- Basic knowledge of Rust procedural macros

---

## Technical Content

### Core Concepts

#### The Two Bindgen Macros

There are **TWO completely different bindgen macros** in the Component Model ecosystem:

| Aspect | `wit_bindgen::generate!` | `wasmtime::component::bindgen!` |
|--------|--------------------------|----------------------------------|
| **Crate** | `wit-bindgen` (standalone) | `wasmtime` (internal) |
| **Purpose** | Generate **guest-side** bindings | Generate **host-side** bindings |
| **Used By** | WASM component authors | Host runtime implementers |
| **Generates** | Traits for components to implement | Traits for hosts to implement + registration helpers |
| **Imports** | Become function calls to host | Become trait methods host must implement |
| **Exports** | Become trait methods component must implement | Become functions component provides |
| **Registration** | Not applicable (guest doesn't register) | Generates `add_to_linker()` helper |

---

#### Conceptual Model

```
┌─────────────────────────────────────────────────────────────────┐
│                     WebAssembly Component Model                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────┐         ┌─────────────────────┐       │
│  │   GUEST (WASM)      │         │   HOST (Rust)       │       │
│  │                     │         │                     │       │
│  │  wit_bindgen::      │  ◄───┐  │  wasmtime::         │       │
│  │  generate!          │       │  │  component::        │       │
│  │                     │       │  │  bindgen!           │       │
│  │  Generates:         │       │  │                     │       │
│  │  - Import stubs     │───────┘  │  Generates:         │       │
│  │  - Export traits    │          │  - Host traits      │       │
│  │                     │          │  - add_to_linker()  │       │
│  └─────────────────────┘          └─────────────────────┘       │
│                                                                 │
│  Component implements exports    Host implements imports       │
│  Component calls imports         Host calls exports            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

### Implementation Details

#### 1. Guest-Side: `wit_bindgen::generate!`

**Used in:** WASM components (the plugins/extensions)

**Purpose:** Generate bindings for a WASM component to:
- **Import** host functions (call into the host)
- **Export** functions (be called by the host)

**Example - Guest Component:**

```rust
// In a WASM component's lib.rs

wit_bindgen::generate!({
    world: "runtime-host",
    path: "../wit/core",
});

// The macro generates:
// - Functions to call host imports (send, log, get, etc.)
// - Traits for the component to implement exports (ComponentLifecycle)

// Implement the exported interface
struct MyComponent;

impl exports::airssys::core::component_lifecycle::Guest for MyComponent {
    fn init(config: ComponentConfig) -> Result<(), ComponentError> {
        // Component initialization
        Ok(())
    }
    
    fn handle_message(msg: ComponentMessage) -> Result<Option<MessagePayload>, ComponentError> {
        // Call host function (generated by wit_bindgen)
        airssys::core::host_services::log(
            LogLevel::Info,
            "Received message".to_string(),
            None
        );
        
        Ok(None)
    }
}

// Export the component
wit_bindgen::export!(MyComponent with_types_in airssys::core);
```

**What `wit_bindgen::generate!` creates for guests:**
- Import functions become **function calls** (e.g., `host_services::log()`)
- Export interfaces become **traits to implement** (e.g., `Guest` trait)
- No registration code (guest doesn't register anything)

---

#### 2. Host-Side: `wasmtime::component::bindgen!`

**Used in:** Host runtime (airssys-wasm)

**Purpose:** Generate bindings for the host to:
- **Implement** imported functions (provide functionality to components)
- **Call** exported functions (invoke component code)

**Example - Host Runtime:**

```rust
// In airssys-wasm/src/lib.rs

wasmtime::component::bindgen!({
    world: "runtime-host",
    path: "wit/core",
});

// The macro generates:
// - `RuntimeHost` module with `add_to_linker()` function
// - Host traits for imported interfaces (what host must implement)
// - Export types for calling component functions

// Later in runtime/host_functions.rs:
use crate::RuntimeHost;
use crate::airssys::core::host_messaging;
use crate::runtime::engine::HostState;

// Implement the Host trait for imported functions
impl host_messaging::Host for HostState {
    fn send(&mut self, target: ComponentId, payload: MessagePayload) 
        -> Result<(), MessagingError> {
        // Host implementation - this is what components call
        if let Some(router) = &self.message_router {
            router.route_message(target, payload)?;
        }
        Ok(())
    }
    
    fn self_id(&mut self) -> ComponentId {
        self.component_id.clone()
    }
    
    // ... implement all 18 host functions
}

// Register with wasmtime Linker (ONE LINE!)
pub fn register_host_functions(linker: &mut Linker<HostState>) -> wasmtime::Result<()> {
    RuntimeHost::add_to_linker(linker, |state: &mut HostState| state)
}
```

**What `wasmtime::component::bindgen!` creates for hosts:**
- Import interfaces become **traits to implement** (e.g., `host_messaging::Host`)
- Export interfaces become **typed function getters** (to call component code)
- **`RuntimeHost::add_to_linker()`** helper for automatic registration

---

### Code Examples

#### Example 1: Complete Guest Component

```rust
// guest-component/src/lib.rs
// This runs INSIDE the WASM sandbox

wit_bindgen::generate!({
    world: "runtime-host",
    path: "../wit/core",
});

struct Calculator;

impl exports::airssys::core::component_lifecycle::Guest for Calculator {
    fn init(config: ComponentConfig) -> Result<(), ComponentError> {
        // Call host logging function (import)
        airssys::core::host_services::log(
            LogLevel::Info,
            format!("Calculator initialized: {}", config.component_id.name),
            None
        );
        Ok(())
    }
    
    fn handle_message(msg: ComponentMessage) -> Result<Option<MessagePayload>, ComponentError> {
        // Parse message
        let operands: Vec<i32> = serde_json::from_slice(&msg.payload.data)?;
        let result = operands.iter().sum::<i32>();
        
        // Store result (call host storage function)
        airssys::core::storage::set(
            "last_result".to_string(),
            MessagePayload::new(result.to_string().into_bytes())
        )?;
        
        // Return result
        Ok(Some(MessagePayload::new(result.to_string().into_bytes())))
    }
}

wit_bindgen::export!(Calculator with_types_in airssys::core);
```

**Build:**
```bash
cargo build --target wasm32-wasip1 --release
wasm-tools component new target/wasm32-wasip1/release/calculator.wasm \
    -o calculator-component.wasm
```

---

#### Example 2: Complete Host Implementation

```rust
// airssys-wasm/src/lib.rs
// This runs in the HOST (Rust native)

wasmtime::component::bindgen!({
    world: "runtime-host",
    path: "wit/core",
});

// airssys-wasm/src/runtime/host_functions.rs
use crate::RuntimeHost;
use crate::airssys::core::{host_messaging, host_services, storage};
use crate::runtime::engine::HostState;

// Implement messaging imports
impl host_messaging::Host for HostState {
    fn send(&mut self, target: ComponentId, payload: MessagePayload) 
        -> Result<(), MessagingError> {
        // Real implementation using message router
        if let Some(router) = &self.message_router {
            router.send_message(target, payload)?;
        }
        Ok(())
    }
    
    fn self_id(&mut self) -> ComponentId {
        self.component_id.clone()
    }
}

// Implement services imports
impl host_services::Host for HostState {
    fn log(&mut self, level: LogLevel, message: String, context: Option<Vec<(String, String)>>) {
        // Use tracing to log from components
        match level {
            LogLevel::Info => tracing::info!(?context, "{}", message),
            LogLevel::Error => tracing::error!(?context, "{}", message),
            // ... other levels
        }
    }
    
    fn current_time(&mut self) -> Timestamp {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap();
        Timestamp {
            seconds: now.as_secs(),
            nanoseconds: now.subsec_nanos(),
        }
    }
}

// Implement storage imports  
impl storage::Host for HostState {
    fn get(&mut self, key: String) -> Result<Option<MessagePayload>, StorageError> {
        // Use component-isolated storage backend
        self.storage_backend.get(&self.component_id, &key)
    }
    
    fn set(&mut self, key: String, value: MessagePayload) -> Result<(), StorageError> {
        self.storage_backend.set(&self.component_id, &key, value)
    }
}

// Registration is ONE LINE thanks to wasmtime::component::bindgen!
pub fn register_host_functions(linker: &mut Linker<HostState>) -> wasmtime::Result<()> {
    RuntimeHost::add_to_linker(linker, |state: &mut HostState| state)
}
```

---

### Configuration

**Guest Component Cargo.toml:**
```toml
[dependencies]
wit-bindgen = { version = "0.47", default-features = false, features = ["macros"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[profile.release]
lto = true
opt-level = "z"  # Optimize for size

[lib]
crate-type = ["cdylib"]

[package.metadata.component]
package = "airssys:core"
```

**Host Runtime Cargo.toml:**
```toml
[dependencies]
wasmtime = { version = "24.0", features = ["component-model", "async"] }
wit-bindgen = { version = "0.47", default-features = false, features = ["macros"] }  # ← Still needed for types!
```

**Why host needs BOTH:**
- `wasmtime` with `component-model` feature → Provides `wasmtime::component::bindgen!`
- `wit-bindgen` → Provides shared type definitions (if generating types separately)

---

## Usage Patterns

### Common Use Cases

#### Use Case 1: Implementing airssys-wasm Host (YOU ARE HERE)

**Scenario:** Building the host runtime that loads and executes WASM components

**Use:** `wasmtime::component::bindgen!`

**Why:** You need to:
- Implement host functions that components call (imports)
- Call component functions (exports)
- Register functions with wasmtime's Linker

**Location:** `airssys-wasm/src/lib.rs` (already correct!)

---

#### Use Case 2: Writing a WASM Component

**Scenario:** Building a plugin/extension that runs in airssys-wasm

**Use:** `wit_bindgen::generate!`

**Why:** You need to:
- Call host functions (imports like `send`, `log`, `get`)
- Implement component interface (export `ComponentLifecycle`)
- Compile to `wasm32-wasip1` target

**Location:** Component projects (e.g., `examples/calculator-component/src/lib.rs`)

---

#### Use Case 3: Generating Shared Types

**Scenario:** Both host and guests need access to WIT-defined types

**Options:**
1. **Option A:** Both use their respective bindgen macros (types duplicated but consistent)
2. **Option B:** Generate types once with `wit-bindgen`, share via crate (more complex)

**Recommendation:** Option A (what airssys-wasm does)
- Host generates types via `wasmtime::component::bindgen!` in `lib.rs`
- Guest generates types via `wit_bindgen::generate!` in component's `lib.rs`
- Types are identical (both from same WIT files), no drift

---

### Best Practices

#### 1. **Use the Right Tool for the Job**

✅ **DO:**
```rust
// In airssys-wasm (HOST):
wasmtime::component::bindgen!({ world: "runtime-host", path: "wit/core" });

// In calculator-component (GUEST):
wit_bindgen::generate!({ world: "runtime-host", path: "../wit/core" });
```

❌ **DON'T:**
```rust
// In airssys-wasm (HOST):
wit_bindgen::generate!({ world: "runtime-host", path: "wit/core" });  // WRONG!
// This generates guest bindings, not host bindings!
```

---

#### 2. **Leverage Automatic Registration**

✅ **DO:**
```rust
// With wasmtime::component::bindgen!, registration is automatic
RuntimeHost::add_to_linker(linker, |state| state)
```

❌ **DON'T:**
```rust
// Manual registration is unnecessary and error-prone
linker.root().instance("host-messaging")?
    .func_wrap("send", |_, (target, payload)| { ... })?
    .func_wrap("request", |_, (target, payload, timeout)| { ... })?
    // ... 16 more manual registrations
```

---

#### 3. **Keep WIT Files Synchronized**

✅ **DO:**
- Maintain WIT files in host repository
- Copy or symlink WIT files to guest components
- Use `package` and `@version` in WIT for compatibility

❌ **DON'T:**
- Duplicate WIT definitions
- Let host/guest WIT drift
- Forget to update guests when host WIT changes

---

#### 4. **Document Which Bindgen You're Using**

✅ **DO:**
```rust
// airssys-wasm/src/lib.rs

// HOST-SIDE BINDINGS: Use wasmtime::component::bindgen!
// This generates Host traits and add_to_linker helper
wasmtime::component::bindgen!({
    world: "runtime-host",
    path: "wit/core",
});
```

---

### Antipatterns

#### ❌ Antipattern 1: Using Guest Bindgen in Host

```rust
// airssys-wasm/src/lib.rs - WRONG!
wit_bindgen::generate!({  // ← Guest-side macro in host!
    world: "runtime-host",
    path: "wit/core",
});

// Problem: No RuntimeHost::add_to_linker() generated
// Problem: Traits are for components to implement, not hosts
// Result: Cannot register host functions with wasmtime
```

---

#### ❌ Antipattern 2: Manual Registration with wasmtime::component::bindgen!

```rust
// If you're using wasmtime::component::bindgen!, DON'T do this:
fn register_host_functions(linker: &mut Linker<HostState>) -> Result<()> {
    // UNNECESSARY! wasmtime::component::bindgen! already provides add_to_linker()
    linker.root().instance("host-messaging")?
        .func_wrap("send", |_, (target, payload)| { ... })?;
    // ...
}

// Instead, use the generated helper:
RuntimeHost::add_to_linker(linker, |state| state)
```

---

#### ❌ Antipattern 3: Confusion Between Crates

```rust
// Don't confuse the crates!

// WRONG: This is the internal wasmtime version
use wasmtime_wit_bindgen::generate;  // ← Don't use directly!

// RIGHT: Use the public API
wasmtime::component::bindgen!({ ... });  // ← Host-side
// OR
wit_bindgen::generate!({ ... });  // ← Guest-side
```

---

## Performance Considerations

### Performance Characteristics

Both bindgen macros generate **zero-cost abstractions**:
- No runtime overhead for type conversions (Canonical ABI)
- Direct function calls via wasmtime's optimized trampolines
- Trait implementations inline where possible

**Compile-time:**
- `wit_bindgen::generate!` is faster (simpler guest codegen)
- `wasmtime::component::bindgen!` is slower (generates more complex host infrastructure)

**Runtime:**
- Both have identical performance (same Canonical ABI)

---

### Optimization Opportunities

1. **Minimize WIT Scope:**
   ```rust
   // Only generate bindings for interfaces you use
   wasmtime::component::bindgen!({
       world: "runtime-host",
       path: "wit/core",
       interfaces: "
           import host-messaging;
           import storage;
       ",  // Skip host-services if not needed
   });
   ```

2. **Use `with` to Share Types:**
   ```rust
   // Avoid regenerating types by referencing existing bindings
   wasmtime::component::bindgen!({
       with: {
           "wasi:io/streams": wasmtime_wasi::bindings::io::streams,
       },
   });
   ```

---

## Integration Points

### Dependencies

**Guest Components:**
- `wit-bindgen` crate (macro and runtime support)
- Target: `wasm32-wasip1` or `wasm32-unknown-unknown`
- `wasm-tools` for building components

**Host Runtime:**
- `wasmtime` crate with `component-model` feature
- (Optional) `wit-bindgen` for shared type generation

---

### Compatibility

**wasmtime and wit-bindgen Version Compatibility:**

| wasmtime | wit-bindgen | Component Model Version |
|----------|-------------|-------------------------|
| 24.0     | 0.47.0      | Canonical ABI 0.2       |
| 25.0     | 0.48.0      | Canonical ABI 0.2       |
| 26.0     | 0.49.0      | Canonical ABI 0.2       |

**Important:** `wasmtime::component::bindgen!` is tied to the wasmtime version. Always use matching versions.

**WIT Compatibility:**
- WIT syntax is relatively stable
- Breaking changes announced in release notes
- Components target a specific Component Model version

---

### Migration Paths

#### Migrating from wit_bindgen to wasmtime::component::bindgen! (Host Side)

**Before (WRONG):**
```rust
// airssys-wasm/src/lib.rs
wit_bindgen::generate!({ world: "runtime-host", path: "wit/core" });

// airssys-wasm/src/runtime/host_functions.rs
fn register_messaging_functions(linker: &mut Linker<HostState>) -> Result<()> {
    linker.root().instance("host-messaging")?
        .func_wrap("send", |_, (target, payload)| { ... })?
        // ... 4 more manual registrations
    Ok(())
}
```

**After (CORRECT):**
```rust
// airssys-wasm/src/lib.rs
wasmtime::component::bindgen!({ world: "runtime-host", path: "wit/core" });

// airssys-wasm/src/runtime/host_functions.rs
use crate::RuntimeHost;
use crate::airssys::core::host_messaging;

impl host_messaging::Host for HostState {
    fn send(&mut self, target: ComponentId, payload: MessagePayload) 
        -> Result<(), MessagingError> {
        // Implementation
        Ok(())
    }
    // ... 4 more trait methods
}

fn register_host_functions(linker: &mut Linker<HostState>) -> wasmtime::Result<()> {
    RuntimeHost::add_to_linker(linker, |state| state)  // ONE LINE!
}
```

**Steps:**
1. Replace `wit_bindgen::generate!` with `wasmtime::component::bindgen!`
2. Implement `Host` traits instead of manual `func_wrap`
3. Replace all manual registrations with `RuntimeHost::add_to_linker()`
4. Remove 90% of registration boilerplate

---

## Security Considerations

### Security Implications

Both bindgen macros generate **type-safe** bindings following the Component Model's Canonical ABI:
- No raw pointer manipulation
- Bounds-checked memory access
- Validated type conversions

**Host-Side (`wasmtime::component::bindgen!`):**
- ✅ Type-safe trait implementations
- ✅ Compiler-enforced function signatures
- ⚠️ Host implementations can still have bugs (validate all component inputs!)

**Guest-Side (`wit_bindgen::generate!`):**
- ✅ Sandboxed execution (no direct host access)
- ✅ Can only call imported functions (explicit capability grant)
- ⚠️ Malicious guests can still call imports in harmful ways

---

### Threat Model

**Threats:**
1. **Confused Deputy:** Guest tricks host into performing unauthorized action
2. **Resource Exhaustion:** Guest calls expensive host functions repeatedly
3. **Type Confusion:** Bindings mismatch between host/guest (WIT drift)

**Mitigations:**
1. **Capability Checking:** Validate permissions in every host function implementation
2. **Rate Limiting:** Track call frequency, enforce quotas
3. **WIT Version Pinning:** Ensure host/guest use identical WIT definitions

---

### Compliance

- **Component Model Compliance:** Both macros generate compliant Canonical ABI code
- **airssys-osl Integration:** Host implementations must integrate with security policies (ADR-WASM-005)
- **Audit Logging:** Host implementations should log all component interactions

---

## Maintenance

### Review Schedule

**Quarterly** - Review when:
- wasmtime releases a new major version
- Component Model specification changes
- WIT syntax evolves

---

### Update Triggers

1. **Immediate:** Security vulnerability in wasmtime or wit-bindgen
2. **Immediate:** Breaking change in Component Model
3. **Quarterly:** New wasmtime/wit-bindgen versions
4. **Yearly:** Architecture review

---

### Owner/Maintainer

**Primary:** Runtime Module Maintainer  
**Secondary:** Architecture Team  
**Reviewers:** All developers working on host or guest code

---

## References

### Related Documentation

**ADRs:**
- **ADR-WASM-030:** Runtime Module Design (host functions)
- **ADR-WASM-027:** WIT Interface Design
- **ADR-WASM-025:** Clean-Slate Rebuild Architecture (module boundaries)

**Knowledges:**
- **KNOWLEDGE-WASM-042:** wit_bindgen Macro and Host Function Registration (now partially outdated)
- **KNOWLEDGE-WASM-031:** Foundational Architecture
- **KNOWLEDGE-WASM-037:** Rebuild Architecture

**External References:**
- [wasmtime::component::bindgen! Documentation](https://docs.wasmtime.dev/api/wasmtime/component/macro.bindgen.html)
- [wit-bindgen Documentation](https://docs.rs/wit-bindgen/latest/wit_bindgen/)
- [Component Model Specification](https://component-model.bytecodealliance.org/)
- [Building WebAssembly Components in Rust](https://component-model.bytecodealliance.org/language-support/rust.html)
- [Radu Matei's Host Implementation Guide](https://radu-matei.com/pdf/wasm-components-host-implementations.pdf)

---

### Workspace Standards

**Standards Applied:**
- §2.1: 3-layer import organization (std → wasmtime → crate)
- §4.3: Module architecture patterns (runtime/ responsibilities)
- §6.1: YAGNI principles (appropriate tool selection)

**Compliance Notes:**
- Module boundaries enforced (ADR-WASM-025)
- Host-side bindings only in runtime/ and system/
- Guest-side bindings only in example components

---

## History

### Version History

- **2026-01-16:** 1.0 - Initial creation documenting bindgen macro differences

### Review History

- **2026-01-16:** Created by Memory Bank Manager based on WASM-TASK-034 findings

---

**Template Version:** 1.0  
**Document Version:** 1.0  
**Last Updated:** 2026-01-16
