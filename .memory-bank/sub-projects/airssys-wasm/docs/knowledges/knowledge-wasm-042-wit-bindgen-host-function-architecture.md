# wit_bindgen Macro and Host Function Registration Architecture

**Document ID:** KNOWLEDGE-WASM-042  
**Created:** 2026-01-15  
**Updated:** 2026-01-15  
**Category:** architecture  
**Maturity:** stable  

## Overview

This document explains how the `wit_bindgen::generate!` macro in `lib.rs` generates Rust trait definitions from WIT interfaces, and how these generated traits must be implemented and registered as host functions using wasmtime's Component Model `Linker`. This is the foundational architecture for enabling WASM components to call into host-provided functionality.

---

## Context

### Problem Statement

WASM components need to call host-provided functions (messaging, logging, storage, etc.). The WebAssembly Component Model uses WIT (WebAssembly Interface Types) to define these interfaces, but there must be a mechanism to:

1. Generate Rust types and traits from WIT definitions
2. Allow the host to implement these traits
3. Register these implementations with the wasmtime runtime
4. Enable WASM components to call these functions at runtime

### Scope

This knowledge applies to:
- All host-provided functions imported by WASM components
- The relationship between WIT files → generated traits → Linker registration
- The runtime/ module's host_fn.rs implementation (Layer 2B)
- Component instantiation and import resolution

### Prerequisites

- Understanding of WIT (WebAssembly Interface Types) syntax
- Familiarity with wasmtime's Component Model
- Knowledge of Rust traits and type systems
- Understanding of airssys-wasm's six-module architecture (ADR-WASM-025)

---

## Technical Content

### Core Concepts

#### 1. The Three-Stage Architecture

```
Stage 1: WIT Definition (Design Time)
    ↓
Stage 2: wit_bindgen::generate! (Compile Time)
    ↓
Stage 3: Linker Registration (Runtime)
```

**Stage 1: WIT Definition Files**

WIT files define interfaces in a language-agnostic format:

```wit
// wit/core/host-messaging.wit
interface host-messaging {
    send: func(target: component-id, payload: message-payload) 
        -> result<_, messaging-error>;
}
```

**Stage 2: wit_bindgen Trait Generation**

The `wit_bindgen::generate!` macro in `lib.rs` generates Rust traits:

```rust
// Generated by wit_bindgen::generate! in lib.rs
pub mod exports {
    pub mod host_messaging {
        pub trait Host {
            fn send(&mut self, target: ComponentId, payload: MessagePayload) 
                -> Result<(), MessagingError>;
        }
    }
}
```

**Stage 3: Linker Registration**

The `runtime/host_fn.rs` module registers implementations with wasmtime's Linker:

```rust
// runtime/host_fn.rs
pub fn register_host_functions<T>(
    linker: &mut wasmtime::component::Linker<T>,
) -> Result<()> {
    register_messaging_functions(linker)?;
    register_services_functions(linker)?;
    register_storage_functions(linker)?;
    Ok(())
}
```

---

#### 2. The wit_bindgen::generate! Macro

**Location:** `airssys-wasm/src/lib.rs` lines 151-154

**Purpose:** Generate Rust bindings from WIT world definition

**Invocation:**
```rust
wit_bindgen::generate!({
    world: "component",
    path: "wit/core",
});
```

**What It Generates:**

From the WIT world definition in `wit/core/world.wit`:

```wit
world component {
    /// Host-provided capabilities (components import these)
    import host-messaging;
    import host-services;
    import storage;

    /// Guest-implemented interfaces (components export these)
    export component-lifecycle;
}
```

The macro generates:

1. **Type Definitions** from `types.wit`:
   - `ComponentId`, `MessagePayload`, `CorrelationId`, etc.
   - All WIT records → Rust structs
   - All WIT variants → Rust enums

2. **Error Types** from `errors.wit`:
   - `MessagingError`, `StorageError`, `ComponentError`, etc.

3. **Host Function Traits** (the critical part for this task):
   - One trait per imported interface
   - Function signatures matching WIT function definitions
   - Proper Rust types with Result returns

4. **Guest Function Traits**:
   - Traits for exported functions (component-lifecycle)

**Key Insight:** The generated traits are the CONTRACT that host functions must implement.

---

#### 3. The 18 Host Functions

The three imported interfaces define exactly 18 host functions:

**host-messaging.wit (5 functions):**
```wit
interface host-messaging {
    send: func(target: component-id, payload: message-payload) 
        -> result<_, messaging-error>;
    
    request: func(target: component-id, payload: message-payload, timeout-ms: u64) 
        -> result<correlation-id, messaging-error>;
    
    cancel-request: func(request-id: request-id) 
        -> result<_, messaging-error>;
    
    broadcast: func(targets: list<component-id>, payload: message-payload) 
        -> result<_, messaging-error>;
    
    self-id: func() -> component-id;
}
```

**host-services.wit (6 functions):**
```wit
interface host-services {
    log: func(level: log-level, message: string, 
             context: option<list<tuple<string, string>>>);
    
    current-time: func() -> timestamp;
    
    current-time-millis: func() -> u64;
    
    sleep-millis: func(duration-ms: u64);
    
    list-components: func() -> list<component-id>;
    
    get-component-metadata: func(id: component-id) 
        -> result<component-info, component-error>;
}
```

**storage.wit (6 functions):**
```wit
interface storage {
    get: func(key: string) -> result<option<storage-value>, storage-error>;
    
    set: func(key: string, value: storage-value) -> result<_, storage-error>;
    
    delete: func(key: string) -> result<_, storage-error>;
    
    exists: func(key: string) -> result<bool, storage-error>;
    
    list-keys: func(prefix: option<string>) -> result<list<string>, storage-error>;
    
    usage: func() -> result<storage-usage, storage-error>;
}
```

**Total: 5 + 6 + 6 = 18 host functions**

---

#### 4. Linker Registration Architecture

**What is wasmtime::component::Linker?**

From official Wasmtime documentation:

> "A type used to instantiate Components. This type is used to both link components together as well as supply host functionality to components. Values are defined in a Linker by their import name and then components are instantiated with a Linker using the names provided for name resolution of the component's imports."

**Registration Pattern:**

```rust
use wasmtime::component::Linker;

pub fn register_messaging_functions<T>(
    linker: &mut Linker<T>,
) -> Result<()> {
    linker
        .root()
        .instance("host-messaging")?
        .func_wrap("send", |_store: StoreContextMut<T>, 
                            (target, payload): (ComponentId, MessagePayload)| {
            // STUB implementation for now
            Ok(())
        })?;
    
    // Register other 4 functions: request, cancel-request, broadcast, self-id
    Ok(())
}
```

**Critical Requirements:**

1. **Function signatures MUST match generated trait signatures exactly**
   - Wrong signature = linkage error at component instantiation
   - Type mismatches caught at runtime, not compile-time

2. **Function names MUST match WIT function names**
   - WIT: `send` → Linker: `"send"`
   - WIT: `cancel-request` → Linker: `"cancel-request"`

3. **Instance names MUST match WIT interface names**
   - WIT: `interface host-messaging` → Linker: `instance("host-messaging")`

---

### Implementation Details

#### Generated Trait Structure (Conceptual)

When `wit_bindgen::generate!` processes the WIT files, it generates traits like:

```rust
// Generated in lib.rs by wit_bindgen macro
// (Actual generated code is more complex, this is simplified)

pub mod host_messaging {
    use super::*;
    
    pub trait Host {
        fn send(
            &mut self,
            target: ComponentId,
            payload: MessagePayload,
        ) -> Result<(), MessagingError>;
        
        fn request(
            &mut self,
            target: ComponentId,
            payload: MessagePayload,
            timeout_ms: u64,
        ) -> Result<CorrelationId, MessagingError>;
        
        // ... other 3 functions
    }
}

pub mod host_services {
    use super::*;
    
    pub trait Host {
        fn log(
            &mut self,
            level: LogLevel,
            message: String,
            context: Option<Vec<(String, String)>>,
        );
        
        fn current_time(&mut self) -> Timestamp;
        
        // ... other 4 functions
    }
}

pub mod storage {
    use super::*;
    
    pub trait Host {
        fn get(
            &mut self,
            key: String,
        ) -> Result<Option<StorageValue>, StorageError>;
        
        fn set(
            &mut self,
            key: String,
            value: StorageValue,
        ) -> Result<(), StorageError>;
        
        // ... other 4 functions
    }
}
```

**Note:** These traits are NOT directly implemented by the host in typical usage. Instead, wasmtime's `Linker` provides a lower-level registration API (`func_wrap`) that doesn't require implementing the trait. The trait serves as documentation of the expected signature.

---

#### Linker Registration Pattern (runtime/host_fn.rs)

**Module Responsibility:** runtime/ (Layer 2B)

**Allowed Imports:**
- ✅ `core/` (Layer 0)
- ✅ `security/` (Layer 1)
- ✅ `wasmtime` crate

**Forbidden Imports (ADR-WASM-025):**
- ❌ `component/` (Layer 3A)
- ❌ `messaging/` (Layer 3B)
- ❌ `system/` (Layer 4)

**Implementation Pattern:**

```rust
// runtime/host_fn.rs
use wasmtime::component::{Linker, ResourceType};
use wasmtime::{Result, StoreContextMut};

// Import types generated by wit_bindgen in lib.rs
use crate::{
    ComponentId, MessagePayload, CorrelationId, RequestId,
    MessagingError, StorageError, ComponentError,
    LogLevel, Timestamp, StorageValue, StorageUsage,
};

/// Register all host functions with the linker
pub fn register_host_functions<T>(
    linker: &mut Linker<T>,
) -> Result<()> {
    register_messaging_functions(linker)?;
    register_services_functions(linker)?;
    register_storage_functions(linker)?;
    Ok(())
}

/// Register host-messaging interface functions
fn register_messaging_functions<T>(
    linker: &mut Linker<T>,
) -> Result<()> {
    let mut instance = linker.root().instance("host-messaging")?;
    
    // Function 1: send
    instance.func_wrap(
        "send",
        |_store: StoreContextMut<T>, 
         (target, payload): (ComponentId, MessagePayload)| {
            // STUB: Actual implementation in Phase 6
            Ok(())
        },
    )?;
    
    // Function 2: request
    instance.func_wrap(
        "request",
        |_store: StoreContextMut<T>,
         (target, payload, timeout_ms): (ComponentId, MessagePayload, u64)| {
            // STUB: Return dummy correlation ID
            Ok(CorrelationId {
                value: "stub-correlation-id".to_string(),
            })
        },
    )?;
    
    // Function 3: cancel-request
    instance.func_wrap(
        "cancel-request",
        |_store: StoreContextMut<T>, (request_id,): (RequestId,)| {
            // STUB
            Ok(())
        },
    )?;
    
    // Function 4: broadcast
    instance.func_wrap(
        "broadcast",
        |_store: StoreContextMut<T>,
         (targets, payload): (Vec<ComponentId>, MessagePayload)| {
            // STUB
            Ok(())
        },
    )?;
    
    // Function 5: self-id
    instance.func_wrap(
        "self-id",
        |_store: StoreContextMut<T>, (): ()| {
            // STUB: Return dummy component ID
            Ok(ComponentId {
                namespace: "stub".to_string(),
                name: "stub-component".to_string(),
                instance: "v1".to_string(),
            })
        },
    )?;
    
    Ok(())
}

// Similar functions for register_services_functions and register_storage_functions
```

---

### Code Examples

#### Example 1: Full Host Function Registration

```rust
// runtime/host_fn.rs
use wasmtime::component::Linker;
use wasmtime::{Result, StoreContextMut};
use crate::{
    ComponentId, MessagePayload, CorrelationId,
    MessagingError, LogLevel, Timestamp,
};

pub fn register_host_functions<T>(
    linker: &mut Linker<T>,
) -> Result<()> {
    register_messaging_functions(linker)?;
    register_services_functions(linker)?;
    register_storage_functions(linker)?;
    Ok(())
}

fn register_messaging_functions<T>(
    linker: &mut Linker<T>,
) -> Result<()> {
    linker
        .root()
        .instance("host-messaging")?
        .func_wrap("send", stub_send)?
        .func_wrap("request", stub_request)?
        .func_wrap("cancel-request", stub_cancel_request)?
        .func_wrap("broadcast", stub_broadcast)?
        .func_wrap("self-id", stub_self_id)?;
    Ok(())
}

// Stub implementations (Phase 5 - registration only)
fn stub_send<T>(
    _store: StoreContextMut<T>,
    (_target, _payload): (ComponentId, MessagePayload),
) -> Result<()> {
    Ok(())
}

fn stub_request<T>(
    _store: StoreContextMut<T>,
    (_target, _payload, _timeout): (ComponentId, MessagePayload, u64),
) -> Result<CorrelationId> {
    Ok(CorrelationId {
        value: "stub".to_string(),
    })
}
```

---

#### Example 2: Component Instantiation Using Registered Host Functions

```rust
// Example showing how registered host functions are used
use wasmtime::{Engine, Store};
use wasmtime::component::{Component, Linker};

fn instantiate_component() -> Result<()> {
    let engine = Engine::default();
    let mut store = Store::new(&engine, ());
    
    // Load component
    let component = Component::from_file(&engine, "my-component.wasm")?;
    
    // Create linker and register host functions
    let mut linker = Linker::new(&engine);
    crate::runtime::host_fn::register_host_functions(&mut linker)?;
    
    // Instantiate - wasmtime resolves imports using registered functions
    let instance = linker.instantiate(&mut store, &component)?;
    
    // Now the component can call host functions like `send`, `log`, `get`, etc.
    Ok(())
}
```

---

### Configuration

**No runtime configuration required.** Host function registration happens at component instantiation time using the Linker API.

**Compile-time configuration:**

```toml
# Cargo.toml
[dependencies]
wasmtime = { version = "29.0", features = ["component-model"] }
wit-bindgen = "0.37"
```

---

## Usage Patterns

### Common Use Cases

1. **Component Instantiation**
   - Create Linker
   - Call `register_host_functions`
   - Instantiate component
   - Component can now call host functions

2. **Adding New Host Functions**
   - Add function to WIT file
   - Re-run `wit_bindgen::generate!` (happens automatically on build)
   - Add registration in `runtime/host_fn.rs`
   - Implement function body (in Phase 6)

3. **Testing Host Functions**
   - Create test Linker
   - Register functions
   - Load test component
   - Verify component can call functions

---

### Best Practices

1. **Stub Implementations First (YAGNI)**
   - Register function signatures immediately (Phase 5)
   - Implement bodies later when needed (Phase 6)
   - Prevents blocking other development

2. **Match WIT Signatures Exactly**
   - Copy-paste from generated traits
   - Any mismatch = runtime linkage error
   - Use `wit-bindgen` generated types, don't redefine

3. **Group by WIT Interface**
   - One registration function per WIT interface
   - `register_messaging_functions`, `register_services_functions`, etc.
   - Matches WIT file structure

4. **Use func_wrap for Type Safety**
   - `func_wrap` provides some type checking
   - Better than `func_new` (fully dynamic)
   - Rust compiler catches some signature mismatches

5. **Document Function Purpose**
   - Link to WIT file defining the function
   - Explain stub vs real implementation
   - Note which Phase implements the body

---

### Antipatterns

❌ **Defining Host Functions Without WIT**
```rust
// BAD: Arbitrary host function not in WIT
linker.root().func_wrap("my-custom-func", |_, ()| Ok(()))?;
// Component can't import this - not in WIT world
```

❌ **Wrong Function Signatures**
```rust
// BAD: Signature doesn't match WIT
// WIT says: send(target: component-id, payload: message-payload)
linker.root().instance("host-messaging")?
    .func_wrap("send", |_store, (target,): (ComponentId,)| {
        // Missing payload parameter!
        Ok(())
    })?;
```

❌ **Implementing Bodies in runtime/ (Phase 5)**
```rust
// BAD: Full implementation belongs in Phase 6
fn register_messaging_functions<T>(linker: &mut Linker<T>) -> Result<()> {
    linker.root().instance("host-messaging")?
        .func_wrap("send", |store, (target, payload)| {
            // BAD: Accessing message broker, actor system, etc.
            let broker = store.data().message_broker();
            broker.route_message(target, payload)?; // FORBIDDEN
            Ok(())
        })?;
    Ok(())
}
// This violates Layer 2 responsibilities and imports forbidden modules
```

❌ **Hardcoding Instance Names**
```rust
// BAD: Magic strings instead of WIT-defined names
linker.root().instance("messaging-functions")?; // Wrong!
// WIT defines: interface host-messaging
// Linker must use: instance("host-messaging")
```

---

## Performance Considerations

### Performance Characteristics

- **Registration:** O(n) where n = number of host functions (18 in our case)
- **Call Overhead:** Minimal - wasmtime optimized for host calls
- **Memory:** Linker stores function pointers, negligible overhead

### Optimization Opportunities

1. **Lazy Registration**
   - Only register functions actually imported by component
   - Requires introspecting component imports
   - Minor optimization, likely not worth complexity

2. **Batch Registration**
   - Current approach already batches by interface
   - Further batching unlikely to improve performance

### Benchmarks

No benchmarks required for registration (one-time cost at instantiation).

Host function call performance measured in Phase 6 (actual implementations).

---

## Integration Points

### Dependencies

**Direct Dependencies:**
- `wasmtime` crate (Component Model API)
- `wit-bindgen` crate (macro for generating traits)
- Generated types from `lib.rs` (ComponentId, MessagePayload, etc.)

**Indirect Dependencies:**
- WIT files in `wit/core/` directory
- core/ module types (via generated types)
- security/ module (for future capability checks in Phase 6)

### Compatibility

**Wasmtime Version:** 29.0+
- Component Model requires wasmtime 29.0 or newer
- Breaking changes rare but possible in major versions

**wit-bindgen Version:** 0.37+
- Tied to wasmtime version
- Must match wasmtime's Component Model version

**WIT Versioning:**
- Interface names support semantic versioning
- Example: `host-messaging@0.2.0`
- Linker performs semver-aware name resolution

### Migration Paths

**If WIT changes (adding functions):**
1. Update WIT file
2. Rebuild (wit_bindgen regenerates traits)
3. Add new function registration in `runtime/host_fn.rs`
4. Update tests

**If WIT changes (removing functions):**
1. Remove from WIT file
2. Rebuild (wit_bindgen removes trait methods)
3. Remove registration from `runtime/host_fn.rs`
4. Component using old interface will fail instantiation

---

## Security Considerations

### Security Implications

1. **Host Functions = Attack Surface**
   - Every host function is a potential vulnerability
   - Components can call these functions arbitrarily
   - Must validate all inputs in Phase 6 implementations

2. **No Capability Checking Yet**
   - Phase 5: Registration only, no checks
   - Phase 6: Must integrate with security/ module
   - All host functions must check component capabilities

3. **Stub Implementations Are Unsafe**
   - Current stubs return dummy data
   - Do NOT use in production
   - Only for registration testing

### Threat Model

**Threats:**
- Malicious component calling host functions with malicious inputs
- Component exhausting host resources (DoS)
- Component accessing unauthorized data

**Mitigations (Phase 6):**
- Capability validation before executing host function
- Input validation and sanitization
- Rate limiting and resource quotas
- Audit logging of all host function calls

### Compliance

- Must follow airssys-osl security integration (KNOWLEDGE-WASM-020)
- Capability-based security model (ADR-WASM-005)
- Deny-by-default principle

---

## Maintenance

### Review Schedule

**Quarterly** - Review when:
- Wasmtime releases major version
- WIT specification changes
- New host functions added

### Update Triggers

1. **Immediate:** Security vulnerability in wasmtime
2. **Immediate:** WIT specification breaking change
3. **Quarterly:** New host function requirements
4. **Yearly:** Architecture review

### Owner/Maintainer

**Primary:** Runtime module maintainer  
**Secondary:** Architecture team  
**Reviewers:** Security team (for Phase 6 implementations)

---

## References

### Related Documentation

**ADRs:**
- **ADR-WASM-027:** WIT Interface Design (defines the 18 host functions)
- **ADR-WASM-030:** Runtime Module Design (host_fn.rs specification)
- **ADR-WASM-025:** Clean-Slate Rebuild Architecture (module boundaries)

**Knowledges:**
- **KNOWLEDGE-WASM-031:** Foundational Architecture
- **KNOWLEDGE-WASM-037:** Rebuild Architecture - Clean Slate
- **KNOWLEDGE-WASM-039:** Runtime Module Responsibility

**External References:**
- [wit-bindgen Documentation](https://docs.rs/wit-bindgen/latest/wit_bindgen/)
- [Wasmtime Component Model](https://docs.wasmtime.dev/api/wasmtime/component/)
- [Wasmtime Linker API](https://docs.wasmtime.dev/api/wasmtime/component/struct.Linker.html)
- [WebAssembly Component Model](https://component-model.bytecodealliance.org/)
- [WIT Specification](https://component-model.bytecodealliance.org/design/wit.html)

### Workspace Standards

**Standards Applied:**
- §2.1: 3-layer import organization (std → wasmtime → crate::core)
- §4.3: Module architecture patterns (runtime/ responsibilities)
- §6.1: YAGNI principles (stub implementations Phase 5, bodies Phase 6)

**Compliance Notes:**
- Module boundaries strictly enforced (ADR-WASM-025)
- No forbidden imports from component/, messaging/, system/
- All types imported from generated `crate::*` (from wit_bindgen)

---

## History

### Version History

- **2026-01-15:** 1.0 - Initial creation documenting wit_bindgen → Linker architecture

### Review History

- **2026-01-15:** Created by Memory Bank Manager - Initial documentation

---

**Template Version:** 1.0  
**Document Version:** 1.0  
**Last Updated:** 2026-01-15
