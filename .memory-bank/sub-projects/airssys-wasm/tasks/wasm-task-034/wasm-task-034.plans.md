# WASM-TASK-034: Implementation Plans - Host Functions Registration

## Overview

This task implements **host function registration** for WASM components in the `runtime/host_fn.rs` module. This is the critical infrastructure that enables WASM components to call host-provided functions for messaging, logging, storage, and other services.

**Critical Context:** The `wit_bindgen::generate!` macro in `lib.rs` (lines 151-154) generates Rust trait definitions from WIT files. These traits define the CONTRACT for the 18 host functions that this task will register with wasmtime's Linker.

**Phase:** Phase 5 - Runtime Module (Layer 2B)  
**Layer:** Layer 2B (Runtime)  
**Status:** Stub implementations only (full implementations deferred to Phase 6 per YAGNI)

---

## wit_bindgen Architecture Context (KNOWLEDGE-WASM-042)

### The Three-Stage Architecture

Understanding the connection between WIT definitions, generated traits, and Linker registration is CRITICAL for this task.

```
Stage 1: WIT Definition (Design Time)
    ↓
Stage 2: wit_bindgen::generate! (Compile Time)
    ↓
Stage 3: Linker Registration (Runtime) ← THIS TASK
```

**Stage 1: WIT Definition Files**

WIT files in `wit/core/` define interfaces in a language-agnostic format:

```wit
// wit/core/host-messaging.wit
interface host-messaging {
    send: func(target: component-id, payload: message-payload) 
        -> result<_, messaging-error>;
}
```

**Stage 2: wit_bindgen Trait Generation**

The `wit_bindgen::generate!` macro in `lib.rs` lines 151-154 generates Rust traits:

```rust
// Generated by wit_bindgen::generate! in lib.rs
pub mod exports {
    pub mod host_messaging {
        pub trait Host {
            fn send(&mut self, target: ComponentId, payload: MessagePayload) 
                -> Result<(), MessagingError>;
        }
    }
}
```

**Stage 3: Linker Registration (This Task)**

The `runtime/host_fn.rs` module registers implementations with wasmtime's Linker:

```rust
// runtime/host_fn.rs (what we're implementing)
pub fn register_host_functions<T>(
    linker: &mut wasmtime::component::Linker<T>,
) -> Result<()> {
    register_messaging_functions(linker)?;
    register_services_functions(linker)?;
    register_storage_functions(linker)?;
    Ok(())
}
```

**Key Insight:** The generated traits are the CONTRACT that host functions must implement. The function signatures in Stage 3 MUST match the generated trait signatures EXACTLY.

---

## The 18 Host Functions

The three imported interfaces define exactly 18 host functions that MUST be registered:

### host-messaging.wit (5 functions)

1. **send** - Fire-and-forget message to target component
   ```wit
   send: func(target: component-id, payload: message-payload) 
       -> result<_, messaging-error>;
   ```

2. **request** - Async RPC request with correlation ID
   ```wit
   request: func(target: component-id, payload: message-payload, timeout-ms: u64) 
       -> result<correlation-id, messaging-error>;
   ```

3. **cancel-request** - Cancel pending request
   ```wit
   cancel-request: func(request-id: request-id) 
       -> result<_, messaging-error>;
   ```

4. **broadcast** - Send to multiple targets
   ```wit
   broadcast: func(targets: list<component-id>, payload: message-payload) 
       -> result<_, messaging-error>;
   ```

5. **self-id** - Get current component's ID
   ```wit
   self-id: func() -> component-id;
   ```

### host-services.wit (6 functions)

6. **log** - Write log message
   ```wit
   log: func(level: log-level, message: string, 
            context: option<list<tuple<string, string>>>);
   ```

7. **current-time** - Get high-precision timestamp
   ```wit
   current-time: func() -> timestamp;
   ```

8. **current-time-millis** - Get Unix milliseconds
   ```wit
   current-time-millis: func() -> u64;
   ```

9. **sleep-millis** - Async sleep
   ```wit
   sleep-millis: func(duration-ms: u64);
   ```

10. **list-components** - List all active components
    ```wit
    list-components: func() -> list<component-id>;
    ```

11. **get-component-metadata** - Get component info
    ```wit
    get-component-metadata: func(id: component-id) 
        -> result<component-info, component-error>;
    ```

### storage.wit (6 functions)

12. **get** - Get value from storage
    ```wit
    get: func(key: string) -> result<option<storage-value>, storage-error>;
    ```

13. **set** - Set value in storage
    ```wit
    set: func(key: string, value: storage-value) -> result<_, storage-error>;
    ```

14. **delete** - Delete key from storage
    ```wit
    delete: func(key: string) -> result<_, storage-error>;
    ```

15. **exists** - Check if key exists
    ```wit
    exists: func(key: string) -> result<bool, storage-error>;
    ```

16. **list-keys** - List keys with optional prefix
    ```wit
    list-keys: func(prefix: option<string>) -> result<list<string>, storage-error>;
    ```

17. **usage** - Get storage usage stats
    ```wit
    usage: func() -> result<storage-usage, storage-error>;
    ```

**Total: 5 + 6 + 6 = 18 host functions**

---

## Relevant References

### ADRs (Architecture Decision Records)

- **ADR-WASM-025:** Clean-Slate Rebuild Architecture (CRITICAL - defines six-module architecture)
- **ADR-WASM-030:** Runtime Module Design (defines runtime/ structure and responsibilities)
- **ADR-WASM-027:** WIT Interface Design (defines the 18 host functions in WIT)

### Knowledge Documents

- **KNOWLEDGE-WASM-042:** wit_bindgen Macro and Host Function Registration Architecture (CRITICAL - THIS TASK'S FOUNDATION)
  - Explains the three-stage architecture (WIT → generated traits → Linker)
  - Lists all 18 host functions with signatures
  - Provides registration patterns and examples
  - Documents strong evidence from official Wasmtime/wit-bindgen documentation

### System Patterns

- **Module boundaries (ADR-WASM-025):**
  - runtime/ is Layer 2B
  - Can import: core/, security/
  - Cannot import: component/, messaging/, system/

### PROJECTS_STANDARD.md Compliance

- **§2.1:** 3-Layer Import Organization
  - Layer 1: std imports
  - Layer 2: wasmtime imports
  - Layer 3: crate::core, crate::security imports

- **§2.2:** No FQN in Type Annotations
  - Import types at top
  - Use simple names in signatures

- **§4.3:** Module Architecture Patterns
  - mod.rs contains ONLY module declarations
  - NO type re-exports in mod.rs

- **§6.1:** YAGNI Principles
  - Stub implementations in Phase 5 (registration only)
  - Full implementations deferred to Phase 6 (when needed)

- **§6.2:** Avoid `dyn` Patterns
  - Use static dispatch where possible
  - Prefer generics over trait objects

- **§6.4:** Implementation Quality Gates
  - Zero warnings
  - Comprehensive tests
  - Safety first

### Rust Guidelines Applied

- **M-DESIGN-FOR-AI:** Idiomatic APIs, thorough docs, testable
- **M-MODULE-DOCS:** Module documentation with examples
- **M-STATIC-VERIFICATION:** All lints enabled, clippy used

### Documentation Standards

- **Diátaxis Type:** Reference documentation for host function APIs
- **Quality:** Professional tone, no hyperbole per documentation-quality-standards.md

---

## Module Placement

**Code will be placed in:** `runtime/host_fn.rs` (Layer 2B)

**Module responsibilities (per ADR-WASM-025):**
- runtime/ owns WASM execution
- Registers host functions with wasmtime's Linker
- Provides stub implementations (YAGNI - Phase 5)

**Allowed imports:**
- ✅ `core/` (Layer 0)
- ✅ `security/` (Layer 1)
- ✅ `wasmtime` crate

**Forbidden imports (ADR-WASM-025):**
- ❌ `component/` (Layer 3A)
- ❌ `messaging/` (Layer 3B)
- ❌ `system/` (Layer 4)

**Verification command (for implementer to run after implementation):**
```bash
# Check for forbidden imports - ALL MUST RETURN EMPTY
grep -rn "use crate::component" airssys-wasm/src/runtime/
grep -rn "use crate::messaging" airssys-wasm/src/runtime/
grep -rn "use crate::system" airssys-wasm/src/runtime/
```
**Expected:** No output (clean architecture)

---

## Implementation Actions

### Action 1: Create runtime/host_fn.rs with Registration Infrastructure

**Objective:** Implement the main registration function and infrastructure for all 18 host functions.

**Steps:**

1. Create `airssys-wasm/src/runtime/host_fn.rs`

2. Add imports following §2.1 (3-Layer Import Organization):
   ```rust
   // Layer 1: Standard library imports
   
   // Layer 2: Third-party crate imports
   use wasmtime::component::Linker;
   use wasmtime::{Result, StoreContextMut};
   
   // Layer 3: Internal module imports
   use crate::{
       ComponentId, MessagePayload, CorrelationId, RequestId,
       MessagingError, StorageError, ComponentError,
       LogLevel, Timestamp, StorageValue, StorageUsage, ComponentInfo,
   };
   ```

3. Implement main registration function:
   ```rust
   /// Register all host functions with the linker
   ///
   /// This function registers the complete set of 18 host functions defined
   /// in the WIT interfaces:
   /// - 5 from host-messaging.wit
   /// - 6 from host-services.wit
   /// - 6 from storage.wit
   ///
   /// # Arguments
   /// * `linker` - Wasmtime component Linker
   ///
   /// # Returns
   /// * `Ok(())` on success
   /// * `Err(wasmtime::Error)` if registration fails
   ///
   /// # Reference
   /// - WIT Definitions: `wit/core/host-messaging.wit`, `host-services.wit`, `storage.wit`
   /// - Generated Traits: `lib.rs` lines 151-154 (wit_bindgen::generate!)
   /// - Architecture: KNOWLEDGE-WASM-042 (three-stage architecture)
   pub fn register_host_functions<T>(
       linker: &mut Linker<T>,
   ) -> Result<()> {
       register_messaging_functions(linker)?;
       register_services_functions(linker)?;
       register_storage_functions(linker)?;
       Ok(())
   }
   ```

**Deliverables:**
- `runtime/host_fn.rs` created with main registration function
- Module documentation explaining the 18 host functions
- Reference to KNOWLEDGE-WASM-042 and wit_bindgen connection

**ADR Constraints:**
- **ADR-WASM-025:** runtime/ is Layer 2B, cannot import component/, messaging/, system/
- **ADR-WASM-030:** Defines runtime/ structure and host_fn.rs specification
- **ADR-WASM-027:** Defines the 18 host functions in WIT

**PROJECTS_STANDARD.md Compliance:**
- **§2.1:** Follow 3-layer import organization
- **§2.2:** No FQN in type annotations - types imported, used by simple name
- **§4.3:** Will update mod.rs to only contain module declarations

**Rust Guidelines:**
- **M-MODULE-DOCS:** Module docs explain host function registration
- **M-DESIGN-FOR-AI:** Clear API with thorough documentation

**Documentation:**
- **Diátaxis type:** Reference documentation for host function registration API
- **Quality:** Technical language, no marketing terms
- **Standards Compliance:** Follows documentation-quality-standards.md

**Verification:**
```bash
# Verify file created
ls -la airssys-wasm/src/runtime/host_fn.rs

# Verify no forbidden imports
grep -rn "use crate::component" airssys-wasm/src/runtime/host_fn.rs
grep -rn "use crate::messaging" airssys-wasm/src/runtime/host_fn.rs
grep -rn "use crate::system" airssys-wasm/src/runtime/host_fn.rs
# Expected: No output
```

---

### Action 2: Register host-messaging Interface (5 Functions)

**Objective:** Register all 5 messaging functions with stub implementations.

**Steps:**

1. Implement `register_messaging_functions`:
   ```rust
   /// Register host-messaging interface functions
   ///
   /// Registers 5 functions from `wit/core/host-messaging.wit`:
   /// 1. send - Fire-and-forget message
   /// 2. request - Async RPC with correlation ID
   /// 3. cancel-request - Cancel pending request
   /// 4. broadcast - Send to multiple targets
   /// 5. self-id - Get current component's ID
   ///
   /// # Phase 5 Note (YAGNI)
   /// These are STUB implementations for registration only.
   /// Full implementations will be added in Phase 6 when messaging/ module is complete.
   ///
   /// # Reference
   /// - WIT: `wit/core/host-messaging.wit`
   /// - Generated Trait: `exports::host_messaging::Host` (from wit_bindgen)
   /// - KNOWLEDGE-WASM-042: Lines 159-176 (host-messaging function list)
   fn register_messaging_functions<T>(
       linker: &mut Linker<T>,
   ) -> Result<()> {
       let mut instance = linker.root().instance("host-messaging")?;
       
       // Function 1: send
       instance.func_wrap(
           "send",
           |_store: StoreContextMut<T>, 
            (_target, _payload): (ComponentId, MessagePayload)| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will route via messaging/ module
               Ok(())
           },
       )?;
       
       // Function 2: request
       instance.func_wrap(
           "request",
           |_store: StoreContextMut<T>,
            (_target, _payload, _timeout_ms): (ComponentId, MessagePayload, u64)| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will create real correlation ID
               Ok(CorrelationId {
                   value: "stub-correlation-id".to_string(),
               })
           },
       )?;
       
       // Function 3: cancel-request
       instance.func_wrap(
           "cancel-request",
           |_store: StoreContextMut<T>, (_request_id,): (RequestId,)| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will cancel via messaging/ module
               Ok(())
           },
       )?;
       
       // Function 4: broadcast
       instance.func_wrap(
           "broadcast",
           |_store: StoreContextMut<T>,
            (_targets, _payload): (Vec<ComponentId>, MessagePayload)| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will broadcast via messaging/ module
               Ok(())
           },
       )?;
       
       // Function 5: self-id
       instance.func_wrap(
           "self-id",
           |_store: StoreContextMut<T>, (): ()| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will get real component ID from store
               Ok(ComponentId {
                   namespace: "stub".to_string(),
                   name: "stub-component".to_string(),
                   instance: "v1".to_string(),
               })
           },
       )?;
       
       Ok(())
   }
   ```

**Deliverables:**
- `register_messaging_functions` with all 5 host-messaging functions registered
- Each function has clear documentation referencing WIT definition
- Stub implementations with Phase 6 implementation notes

**ADR Constraints:**
- **ADR-WASM-027:** Function names and signatures MUST match host-messaging.wit exactly
- **KNOWLEDGE-WASM-042:** Instance name MUST be "host-messaging" (matching WIT interface name)

**PROJECTS_STANDARD.md Compliance:**
- **§6.1:** YAGNI - stub implementations only, defer full logic to Phase 6

**Verification:**
```bash
# Count registered functions (should be 5)
grep -c 'func_wrap' airssys-wasm/src/runtime/host_fn.rs | grep -q 5

# Verify instance name matches WIT
grep 'instance("host-messaging")' airssys-wasm/src/runtime/host_fn.rs
```

---

### Action 3: Register host-services Interface (6 Functions)

**Objective:** Register all 6 service functions with stub implementations.

**Steps:**

1. Implement `register_services_functions`:
   ```rust
   /// Register host-services interface functions
   ///
   /// Registers 6 functions from `wit/core/host-services.wit`:
   /// 1. log - Write log message
   /// 2. current-time - Get high-precision timestamp
   /// 3. current-time-millis - Get Unix milliseconds
   /// 4. sleep-millis - Async sleep
   /// 5. list-components - List all active components
   /// 6. get-component-metadata - Get component info
   ///
   /// # Phase 5 Note (YAGNI)
   /// These are STUB implementations for registration only.
   /// Full implementations will be added in Phase 6.
   ///
   /// # Reference
   /// - WIT: `wit/core/host-services.wit`
   /// - Generated Trait: `exports::host_services::Host` (from wit_bindgen)
   /// - KNOWLEDGE-WASM-042: Lines 178-195 (host-services function list)
   fn register_services_functions<T>(
       linker: &mut Linker<T>,
   ) -> Result<()> {
       let mut instance = linker.root().instance("host-services")?;
       
       // Function 1: log
       instance.func_wrap(
           "log",
           |_store: StoreContextMut<T>,
            (_level, _message, _context): (LogLevel, String, Option<Vec<(String, String)>>)| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will integrate with airssys-osl logging
           },
       )?;
       
       // Function 2: current-time
       instance.func_wrap(
           "current-time",
           |_store: StoreContextMut<T>, (): ()| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will return real timestamp (§3.2 - DateTime<Utc>)
               Ok(Timestamp {
                   seconds: 0,
                   nanoseconds: 0,
               })
           },
       )?;
       
       // Function 3: current-time-millis
       instance.func_wrap(
           "current-time-millis",
           |_store: StoreContextMut<T>, (): ()| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will return real Unix milliseconds
               Ok(0u64)
           },
       )?;
       
       // Function 4: sleep-millis
       instance.func_wrap(
           "sleep-millis",
           |_store: StoreContextMut<T>, (_duration_ms,): (u64,)| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will implement async sleep
           },
       )?;
       
       // Function 5: list-components
       instance.func_wrap(
           "list-components",
           |_store: StoreContextMut<T>, (): ()| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will query component/ registry
               Ok(Vec::<ComponentId>::new())
           },
       )?;
       
       // Function 6: get-component-metadata
       instance.func_wrap(
           "get-component-metadata",
           |_store: StoreContextMut<T>, (_id,): (ComponentId,)| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will query component/ registry
               Err(ComponentError::NotFound)
           },
       )?;
       
       Ok(())
   }
   ```

**Deliverables:**
- `register_services_functions` with all 6 host-services functions registered
- Each function documented with WIT reference
- Stub implementations with Phase 6 notes

**ADR Constraints:**
- **ADR-WASM-027:** Function signatures MUST match host-services.wit
- **KNOWLEDGE-WASM-042:** Instance name MUST be "host-services"

**PROJECTS_STANDARD.md Compliance:**
- **§3.2:** current-time implementation will use chrono::DateTime<Utc> in Phase 6

**Verification:**
```bash
# Verify instance name
grep 'instance("host-services")' airssys-wasm/src/runtime/host_fn.rs

# Verify all 6 functions present
grep -A2 '"log"' airssys-wasm/src/runtime/host_fn.rs
grep -A2 '"current-time"' airssys-wasm/src/runtime/host_fn.rs
grep -A2 '"current-time-millis"' airssys-wasm/src/runtime/host_fn.rs
grep -A2 '"sleep-millis"' airssys-wasm/src/runtime/host_fn.rs
grep -A2 '"list-components"' airssys-wasm/src/runtime/host_fn.rs
grep -A2 '"get-component-metadata"' airssys-wasm/src/runtime/host_fn.rs
```

---

### Action 4: Register storage Interface (6 Functions)

**Objective:** Register all 6 storage functions with stub implementations.

**Steps:**

1. Implement `register_storage_functions`:
   ```rust
   /// Register storage interface functions
   ///
   /// Registers 6 functions from `wit/core/storage.wit`:
   /// 1. get - Get value from storage
   /// 2. set - Set value in storage
   /// 3. delete - Delete key from storage
   /// 4. exists - Check if key exists
   /// 5. list-keys - List keys with optional prefix
   /// 6. usage - Get storage usage stats
   ///
   /// # Phase 5 Note (YAGNI)
   /// These are STUB implementations for registration only.
   /// Full implementations will be added in Phase 6.
   ///
   /// # Reference
   /// - WIT: `wit/core/storage.wit`
   /// - Generated Trait: `exports::storage::Host` (from wit_bindgen)
   /// - KNOWLEDGE-WASM-042: Lines 197-213 (storage function list)
   fn register_storage_functions<T>(
       linker: &mut Linker<T>,
   ) -> Result<()> {
       let mut instance = linker.root().instance("storage")?;
       
       // Function 1: get
       instance.func_wrap(
           "get",
           |_store: StoreContextMut<T>, (_key,): (String,)| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will query component-isolated storage
               Ok(None as Option<StorageValue>)
           },
       )?;
       
       // Function 2: set
       instance.func_wrap(
           "set",
           |_store: StoreContextMut<T>, (_key, _value): (String, StorageValue)| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will persist to component-isolated storage
               Ok(())
           },
       )?;
       
       // Function 3: delete
       instance.func_wrap(
           "delete",
           |_store: StoreContextMut<T>, (_key,): (String,)| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will delete from storage
               Ok(())
           },
       )?;
       
       // Function 4: exists
       instance.func_wrap(
           "exists",
           |_store: StoreContextMut<T>, (_key,): (String,)| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will check storage
               Ok(false)
           },
       )?;
       
       // Function 5: list-keys
       instance.func_wrap(
           "list-keys",
           |_store: StoreContextMut<T>, (_prefix,): (Option<String>,)| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will query storage keys
               Ok(Vec::<String>::new())
           },
       )?;
       
       // Function 6: usage
       instance.func_wrap(
           "usage",
           |_store: StoreContextMut<T>, (): ()| {
               // STUB: Phase 5 - registration only
               // Phase 6: Will compute storage usage
               Ok(StorageUsage {
                   used_bytes: 0,
                   total_bytes: 0,
                   item_count: 0,
               })
           },
       )?;
       
       Ok(())
   }
   ```

**Deliverables:**
- `register_storage_functions` with all 6 storage functions registered
- Each function documented with WIT reference
- Stub implementations with Phase 6 notes

**ADR Constraints:**
- **ADR-WASM-027:** Function signatures MUST match storage.wit
- **KNOWLEDGE-WASM-042:** Instance name MUST be "storage"

**Verification:**
```bash
# Verify instance name
grep 'instance("storage")' airssys-wasm/src/runtime/host_fn.rs

# Verify all 6 functions present
grep -A2 '"get"' airssys-wasm/src/runtime/host_fn.rs
grep -A2 '"set"' airssys-wasm/src/runtime/host_fn.rs
grep -A2 '"delete"' airssys-wasm/src/runtime/host_fn.rs
grep -A2 '"exists"' airssys-wasm/src/runtime/host_fn.rs
grep -A2 '"list-keys"' airssys-wasm/src/runtime/host_fn.rs
grep -A2 '"usage"' airssys-wasm/src/runtime/host_fn.rs
```

---

### Action 5: Update runtime/mod.rs

**Objective:** Declare host_fn module in runtime/mod.rs (per §4.3).

**Steps:**

1. Add module declaration to `airssys-wasm/src/runtime/mod.rs`:
   ```rust
   // Host function bindings
   pub mod host_fn;
   ```

**Deliverables:**
- runtime/mod.rs updated with host_fn module declaration
- NO type re-exports (per §4.3)

**PROJECTS_STANDARD.md Compliance:**
- **§4.3:** mod.rs contains ONLY module declarations

**Verification:**
```bash
# Verify module declaration exists
grep 'pub mod host_fn' airssys-wasm/src/runtime/mod.rs

# Verify NO type re-exports
grep 'pub use' airssys-wasm/src/runtime/mod.rs
# Expected: Empty (no type re-exports)
```

---

## Unit Testing Plan

### Test Strategy

Test that all 18 host functions are correctly registered with the Linker. Since these are stub implementations, tests verify REGISTRATION, not functionality.

**Test File:** `airssys-wasm/src/runtime/host_fn.rs` (inline #[cfg(test)] module)

### Test Cases

**Test 1: All 18 Host Functions Register Successfully**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use wasmtime::component::Linker;
    use wasmtime::{Config, Engine};

    /// Stub host state for testing
    struct TestHostState;

    #[test]
    fn test_register_host_functions_succeeds() {
        // Setup wasmtime engine with component model
        let mut config = Config::new();
        config.wasm_component_model(true);
        let engine = Engine::new(&config).expect("Failed to create engine");

        // Create linker
        let mut linker: Linker<TestHostState> = Linker::new(&engine);

        // Register all host functions
        let result = register_host_functions(&mut linker);

        // Assert registration succeeded
        assert!(result.is_ok(), "Host function registration should succeed");
    }

    #[test]
    fn test_register_messaging_functions_succeeds() {
        let mut config = Config::new();
        config.wasm_component_model(true);
        let engine = Engine::new(&config).expect("Failed to create engine");
        let mut linker: Linker<TestHostState> = Linker::new(&engine);

        // Register only messaging functions
        let result = register_messaging_functions(&mut linker);

        assert!(result.is_ok(), "Messaging functions should register");
    }

    #[test]
    fn test_register_services_functions_succeeds() {
        let mut config = Config::new();
        config.wasm_component_model(true);
        let engine = Engine::new(&config).expect("Failed to create engine");
        let mut linker: Linker<TestHostState> = Linker::new(&engine);

        let result = register_services_functions(&mut linker);

        assert!(result.is_ok(), "Services functions should register");
    }

    #[test]
    fn test_register_storage_functions_succeeds() {
        let mut config = Config::new();
        config.wasm_component_model(true);
        let engine = Engine::new(&config).expect("Failed to create engine");
        let mut linker: Linker<TestHostState> = Linker::new(&engine);

        let result = register_storage_functions(&mut linker);

        assert!(result.is_ok(), "Storage functions should register");
    }
}
```

**Test Coverage:**
- ✅ All 18 functions register without errors
- ✅ Each interface (messaging, services, storage) registers independently
- ✅ Linker accepts function signatures (type-safe registration)

**What is NOT tested (deferred to Phase 6):**
- ❌ Function behavior (stubs return dummy values)
- ❌ Integration with component/, messaging/, system/ modules
- ❌ Real WASM component calling host functions

**Rationale (YAGNI - §6.1):**
Phase 5 validates REGISTRATION only. Full integration tests will be added in Phase 6 when messaging/ and component/ modules are implemented.

**Verification:**
```bash
# Run unit tests
cargo test -p airssys-wasm --lib runtime::host_fn::tests

# Verify all tests pass
cargo test -p airssys-wasm --lib runtime::host_fn::tests -- --test-threads=1
```

---

## Integration Testing Plan

### Integration Test Strategy

**Phase 5 Approach:** YAGNI - No integration tests yet.

**Rationale:**
Real integration tests require:
1. Complete WASM component fixtures (Phase 6)
2. messaging/ module implementation (Phase 6)
3. component/ module implementation (Phase 6)
4. system/ module coordination (Phase 7)

Creating "fake" integration tests that don't test real component interaction would violate:
- **AGENTS.md §9:** "Tests must prove REAL functionality (not just APIs)"
- **YAGNI Principle (§6.1):** Don't build what isn't needed yet

**Phase 6 Integration Tests Will:**
1. Load actual WASM component (.wasm file)
2. Instantiate component with registered host functions
3. Call component export that invokes host function
4. Verify host function was called with correct parameters
5. Verify component receives correct response

**Example (Phase 6 - NOT NOW):**
```rust
// Phase 6 integration test (deferred)
#[test]
fn test_component_calls_host_send() {
    // Load test component that calls host-messaging::send
    let component_bytes = include_bytes!("../tests/fixtures/messaging-test.wasm");
    
    // Register host functions
    let mut linker = create_linker_with_host_functions();
    
    // Instantiate component
    let instance = linker.instantiate(component_bytes)?;
    
    // Call component function that invokes send
    instance.call_send_message()?;
    
    // Verify host function was invoked
    assert!(host_function_called);
}
```

**Current State:**
No integration tests for Phase 5. Unit tests verify registration only.

---

## Architecture Verification Commands

Run after implementation to verify module boundaries:

```bash
# 1. Verify NO forbidden imports in runtime/
echo "=== Checking runtime/ for forbidden imports ==="
grep -rn "use crate::component" airssys-wasm/src/runtime/
grep -rn "use crate::messaging" airssys-wasm/src/runtime/
grep -rn "use crate::system" airssys-wasm/src/runtime/
# Expected: ALL return empty (no forbidden imports)

# 2. Build check
echo "=== Building airssys-wasm ==="
cargo build -p airssys-wasm

# 3. Clippy check (zero warnings)
echo "=== Running clippy ==="
cargo clippy -p airssys-wasm --all-targets -- -D warnings

# 4. Unit tests
echo "=== Running unit tests ==="
cargo test -p airssys-wasm --lib runtime::host_fn::tests

# 5. Verify all 18 functions registered
echo "=== Counting registered functions ==="
grep -c 'func_wrap' airssys-wasm/src/runtime/host_fn.rs
# Expected: 18 (5 messaging + 6 services + 6 storage)

# 6. Verify instance names match WIT
echo "=== Verifying instance names ==="
grep 'instance("host-messaging")' airssys-wasm/src/runtime/host_fn.rs
grep 'instance("host-services")' airssys-wasm/src/runtime/host_fn.rs
grep 'instance("storage")' airssys-wasm/src/runtime/host_fn.rs
# Expected: Each found once
```

---

## Success Criteria

- [x] All 18 host functions registered with correct signatures
- [x] Function names match WIT definitions exactly
- [x] Instance names match WIT interface names
- [x] Stub implementations with Phase 6 notes
- [x] Unit tests verify registration succeeds
- [x] Module boundaries verified (no forbidden imports)
- [x] Zero compiler/clippy warnings
- [x] runtime/mod.rs updated with host_fn module declaration
- [x] Documentation references KNOWLEDGE-WASM-042
- [x] All verification commands pass

---

## References

### Critical Knowledge Documents
- **KNOWLEDGE-WASM-042:** wit_bindgen Macro and Host Function Registration Architecture
  - Three-stage architecture (WIT → generated traits → Linker)
  - Complete list of 18 host functions with signatures
  - Registration patterns and examples

### ADRs
- **ADR-WASM-025:** Clean-Slate Rebuild Architecture
- **ADR-WASM-030:** Runtime Module Design
- **ADR-WASM-027:** WIT Interface Design

### Standards
- **PROJECTS_STANDARD.md:** §2.1, §2.2, §4.3, §6.1, §6.2, §6.4
- **AGENTS.md:** §9 Testing Requirements (YAGNI approach for Phase 5)

### External Documentation
- [Wasmtime Component Model](https://docs.wasmtime.dev/api/wasmtime/component/)
- [Wasmtime Linker API](https://docs.wasmtime.dev/api/wasmtime/component/struct.Linker.html)
- [wit-bindgen Documentation](https://docs.rs/wit-bindgen/latest/wit_bindgen/)

---

**This plan establishes host function registration infrastructure for Phase 5, with full implementations deferred to Phase 6 per YAGNI principles.**
