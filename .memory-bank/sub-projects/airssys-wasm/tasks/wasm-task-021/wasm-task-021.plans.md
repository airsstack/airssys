# WASM-TASK-021: Implementation Plans

## Plan References
- **KNOWLEDGE-WASM-041:** Storage Management Architecture (primary specification for storage design)
- **ADR-WASM-028:** Core Module Structure (Layer 1 compliance, lines 74-77, 507-533)
- **ADR-WASM-025:** Clean-Slate Rebuild Architecture
- **ADR-WASM-026:** Implementation Roadmap (Phase 3)
- **KNOWLEDGE-WASM-037:** Rebuild Architecture Clean-Slate
- **PROJECTS_STANDARD.md:** §2.1, §4.3, §6.2
- **WIT Interface:** `wit/core/storage.wit`, `wit/core/types.wit`

## Target Structure Reference

Per ADR-WASM-028 (lines 74-77), **extended with dedicated `StorageValue` ADT**:
```
core/storage/
├── mod.rs           # Module declarations (per §4.3)
├── value.rs         # StorageValue ADT (dedicated domain type) [NEW]
├── errors.rs        # StorageError enum (co-located)
└── traits.rs        # ComponentStorage trait
```

## Architecture Context

### Design Decision: Dedicated `StorageValue` ADT
**Rationale:** Domain boundary clarity over DRY principle.

| Concern | Decision |
|---------|----------|
| Why not `MessagePayload`? | Storage values are not messages - different domain |
| Why not shared `BytePayload`? | Engineer should know type's purpose from name |
| WIT alignment? | Update `storage.wit` with dedicated `storage-value` type |

### wit_bindgen::generate! Macro Considerations

> **⚠️ CRITICAL**: The `wit_bindgen::generate!` macro in `lib.rs` (line 151) generates Rust bindings from WIT files.

**Impact of WIT changes:**
When we update `storage.wit` to use `storage-value` instead of `message-payload`:

1. **New generated type**: `wit_bindgen` will generate a type alias for storage operations:
   ```rust
   // Generated by wit_bindgen (approximate)
   type StorageValue = Vec<u8>;  // from WIT: type storage-value = list<u8>
   ```

2. **Interface change**: Storage functions will use the new type:
   ```rust
   // Generated interface (approximate)
   fn get(key: &str) -> Result<Option<Vec<u8>>, StorageError>;
   fn set(key: &str, value: Vec<u8>) -> Result<(), StorageError>;
   ```

**Two Type Systems - How They Relate:**

| Layer | Type | Purpose | Location |
|-------|------|---------|----------|
| WIT Bindings | `storage-value` (→ `Vec<u8>`) | FFI/Host-Guest boundary | Generated by `wit_bindgen::generate!` |
| Core API | `StorageValue` | Internal domain abstraction | `core/storage/value.rs` |

**Future Integration (Phase 3+):**
- The `core::storage::StorageValue` can implement `From<Vec<u8>>` and `Into<Vec<u8>>`
- This enables seamless conversion between WIT-generated and core types
- Already included in Action 1 implementation

**Verification:**
After WIT update, run `cargo build` to regenerate bindings and verify no compilation errors.

### Layer 1 Rules (core/ module)
- `core/` is **Layer 1** - zero internal dependencies from other modules
- Allowed: `std`, `thiserror`, `serde`
- `core/storage/` is self-contained with its own value type

### Storage Namespace Isolation (Solana-Inspired)

> **Design Decision (2026-01-10):** Host-enforced implicit namespace isolation

**Model:** Each WASM component has its own isolated storage namespace. Component "A" cannot access Component "B"'s storage. This is inspired by Solana's account model.

**Implementation:**
```
┌─────────────────────────────────────────────────────────────┐
│ Component A calls: storage.get("user:123")                  │
│         ↓                                                   │
│ Host internally: storage.get("component-A/user:123")        │
│         ↓                                                   │
│ ✅ Returns Component A's data                               │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ Component B calls: storage.get("user:123")                  │
│         ↓                                                   │
│ Host internally: storage.get("component-B/user:123")        │
│         ↓                                                   │
│ ✅ Returns Component B's data (different namespace)         │
└─────────────────────────────────────────────────────────────┘
```

**Key Points:**
1. **Implicit namespacing** - Components don't specify namespace, host enforces
2. **Automatic scoping** - All keys are prefixed with `{component-id}/`
3. **No cross-access** - Components cannot access other namespaces
4. **Simple API** - Trait methods just take `key: &str`

**Future Extensions:**
- Cross-component access via explicit capabilities (e.g., `StorageCapability::ReadFrom(component-id)`)
- For now, strict isolation is the only mode

**Trait Documentation Requirement:**
The `ComponentStorage` trait MUST document that:
- Storage is automatically namespaced by the calling component's ID
- Components cannot access storage outside their namespace
- This isolation is enforced at the host/runtime level

---

## Implementation Actions

### Action 0: Update `storage.wit` (WIT Interface Sync)
**Objective:** Define dedicated `storage-value` type, remove dependency on `message-payload`

**Reference:** Current `wit/core/storage.wit`, domain boundary principle

**File Location:** `airssys-wasm/wit/core/storage.wit`

**Before:**
```wit
interface storage {
    use types.{message-payload};
    use errors.{storage-error};

    get: func(key: string) -> result<option<message-payload>, storage-error>;
    set: func(key: string, value: message-payload) -> result<_, storage-error>;
    ...
}
```

**After:**
```wit
package airssys:core@1.0.0;

/// Host-implemented storage interface (component-isolated)
interface storage {
    use errors.{storage-error};

    /// Storage value (raw bytes) - dedicated type for storage operations
    type storage-value = list<u8>;

    /// Get value by key (within component's namespace)
    get: func(key: string) -> result<option<storage-value>, storage-error>;

    /// Set value by key
    set: func(key: string, value: storage-value) -> result<_, storage-error>;

    /// Delete value by key
    delete: func(key: string) -> result<_, storage-error>;

    /// Check if key exists
    exists: func(key: string) -> result<bool, storage-error>;

    /// List keys with optional prefix filter
    list-keys: func(prefix: option<string>) -> result<list<string>, storage-error>;

    /// Get storage usage info
    usage: func() -> result<storage-usage, storage-error>;

    /// Storage usage information
    record storage-usage {
        used-bytes: u64,
        quota-bytes: u64,
        key-count: u64,
    }
}
```

**Verification (CRITICAL - Run before proceeding):**
```bash
# 1. Validate WIT syntax with wasm-tools
wasm-tools component wit wit/core/
# Expected: No errors, prints WIT output

# 2. Alternative: Validate with wit-bindgen (check generate works)
wit-bindgen rust wit/core/ --out-dir /tmp/wit-check 2>&1
# Expected: No errors (may generate files, we just check syntax)

# 3. Verify no message-payload dependency
grep -n "message-payload" wit/core/storage.wit
# Expected: Empty output

# 4. Verify storage-value is defined
grep -n "storage-value" wit/core/storage.wit
# Expected: type definition and usages
```

> **⚠️ CRITICAL**: If `wasm-tools component wit` fails, do NOT proceed with Rust implementation. Fix WIT syntax first.

---

### Action 1: Create `core/storage/value.rs`
**Objective:** Define dedicated `StorageValue` ADT for storage operations

**Reference:** Domain boundary principle, similar pattern to `MessagePayload`

**File Location:** `airssys-wasm/src/core/storage/value.rs`

**Implementation:**
```rust
//! Storage value type.
//!
//! This module contains the `StorageValue` ADT for component storage.
//! This type is exclusively for storage operations, providing domain
//! boundary clarity separate from messaging types.

// Layer 1: Standard library imports (per PROJECTS_STANDARD.md §2.1)
// (none needed for this module)

// Layer 2: Third-party crate imports (per PROJECTS_STANDARD.md §2.1)
// (none needed for this module)

// Layer 3: Internal module imports (per PROJECTS_STANDARD.md §2.1)
// (none - value type has no internal dependencies)

/// Storage value wrapper for raw bytes.
///
/// `StorageValue` wraps raw bytes for component storage operations.
/// This type is semantically distinct from `MessagePayload` - it is
/// used exclusively for storage get/set operations.
///
/// # Architecture Note
///
/// Per domain boundary principle, storage values have their own type
/// even though the underlying representation is similar to other
/// byte wrappers. This ensures engineers know the type's purpose.
///
/// # Examples
///
/// ```rust
/// use airssys_wasm::core::storage::value::StorageValue;
///
/// // Create from Vec<u8>
/// let value = StorageValue::new(vec![1, 2, 3, 4]);
/// assert_eq!(value.len(), 4);
/// assert!(!value.is_empty());
///
/// // Access bytes
/// assert_eq!(value.as_bytes(), &[1, 2, 3, 4]);
///
/// // Convert back to Vec<u8>
/// let bytes = value.into_bytes();
/// assert_eq!(bytes, vec![1, 2, 3, 4]);
/// ```
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct StorageValue(Vec<u8>);

impl StorageValue {
    /// Creates a new `StorageValue` from raw bytes.
    ///
    /// # Arguments
    ///
    /// * `data` - The raw bytes to wrap
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::storage::value::StorageValue;
    ///
    /// let value = StorageValue::new(vec![1, 2, 3]);
    /// assert_eq!(value.len(), 3);
    /// ```
    pub fn new(data: Vec<u8>) -> Self {
        Self(data)
    }

    /// Returns the value as a byte slice.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::storage::value::StorageValue;
    ///
    /// let value = StorageValue::new(vec![1, 2, 3]);
    /// assert_eq!(value.as_bytes(), &[1, 2, 3]);
    /// ```
    pub fn as_bytes(&self) -> &[u8] {
        &self.0
    }

    /// Consumes the value and returns the underlying bytes.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::storage::value::StorageValue;
    ///
    /// let value = StorageValue::new(vec![1, 2, 3]);
    /// let bytes = value.into_bytes();
    /// assert_eq!(bytes, vec![1, 2, 3]);
    /// ```
    pub fn into_bytes(self) -> Vec<u8> {
        self.0
    }

    /// Returns the length of the value in bytes.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::storage::value::StorageValue;
    ///
    /// let value = StorageValue::new(vec![1, 2, 3, 4, 5]);
    /// assert_eq!(value.len(), 5);
    /// ```
    pub fn len(&self) -> usize {
        self.0.len()
    }

    /// Returns `true` if the value is empty.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::storage::value::StorageValue;
    ///
    /// let empty = StorageValue::new(vec![]);
    /// assert!(empty.is_empty());
    ///
    /// let non_empty = StorageValue::new(vec![1]);
    /// assert!(!non_empty.is_empty());
    /// ```
    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }
}

impl From<Vec<u8>> for StorageValue {
    fn from(data: Vec<u8>) -> Self {
        Self::new(data)
    }
}

impl From<&[u8]> for StorageValue {
    fn from(data: &[u8]) -> Self {
        Self::new(data.to_vec())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_storage_value_new() {
        let value = StorageValue::new(vec![1, 2, 3, 4, 5]);
        assert_eq!(value.len(), 5);
        assert!(!value.is_empty());
    }

    #[test]
    fn test_storage_value_as_bytes() {
        let value = StorageValue::new(vec![10, 20, 30]);
        assert_eq!(value.as_bytes(), &[10, 20, 30]);
    }

    #[test]
    fn test_storage_value_into_bytes() {
        let value = StorageValue::new(vec![1, 2, 3]);
        let bytes = value.into_bytes();
        assert_eq!(bytes, vec![1, 2, 3]);
    }

    #[test]
    fn test_storage_value_from_vec() {
        let value: StorageValue = vec![1, 2, 3].into();
        assert_eq!(value.len(), 3);
    }

    #[test]
    fn test_storage_value_from_slice() {
        let data: &[u8] = &[1, 2, 3, 4];
        let value: StorageValue = data.into();
        assert_eq!(value.len(), 4);
    }

    #[test]
    fn test_storage_value_empty() {
        let value = StorageValue::new(vec![]);
        assert!(value.is_empty());
        assert_eq!(value.len(), 0);
    }

    #[test]
    fn test_storage_value_equality() {
        let v1 = StorageValue::new(vec![1, 2, 3]);
        let v2 = StorageValue::new(vec![1, 2, 3]);
        let v3 = StorageValue::new(vec![3, 2, 1]);

        assert_eq!(v1, v2);
        assert_ne!(v1, v3);
    }

    #[test]
    fn test_storage_value_clone() {
        let v1 = StorageValue::new(vec![1, 2, 3]);
        let v2 = v1.clone();
        assert_eq!(v1, v2);
    }

    #[test]
    fn test_storage_value_debug() {
        let value = StorageValue::new(vec![1, 2, 3]);
        let debug_str = format!("{:?}", value);
        assert!(debug_str.contains("StorageValue"));
    }
}
```

**Verification:**
```bash
# Verify no internal dependencies
grep -n "use crate::" src/core/storage/value.rs
# Expected: Empty output
```

---

### Action 2: Create `core/storage/errors.rs`
**Objective:** Define co-located `StorageError` enum for storage operations

**Reference:** ADR-WASM-028 lines 74-77, WIT `errors.wit` (lines 45-51), existing `core/messaging/errors.rs` pattern

**File Location:** `airssys-wasm/src/core/storage/errors.rs`

**WIT Alignment (`errors.wit` lines 45-51):**
```wit
variant storage-error {
    not-found(string),
    already-exists(string),
    quota-exceeded,
    invalid-key(string),
    io-error(string),
}
```

**Implementation:**
```rust
//! Storage error types.
//!
//! This module contains error types for component storage operations.
//! These errors are co-located with the storage module per ADR-WASM-028.

// Layer 1: Standard library imports (per PROJECTS_STANDARD.md §2.1)
// (none needed for this module)

// Layer 2: Third-party crate imports (per PROJECTS_STANDARD.md §2.1)
use thiserror::Error;

// Layer 3: Internal module imports (per PROJECTS_STANDARD.md §2.1)
// (none - errors have no internal dependencies)

/// Storage errors for component storage operations.
///
/// `StorageError` represents errors from key-value storage operations.
/// Aligned with WIT `storage-error` variant in `errors.wit`.
///
/// # Variants
///
/// - `NotFound` - Key does not exist in storage
/// - `AlreadyExists` - Key already exists (for create-only operations)
/// - `QuotaExceeded` - Storage quota for component exceeded
/// - `InvalidKey` - Key format is invalid
/// - `IoError` - Underlying I/O operation failed
///
/// # Examples
///
/// ```rust
/// use airssys_wasm::core::storage::errors::StorageError;
///
/// let err = StorageError::NotFound("user:123".to_string());
/// assert!(format!("{}", err).contains("not found"));
/// ```
#[derive(Debug, Clone, Error, PartialEq, Eq)]
pub enum StorageError {
    /// Key not found in storage.
    #[error("Key not found: {0}")]
    NotFound(String),

    /// Key already exists (for create-only operations).
    #[error("Key already exists: {0}")]
    AlreadyExists(String),

    /// Component storage quota exceeded.
    #[error("Storage quota exceeded")]
    QuotaExceeded,

    /// Invalid key format.
    #[error("Invalid key: {0}")]
    InvalidKey(String),

    /// Underlying I/O error.
    #[error("Storage I/O error: {0}")]
    IoError(String),
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_not_found_display() {
        let err = StorageError::NotFound("user:123".to_string());
        assert_eq!(format!("{}", err), "Key not found: user:123");
    }

    #[test]
    fn test_already_exists_display() {
        let err = StorageError::AlreadyExists("config:main".to_string());
        assert_eq!(format!("{}", err), "Key already exists: config:main");
    }

    #[test]
    fn test_quota_exceeded_display() {
        let err = StorageError::QuotaExceeded;
        assert_eq!(format!("{}", err), "Storage quota exceeded");
    }

    #[test]
    fn test_invalid_key_display() {
        let err = StorageError::InvalidKey("bad\\key".to_string());
        assert_eq!(format!("{}", err), "Invalid key: bad\\key");
    }

    #[test]
    fn test_io_error_display() {
        let err = StorageError::IoError("disk full".to_string());
        assert_eq!(format!("{}", err), "Storage I/O error: disk full");
    }

    #[test]
    fn test_error_is_clone() {
        let err = StorageError::QuotaExceeded;
        let cloned = err.clone();
        assert!(matches!(cloned, StorageError::QuotaExceeded));
    }

    #[test]
    fn test_error_is_debug() {
        let err = StorageError::NotFound("test".to_string());
        let debug_str = format!("{:?}", err);
        assert!(debug_str.contains("NotFound"));
    }

    #[test]
    fn test_error_equality() {
        let err1 = StorageError::QuotaExceeded;
        let err2 = StorageError::QuotaExceeded;
        let err3 = StorageError::NotFound("x".to_string());

        assert_eq!(err1, err2);
        assert_ne!(err1, err3);
    }
}
```

**Verification:**
```bash
# Verify thiserror import
grep -n "use thiserror::Error" src/core/storage/errors.rs
# Expected: Line with import

# Verify no internal crate imports
grep -n "use crate::" src/core/storage/errors.rs
# Expected: Empty output
```

---

### Action 3: Create `core/storage/traits.rs`
**Objective:** Define `ComponentStorage` trait using `StorageValue`

**Reference:** ADR-WASM-028 lines 507-530, WIT `storage.wit`

**File Location:** `airssys-wasm/src/core/storage/traits.rs`

**Implementation:**
```rust
//! Storage trait abstractions.
//!
//! This module contains trait definitions for component-isolated storage.
//! These traits are implemented by the storage system and consumed by
//! components via host functions.

// Layer 1: Standard library imports (per PROJECTS_STANDARD.md §2.1)
// (none)

// Layer 2: Third-party crate imports (per PROJECTS_STANDARD.md §2.1)
// (none)

// Layer 3: Internal module imports (per PROJECTS_STANDARD.md §2.1)
use super::errors::StorageError;
use super::value::StorageValue;

/// Trait for component-isolated key-value storage.
///
/// `ComponentStorage` defines the interface for storage operations.
/// Each component has isolated storage namespaced by its `ComponentId`.
///
/// # Storage Isolation (Solana-Inspired)
///
/// Storage is automatically namespaced by the calling component's ID.
/// Components **cannot** access storage outside their namespace.
/// This isolation is enforced at the host/runtime level.
///
/// ```text
/// Component A calls: get("user:123")
///   → Host internally: get("component-A/user:123")
///   → Returns Component A's data only
///
/// Component B calls: get("user:123")
///   → Host internally: get("component-B/user:123")
///   → Returns Component B's data (different namespace)
/// ```
///
/// # Architecture Note
///
/// This trait is defined in `core/storage/` (Layer 1) as an abstraction.
/// Concrete implementations are provided via host functions or a storage
/// system module. This follows the Dependency Inversion Principle.
///
/// # Thread Safety
///
/// Implementations must be `Send + Sync` for multi-threaded access.
///
/// # Examples
///
/// ```rust
/// use airssys_wasm::core::storage::traits::ComponentStorage;
/// use airssys_wasm::core::storage::errors::StorageError;
/// use airssys_wasm::core::storage::value::StorageValue;
///
/// struct MockStorage;
///
/// impl ComponentStorage for MockStorage {
///     fn get(&self, _key: &str) -> Result<Option<StorageValue>, StorageError> {
///         Ok(None)
///     }
///
///     fn set(&self, _key: &str, _value: StorageValue) -> Result<(), StorageError> {
///         Ok(())
///     }
///
///     fn delete(&self, _key: &str) -> Result<(), StorageError> {
///         Ok(())
///     }
///
///     fn exists(&self, _key: &str) -> Result<bool, StorageError> {
///         Ok(false)
///     }
///
///     fn list_keys(&self, _prefix: Option<&str>) -> Result<Vec<String>, StorageError> {
///         Ok(vec![])
///     }
/// }
/// ```
pub trait ComponentStorage: Send + Sync {
    /// Gets a value by key.
    ///
    /// Returns `None` if the key does not exist in storage.
    ///
    /// # Arguments
    ///
    /// * `key` - The storage key to retrieve
    ///
    /// # Returns
    ///
    /// * `Ok(Some(value))` - Key exists, returns value
    /// * `Ok(None)` - Key does not exist
    /// * `Err(StorageError)` - Operation failed
    ///
    /// # Errors
    ///
    /// - `StorageError::InvalidKey` - Key format is invalid
    /// - `StorageError::IoError` - I/O operation failed
    fn get(&self, key: &str) -> Result<Option<StorageValue>, StorageError>;

    /// Sets a value by key.
    ///
    /// Creates the key if it doesn't exist, overwrites if it does.
    ///
    /// # Arguments
    ///
    /// * `key` - The storage key to set
    /// * `value` - The value to store
    ///
    /// # Errors
    ///
    /// - `StorageError::QuotaExceeded` - Storage quota exceeded
    /// - `StorageError::InvalidKey` - Key format is invalid
    /// - `StorageError::IoError` - I/O operation failed
    fn set(&self, key: &str, value: StorageValue) -> Result<(), StorageError>;

    /// Deletes a value by key.
    ///
    /// No-op if the key doesn't exist.
    ///
    /// # Arguments
    ///
    /// * `key` - The storage key to delete
    ///
    /// # Errors
    ///
    /// - `StorageError::InvalidKey` - Key format is invalid
    /// - `StorageError::IoError` - I/O operation failed
    fn delete(&self, key: &str) -> Result<(), StorageError>;

    /// Checks if a key exists in storage.
    ///
    /// # Arguments
    ///
    /// * `key` - The storage key to check
    ///
    /// # Returns
    ///
    /// * `Ok(true)` - Key exists
    /// * `Ok(false)` - Key does not exist
    ///
    /// # Errors
    ///
    /// - `StorageError::InvalidKey` - Key format is invalid
    /// - `StorageError::IoError` - I/O operation failed
    fn exists(&self, key: &str) -> Result<bool, StorageError>;

    /// Lists keys with an optional prefix filter.
    ///
    /// # Arguments
    ///
    /// * `prefix` - Optional prefix to filter keys. If `None`, returns all keys.
    ///
    /// # Returns
    ///
    /// A vector of matching key names.
    ///
    /// # Errors
    ///
    /// - `StorageError::IoError` - I/O operation failed
    fn list_keys(&self, prefix: Option<&str>) -> Result<Vec<String>, StorageError>;
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::HashMap;
    use std::sync::Mutex;

    struct MockStorage {
        data: Mutex<HashMap<String, StorageValue>>,
    }

    impl MockStorage {
        fn new() -> Self {
            Self {
                data: Mutex::new(HashMap::new()),
            }
        }
    }

    impl ComponentStorage for MockStorage {
        fn get(&self, key: &str) -> Result<Option<StorageValue>, StorageError> {
            Ok(self.data.lock().unwrap().get(key).cloned())
        }

        fn set(&self, key: &str, value: StorageValue) -> Result<(), StorageError> {
            self.data.lock().unwrap().insert(key.to_string(), value);
            Ok(())
        }

        fn delete(&self, key: &str) -> Result<(), StorageError> {
            self.data.lock().unwrap().remove(key);
            Ok(())
        }

        fn exists(&self, key: &str) -> Result<bool, StorageError> {
            Ok(self.data.lock().unwrap().contains_key(key))
        }

        fn list_keys(&self, prefix: Option<&str>) -> Result<Vec<String>, StorageError> {
            let data = self.data.lock().unwrap();
            let keys: Vec<String> = match prefix {
                Some(p) => data.keys().filter(|k| k.starts_with(p)).cloned().collect(),
                None => data.keys().cloned().collect(),
            };
            Ok(keys)
        }
    }

    #[test]
    fn test_component_storage_is_send_sync() {
        fn assert_send_sync<T: Send + Sync + ?Sized>() {}
        assert_send_sync::<dyn ComponentStorage>();
    }

    #[test]
    fn test_mock_storage_set_and_get() {
        let storage = MockStorage::new();
        let value = StorageValue::new(vec![1, 2, 3]);

        storage.set("key1", value.clone()).unwrap();
        let retrieved = storage.get("key1").unwrap();

        assert_eq!(retrieved, Some(value));
    }

    #[test]
    fn test_mock_storage_get_nonexistent() {
        let storage = MockStorage::new();
        let result = storage.get("nonexistent").unwrap();
        assert!(result.is_none());
    }

    #[test]
    fn test_mock_storage_delete() {
        let storage = MockStorage::new();
        storage.set("key1", StorageValue::new(vec![1])).unwrap();

        assert!(storage.exists("key1").unwrap());
        storage.delete("key1").unwrap();
        assert!(!storage.exists("key1").unwrap());
    }

    #[test]
    fn test_mock_storage_exists() {
        let storage = MockStorage::new();

        assert!(!storage.exists("key1").unwrap());
        storage.set("key1", StorageValue::new(vec![1])).unwrap();
        assert!(storage.exists("key1").unwrap());
    }

    #[test]
    fn test_mock_storage_list_keys() {
        let storage = MockStorage::new();
        storage.set("user:1", StorageValue::new(vec![1])).unwrap();
        storage.set("user:2", StorageValue::new(vec![2])).unwrap();
        storage.set("config:main", StorageValue::new(vec![3])).unwrap();

        let user_keys = storage.list_keys(Some("user:")).unwrap();
        assert_eq!(user_keys.len(), 2);

        let all_keys = storage.list_keys(None).unwrap();
        assert_eq!(all_keys.len(), 3);
    }
}
```

**Verification:**
```bash
# Verify StorageValue import from local module
grep -n "use super::value::StorageValue" src/core/storage/traits.rs
# Expected: Line with import

# Verify no external module imports
grep -n "use crate::component\|use crate::messaging" src/core/storage/traits.rs
# Expected: Empty output
```

---

### Action 4: Create `core/storage/mod.rs`
**Objective:** Module declarations with comprehensive documentation

**Reference:** PROJECTS_STANDARD.md §4.3, existing `core/messaging/mod.rs` pattern

**File Location:** `airssys-wasm/src/core/storage/mod.rs`

**Implementation:**
```rust
//! Storage abstractions for component-isolated key-value storage.
//!
//! This module provides types, traits, and errors for component storage.
//! Each component has access to isolated storage namespaced by its ID.
//!
//! # Architecture
//!
//! This module is part of the **core/** foundation (Layer 1). It contains:
//!
//! - **Types**: `StorageValue` (dedicated ADT for storage values)
//! - **Traits**: `ComponentStorage` (abstraction for key-value storage)
//! - **Errors**: `StorageError` (co-located)
//!
//! Concrete implementations are provided via host functions.
//!
//! # Design Decision
//!
//! `StorageValue` is a dedicated type (not `MessagePayload`) for domain
//! boundary clarity. Engineers immediately know the type's purpose.
//!
//! # Submodules
//!
//! - [`value`] - `StorageValue` ADT (dedicated storage value type)
//! - [`errors`] - `StorageError` enum (co-located with storage)
//! - [`traits`] - `ComponentStorage` trait
//!
//! # Usage
//!
//! ```rust
//! use airssys_wasm::core::storage::value::StorageValue;
//! use airssys_wasm::core::storage::errors::StorageError;
//! use airssys_wasm::core::storage::traits::ComponentStorage;
//!
//! // Create a storage value
//! let value = StorageValue::new(vec![1, 2, 3]);
//!
//! // Create an error
//! let error = StorageError::NotFound("user:123".to_string());
//! ```

// Module declarations (per PROJECTS_STANDARD.md §4.3)
pub mod errors;
pub mod traits;
pub mod value;

// NOTE: No glob re-exports per module grouping policy.
// Callers use namespaced access: core::storage::value::StorageValue
```

**Verification:**
```bash
# Verify only module declarations
grep -n "pub mod" src/core/storage/mod.rs
# Expected: pub mod errors; pub mod traits; pub mod value;

# Verify no glob re-exports
grep -n "pub use" src/core/storage/mod.rs
# Expected: Empty output
```

---

### Action 5: Update `core/mod.rs`
**Objective:** Add storage submodule declaration and update documentation

**File Location:** `airssys-wasm/src/core/mod.rs`

**Change Required:**
Add `pub mod storage;` and update module documentation.

**Verification:**
```bash
grep -n "pub mod storage" src/core/mod.rs
# Expected: Line with pub mod storage;
```

---

## Verification Commands

Run after ALL actions complete:

```bash
# 0. WIT Validation (CRITICAL - must pass first)
wasm-tools component wit wit/core/
# Expected: No errors, prints consolidated WIT

# 1. Build check
cargo build -p airssys-wasm

# 2. Lint check
cargo clippy -p airssys-wasm --all-targets -- -D warnings

# 3. Run unit tests
cargo test -p airssys-wasm --lib storage

# 4. Verify no MessagePayload dependency 
grep -rn "MessagePayload" src/core/storage/
# Should be empty (no matches)

# 5. Verify Layer 1 compliance (only local imports)
grep -rn "use crate::" src/core/storage/
# Should be empty (no matches)

# 6. Verify WIT alignment
grep -n "storage-value" wit/core/storage.wit
# Should show type definition
```

---

## Success Criteria

- [ ] `cargo build -p airssys-wasm` succeeds with zero warnings
- [ ] `cargo clippy -p airssys-wasm --all-targets -- -D warnings` passes
- [ ] `cargo test -p airssys-wasm --lib storage` passes (all unit tests)
- [ ] `StorageValue` ADT in `core/storage/value.rs` (no MessagePayload dependency)
- [ ] `storage.wit` updated with `storage-value` type
- [ ] `StorageError` aligned with WIT `storage-error` variants
- [ ] All types properly documented with rustdoc

---

## Standards Compliance Matrix

| Standard | Requirement | Evidence |
|----------|-------------|----------|
| §2.1 | 3-Layer Import Organization | All files follow Layer 1/2/3 comments |
| §4.3 | mod.rs only declarations | mod.rs has only `pub mod` |
| §6.2 | Avoid `dyn` patterns | Trait uses `&self` |
| ADR-WASM-028 | Co-located errors | `StorageError` in `core/storage/errors.rs` |
| ADR-WASM-028 | Layer 1 compliance | Zero external module imports |
| Domain Boundary | Dedicated types | `StorageValue` not `MessagePayload` |
| WIT Sync | Interface alignment | `storage.wit` uses `storage-value` |

---

## Estimated Time

- Action 0 (storage.wit update): 5 minutes
- Action 1 (value.rs): 15 minutes
- Action 2 (errors.rs): 15 minutes
- Action 3 (traits.rs): 20 minutes
- Action 4 (mod.rs): 10 minutes
- Action 5 (core/mod.rs update): 5 minutes
- Verification: 10 minutes

**Total: ~80 minutes (1 hour 20 minutes)**
