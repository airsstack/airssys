{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to AirsSys","text":"<p>AirsSys is a comprehensive collection of system programming components designed for the AirsStack ecosystem. It provides secure, modular, and high-performance tools for building robust concurrent applications with strong security guarantees.</p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p>AirsSys consists of multiple specialized components that work together to provide a complete system programming solution:</p>"},{"location":"#osl-os-layer-framework","title":"\ud83d\udee1\ufe0f OSL (OS Layer Framework)","text":"<p>Secure, cross-platform abstraction over operating system functionality with comprehensive audit trails and security policy enforcement.</p> <p>Key Features: - Cross-platform OS abstraction (filesystem, process, network) - Built-in ACL and RBAC security policies - Comprehensive activity logging and audit trails - Middleware pipeline for extensibility - Helper functions for common operations</p> <p>Use Cases: - Secure application development requiring system resources - Enterprise system administration with compliance requirements - Foundation for higher-level AirsStack components</p>"},{"location":"#rt-actor-runtime","title":"\u26a1 RT (Actor Runtime)","text":"<p>Lightweight Erlang-Actor model runtime system for high-concurrency applications with BEAM-inspired supervision and fault tolerance.</p> <p>Key Features: - Zero-cost actor abstraction with compile-time type safety - BEAM-inspired supervision trees (OneForOne, OneForAll, RestForOne) - High performance: ~625ns actor spawn, 4.7M msgs/sec throughput - Broker-based message routing with backpressure control - Comprehensive monitoring and observability</p> <p>Use Cases: - High-concurrency servers requiring fault tolerance - Event-driven architectures with complex state management - System programming with reliable process supervision - Microservice coordination</p>"},{"location":"#component-status","title":"Component Status","text":"Component Status Documentation airssys-osl \u2705 Complete View Docs airssys-rt \u2705 Complete View Docs airssys-wasm \u23f3 In Development Not yet migrated airssys-wasm-cli \u23f3 In Development Not yet migrated airssys-osl-macros \u23f3 In Development Not yet migrated airssys-wasm-component \u23f3 In Development Not yet migrated <p>Documentation Scope</p> <p>This unified documentation covers completed components only (OSL and RT). Components still in active development maintain their individual mdbook documentation until they reach stable status.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#osl-quick-start","title":"OSL Quick Start","text":"<pre><code>use airssys_osl::helpers::*;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Filesystem operations with built-in security\n    let data = b\"Hello, World!\".to_vec();\n    write_file(\"/tmp/test.txt\", data, \"admin\").await?;\n    let content = read_file(\"/tmp/test.txt\", \"admin\").await?;\n\n    // Process operations\n    let output = spawn_process(\"echo\", vec![\"Hello!\".to_string()], \"admin\").await?;\n\n    // Network operations\n    let listener = network_listen(\"127.0.0.1:0\", \"admin\").await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"#rt-quick-start","title":"RT Quick Start","text":"<pre><code>use airssys_rt::prelude::*;\nuse async_trait::async_trait;\n\n// Define message type\n#[derive(Debug, Clone)]\nenum CounterMsg {\n    Increment,\n    GetCount(tokio::sync::oneshot::Sender&lt;u64&gt;),\n}\n\nimpl Message for CounterMsg {\n    const MESSAGE_TYPE: &amp;'static str = \"counter\";\n}\n\n// Define actor\nstruct CounterActor {\n    count: u64,\n}\n\n// Implement Actor trait\n#[async_trait]\nimpl Actor for CounterActor {\n    type Message = CounterMsg;\n    type Error = std::io::Error;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        msg: Self::Message,\n        ctx: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        match msg {\n            CounterMsg::Increment =&gt; self.count += 1,\n            CounterMsg::GetCount(reply) =&gt; {\n                let _ = reply.send(self.count);\n            }\n        }\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"#design-philosophy","title":"Design Philosophy","text":""},{"location":"#security-by-default","title":"Security by Default","text":"<p>All AirsSys components implement a deny-by-default security model. Operations are only permitted when explicitly allowed by security policies, with comprehensive audit trails for compliance.</p>"},{"location":"#zero-cost-abstractions","title":"Zero-Cost Abstractions","text":"<p>AirsSys leverages Rust's zero-cost abstractions to provide high-level APIs without runtime overhead. Generic constraints and compile-time monomorphization eliminate the need for dynamic dispatch in hot paths.</p>"},{"location":"#modular-architecture","title":"Modular Architecture","text":"<p>Components are designed to work independently or together. Use OSL for secure system operations, RT for actor-based concurrency, or combine them for complete system programming solutions.</p>"},{"location":"#fault-tolerance","title":"Fault Tolerance","text":"<p>Following Erlang/OTP principles, AirsSys embraces the \"let it crash\" philosophy. Supervisor trees monitor process health and automatically restart failed components with configurable strategies.</p>"},{"location":"#integration","title":"Integration","text":"<p>AirsSys components are designed to integrate seamlessly:</p> <pre><code>// OSL actors managed by RT supervisor\nuse airssys_rt::supervisor::OSLSupervisor;\nuse airssys_osl::operations::filesystem::FileReadOperation;\n\n// RT manages OSL operations with fault tolerance\nlet supervisor = OSLSupervisor::new(broker.clone());\nsupervisor.start().await?;\n\n// Actors handle OS operations with supervision\n// See integration guides for complete examples\n</code></pre> <p>See Integration Guide for detailed patterns and examples.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Choose your path based on your needs:</p> <ol> <li>Getting Started Guide - Installation and basic setup</li> <li>Architecture Overview - System design and principles</li> <li>OSL Documentation - OS abstraction layer</li> <li>RT Documentation - Actor runtime system</li> <li>Examples - Practical usage patterns</li> </ol>"},{"location":"#resources","title":"Resources","text":"<ul> <li>Repository: github.com/airsstack/airssys</li> <li>Issues: Report bugs and request features</li> <li>API Documentation: Run <code>cargo doc --open</code> in the repository</li> <li>Contributing: See Contributing Guide</li> </ul>"},{"location":"#license","title":"License","text":"<p>AirsSys is dual-licensed under:</p> <ul> <li>Apache License 2.0</li> <li>MIT License</li> </ul> <p>You may choose either license at your option.</p> <p>Current Version: 0.1.0 Last Updated: December 2025</p>"},{"location":"architecture/","title":"AirsSys Architecture","text":"<p>This document describes the overall architecture of the AirsSys ecosystem and how its components work together.</p>"},{"location":"architecture/#system-overview","title":"System Overview","text":"<p>AirsSys is designed as a layered system where each component has clear responsibilities:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Applications                           \u2502\n\u2502            (Your Code Using AirsSys)                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              AirsSys Components Layer                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502  OSL Framework   \u2502\u2190\u2500\u2500\u2500\u2500\u2192\u2502    RT Runtime System    \u2502 \u2502\n\u2502  \u2502  (OS Operations) \u2502      \u2502  (Actor Concurrency)    \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                Operating System Layer                     \u2502\n\u2502         (Linux, macOS, Windows, etc.)                    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#component-architecture","title":"Component Architecture","text":""},{"location":"architecture/#osl-os-layer-architecture","title":"OSL (OS Layer) Architecture","text":"<p>The OS Layer uses a middleware pipeline pattern:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Application Code                \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502      Helper Functions API (Level 1)    \u2502\n\u2502  read_file(), write_file(), etc.       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       Middleware Pipeline               \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502   Logger     \u2502\u2192 \u2502   Security     \u2502 \u2502\n\u2502  \u2502  Middleware  \u2502  \u2502   Middleware   \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502            Executors                    \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u2502\n\u2502  \u2502Filesystem\u2502 \u2502 Process \u2502 \u2502 Network \u2502\u2502\n\u2502  \u2502 Executor \u2502 \u2502Executor \u2502 \u2502Executor \u2502\u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502\n                 \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Operating System              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Key design decisions: - Operations are immutable types - Middleware has opportunity to inspect/modify - Executors are pluggable and testable - Security enforced before execution</p>"},{"location":"architecture/#rt-actor-runtime-architecture","title":"RT (Actor Runtime) Architecture","text":"<p>The Actor Runtime uses a supervisor tree pattern:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        Supervisor Tree Root             \u2502\n\u2502     (restart strategy: OneForOne)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502         \u2502          \u2502\n    \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u25bc\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n    \u2502 Actor 1 \u2502\u2502Actor 2\u2502\u2502 Actor 3 \u2502\n    \u2502(Worker) \u2502\u2502(Super)\u2502\u2502(Worker) \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                   \u2502\n              \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n              \u2502 Actor 4 \u2502\n              \u2502(Worker) \u2502\n              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nMessage Flow:\n    Application\n         \u2193\n    Message Broker (routing)\n         \u2193\n    Actor Mailbox (buffering)\n         \u2193\n    Actor (sequential processing)\n</code></pre> <p>Key design decisions: - Actors are isolated (no shared state) - Messages are async and immutable - Mailboxes provide backpressure - Supervisors monitor and restart</p>"},{"location":"architecture/#integration-patterns","title":"Integration Patterns","text":""},{"location":"architecture/#pattern-1-osl-with-rt-supervision","title":"Pattern 1: OSL with RT Supervision","text":"<p>Wrap OSL operations in RT actors for fault tolerance:</p> <pre><code>// OSL actor managed by RT supervisor\nstruct FileSystemActor;\n\n#[async_trait]\nimpl Actor for FileSystemActor {\n    async fn handle_message(&amp;mut self, msg: FileOp) {\n        match msg {\n            FileOp::Read(path) =&gt; {\n                // Use OSL helper\n                let content = read_file(&amp;path, \"system\").await?;\n                // Process content...\n            }\n        }\n    }\n}\n</code></pre> <p>The supervisor automatically restarts the actor if OSL operations fail.</p>"},{"location":"architecture/#pattern-2-osl-middleware-in-rt-message-handler","title":"Pattern 2: OSL Middleware in RT Message Handler","text":"<p>Use OSL middleware directly in RT actors:</p> <pre><code>struct SecureFileActor {\n    security: SecurityMiddleware,\n}\n\n#[async_trait]\nimpl Actor for SecureFileActor {\n    async fn handle_message(&amp;mut self, msg: FileOp) {\n        // OSL security check\n        self.security.check_access(&amp;msg.path, &amp;msg.principal)?;\n\n        // Execute operation\n        let result = execute_file_operation(msg).await?;\n        Ok(result)\n    }\n}\n</code></pre>"},{"location":"architecture/#pattern-3-complete-integration","title":"Pattern 3: Complete Integration","text":"<p>Use the built-in <code>OSLSupervisor</code>:</p> <pre><code>use airssys_rt::supervisor::OSLSupervisor;\n\nlet supervisor = OSLSupervisor::new(broker);\nsupervisor.start().await?;\n\n// FileSystem, Process, Network actors now running\n// with full OSL security and RT fault tolerance\n</code></pre>"},{"location":"architecture/#data-flow","title":"Data Flow","text":""},{"location":"architecture/#osl-operation-execution","title":"OSL Operation Execution","text":"<ol> <li>Application calls helper function: <code>read_file(path, principal)</code></li> <li>Helper creates operation: <code>FileReadOperation::new(path)</code></li> <li>Helper creates context: <code>ExecutionContext::new(SecurityContext::new(principal))</code></li> <li>Middleware logs operation: <code>Logger::log_operation(op, ctx)</code></li> <li>Middleware checks security: <code>Security::check_policy(op, ctx)</code></li> <li>Executor executes: <code>FilesystemExecutor::execute(op, ctx)</code></li> <li>Result returned to application</li> </ol>"},{"location":"architecture/#rt-message-processing","title":"RT Message Processing","text":"<ol> <li>Application publishes message: <code>broker.publish(msg, address)</code></li> <li>Broker routes to mailbox: <code>mailbox.send(envelope)</code></li> <li>Mailbox queues message (applies backpressure if full)</li> <li>Actor dequeues message: <code>mailbox.receive()</code></li> <li>Actor processes sequentially: <code>actor.handle_message(msg)</code></li> <li>Supervisor monitors health: <code>supervisor.check_child()</code></li> <li>Supervisor restarts on failure: <code>supervisor.restart_child()</code></li> </ol>"},{"location":"architecture/#security-architecture","title":"Security Architecture","text":""},{"location":"architecture/#osl-security-model","title":"OSL Security Model","text":"<p>Deny-by-default: All operations denied unless explicitly allowed.</p> <p>Policy hierarchy: <pre><code>1. Check ACL (Access Control List)\n   - Glob pattern matching on paths\n   - Per-resource permissions\n\n2. Check RBAC (Role-Based Access Control)\n   - Role hierarchy traversal\n   - Permission inheritance\n\n3. Check custom policies\n   - Rate limiting\n   - Time-based access\n   - Custom logic\n</code></pre></p> <p>Audit trail: <pre><code>{\n  \"timestamp\": \"2025-12-10T10:30:00Z\",\n  \"principal\": \"alice\",\n  \"operation\": \"FileRead\",\n  \"resource\": \"/data/sensitive.txt\",\n  \"result\": \"allowed\",\n  \"policy\": \"acl:data-read\"\n}\n</code></pre></p>"},{"location":"architecture/#rt-security-model","title":"RT Security Model","text":"<p>Isolation: Each actor has private state, enforced by Rust ownership.</p> <p>Message validation: Messages must implement <code>Message</code> trait.</p> <p>Supervision: Failed actors restarted without affecting siblings.</p>"},{"location":"architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"architecture/#osl-performance","title":"OSL Performance","text":"<ul> <li>Helper functions: ~100\u03bcs overhead (logging + security)</li> <li>Middleware: ~10\u03bcs per middleware</li> <li>Executors: Direct OS call performance</li> </ul>"},{"location":"architecture/#rt-performance","title":"RT Performance","text":"<ul> <li>Actor spawn: ~625ns</li> <li>Message throughput: 4.7M msgs/sec</li> <li>Message latency: &lt;1ms p99</li> <li>Mailbox overhead: ~182ns per message</li> </ul>"},{"location":"architecture/#deployment-architecture","title":"Deployment Architecture","text":""},{"location":"architecture/#development","title":"Development","text":"<pre><code>Local Development\n\u251c\u2500\u2500 cargo run              # Direct execution\n\u251c\u2500\u2500 cargo test            # Unit tests\n\u2514\u2500\u2500 cargo doc --open      # API docs\n</code></pre>"},{"location":"architecture/#production","title":"Production","text":"<pre><code>Production Deployment\n\u251c\u2500\u2500 Binary with tokio runtime\n\u251c\u2500\u2500 OSL with file/console logging\n\u251c\u2500\u2500 RT with monitoring enabled\n\u2514\u2500\u2500 External metrics (Prometheus/etc)\n</code></pre>"},{"location":"architecture/#component-boundaries","title":"Component Boundaries","text":""},{"location":"architecture/#osl-boundaries","title":"OSL Boundaries","text":"<p>Inputs: Operation types, security context Outputs: Execution results, audit logs External deps: OS syscalls, filesystem, network stack</p>"},{"location":"architecture/#rt-boundaries","title":"RT Boundaries","text":"<p>Inputs: Messages, actor addresses Outputs: Message routing, supervision events External deps: Tokio runtime, async channels</p>"},{"location":"architecture/#next-steps","title":"Next Steps","text":"<ul> <li>OSL Architecture Details</li> <li>RT Architecture Details</li> <li>Integration Guide</li> <li>Performance Guide</li> </ul>"},{"location":"contributing/","title":"Contributing to AirsSys","text":"<p>Thank you for your interest in contributing to AirsSys! This document provides guidelines for contributing to the project.</p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust 2021 edition or later</li> <li>Git</li> <li>Familiarity with async/await Rust</li> <li>Understanding of the AirsStack ecosystem</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/airsstack/airssys\ncd airssys\n\n# Build all components\ncargo build --workspace\n\n# Run tests\ncargo test --workspace\n\n# Run examples\ncargo run --example actor_basic\n</code></pre>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>airssys/\n\u251c\u2500\u2500 airssys-osl/          # OS Layer Framework\n\u251c\u2500\u2500 airssys-osl-macros/   # OSL procedural macros\n\u251c\u2500\u2500 airssys-rt/           # Actor Runtime\n\u251c\u2500\u2500 airssys-wasm/         # WASM Component Framework\n\u251c\u2500\u2500 airssys-wasm-cli/     # WASM CLI tools\n\u251c\u2500\u2500 airssys-wasm-component/ # WASM component macros\n\u251c\u2500\u2500 docs/                 # Unified documentation\n\u251c\u2500\u2500 site-mkdocs/          # MkDocs configuration\n\u2514\u2500\u2500 .github/workflows/    # CI/CD workflows\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#1-find-or-create-an-issue","title":"1. Find or Create an Issue","text":"<ul> <li>Check existing issues on GitHub</li> <li>Create a new issue if needed</li> <li>Discuss approach before major changes</li> </ul>"},{"location":"contributing/#2-create-a-branch","title":"2. Create a Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n</code></pre> <p>Branch naming conventions: - <code>feature/</code> - New features - <code>fix/</code> - Bug fixes - <code>docs/</code> - Documentation updates - <code>refactor/</code> - Code refactoring - <code>test/</code> - Test additions/improvements</p>"},{"location":"contributing/#3-make-changes","title":"3. Make Changes","text":"<p>Follow the coding standards below.</p>"},{"location":"contributing/#4-test-your-changes","title":"4. Test Your Changes","text":"<pre><code># Run all tests\ncargo test --workspace\n\n# Run component-specific tests\ncargo test --package airssys-osl\ncargo test --package airssys-rt\n\n# Run with features\ncargo test --features macros\n\n# Check code quality\ncargo clippy --workspace --all-targets --all-features\ncargo fmt --all -- --check\n</code></pre>"},{"location":"contributing/#5-commit-your-changes","title":"5. Commit Your Changes","text":"<p>Follow conventional commits:</p> <pre><code>type(scope): description\n\n[optional body]\n\n[optional footer]\n</code></pre> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation changes - <code>style</code>: Code style changes (formatting) - <code>refactor</code>: Code refactoring - <code>test</code>: Test changes - <code>chore</code>: Build/tooling changes</p> <p>Examples: <pre><code>feat(osl): add rate limiting middleware\nfix(rt): resolve actor spawn race condition\ndocs(guides): add integration examples\n</code></pre></p>"},{"location":"contributing/#6-push-and-create-pull-request","title":"6. Push and Create Pull Request","text":"<pre><code>git push origin feature/your-feature-name\n</code></pre> <p>Then create a pull request on GitHub.</p>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"contributing/#rust-style","title":"Rust Style","text":"<p>Follow the Rust API Guidelines:</p> <pre><code>// \u2705 Good: Clear, documented, idiomatic\n/// Reads a file with security checks\n///\n/// # Arguments\n/// * `path` - File path to read\n/// * `principal` - Security principal\n///\n/// # Errors\n/// Returns `OSError` if access denied or file not found\npub async fn read_file(\n    path: &amp;str,\n    principal: &amp;str,\n) -&gt; Result&lt;Vec&lt;u8&gt;, OSError&gt; {\n    // Implementation\n}\n\n// \u274c Bad: Undocumented, unclear\npub async fn rf(p: &amp;str, pr: &amp;str) -&gt; Result&lt;Vec&lt;u8&gt;, OSError&gt; {\n    // Implementation\n}\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>Document all public APIs</li> <li>Include examples in doc comments</li> <li>Explain non-obvious design decisions</li> <li>Keep docs up-to-date with code</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<ul> <li>Write unit tests for new functionality</li> <li>Write integration tests for component interactions</li> <li>Aim for &gt;80% code coverage</li> <li>Include both success and failure cases</li> </ul> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_file_read_success() {\n        // Test successful read\n    }\n\n    #[tokio::test]\n    async fn test_file_read_access_denied() {\n        // Test access denied\n    }\n}\n</code></pre>"},{"location":"contributing/#error-handling","title":"Error Handling","text":"<ul> <li>Use appropriate error types</li> <li>Provide helpful error messages</li> <li>Don't leak sensitive information</li> <li>Log errors appropriately</li> </ul> <pre><code>// \u2705 Good: Clear error with context\nreturn Err(OSError::AccessDenied {\n    resource: path.to_string(),\n    principal: context.principal().to_string(),\n});\n\n// \u274c Bad: Vague error\nreturn Err(OSError::Unknown);\n</code></pre>"},{"location":"contributing/#component-specific-guidelines","title":"Component-Specific Guidelines","text":""},{"location":"contributing/#osl-guidelines","title":"OSL Guidelines","text":"<ul> <li>All operations must be security-checked</li> <li>Add middleware for cross-cutting concerns</li> <li>Executors must be platform-agnostic</li> <li>Helper functions must use default security</li> </ul>"},{"location":"contributing/#rt-guidelines","title":"RT Guidelines","text":"<ul> <li>Actors must not share mutable state</li> <li>Use message passing exclusively</li> <li>Implement proper lifecycle hooks</li> <li>Add supervision for fault tolerance</li> <li>Messages must be Send + Sync</li> </ul>"},{"location":"contributing/#documentation-updates","title":"Documentation Updates","text":"<p>When adding features:</p> <ol> <li>Update relevant API documentation</li> <li>Add examples demonstrating usage</li> <li>Update integration guide if needed</li> <li>Update migration guide for breaking changes</li> </ol>"},{"location":"contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Build MkDocs documentation\ncd site-mkdocs\nmkdocs serve\n\n# Build API documentation\ncargo doc --open --workspace\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"contributing/#pr-checklist","title":"PR Checklist","text":"<ul> <li> Code follows project style</li> <li> All tests pass</li> <li> New tests added for new functionality</li> <li> Documentation updated</li> <li> Commit messages follow conventions</li> <li> No merge conflicts</li> <li> CI/CD passes</li> </ul>"},{"location":"contributing/#review-process","title":"Review Process","text":"<ol> <li>Maintainer reviews PR</li> <li>Feedback provided if needed</li> <li>Make requested changes</li> <li>Re-review after changes</li> <li>Merge when approved</li> </ol>"},{"location":"contributing/#after-merge","title":"After Merge","text":"<ul> <li>PR is merged to <code>main</code> branch</li> <li>Documentation automatically deployed</li> <li>Close related issues</li> <li>Update any tracking documents</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":""},{"location":"contributing/#our-standards","title":"Our Standards","text":"<ul> <li>Be respectful and inclusive</li> <li>Welcome newcomers</li> <li>Provide constructive feedback</li> <li>Focus on what's best for the community</li> </ul>"},{"location":"contributing/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for: - Clarifying standards of acceptable behavior - Taking corrective action when needed - Enforcing the code of conduct</p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>Report unacceptable behavior to: hiraqdev@gmail.com</p>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Questions: Open a GitHub Discussion</li> <li>Bugs: Open a GitHub Issue</li> <li>Security: Email hiraqdev@gmail.com</li> <li>Chat: Join our community (link coming soon)</li> </ul>"},{"location":"contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in: - CONTRIBUTORS.md file - Release notes - Project README</p> <p>Thank you for contributing to AirsSys!</p>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to AirsSys, you agree that your contributions will be licensed under both the Apache License 2.0 and MIT License.</p>"},{"location":"getting-started/","title":"Getting Started with AirsSys","text":"<p>This guide will help you get started with AirsSys components.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust: 2021 edition or later (install from rustup.rs)</li> <li>Tokio: Async runtime (included as dependency)</li> <li>Operating System: Linux, macOS, or Windows</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Add AirsSys components to your <code>Cargo.toml</code>:</p>"},{"location":"getting-started/#for-osl-os-layer","title":"For OSL (OS Layer)","text":"<pre><code>[dependencies]\nairssys-osl = { version = \"0.1\", features = [\"macros\"] }\ntokio = { version = \"1.0\", features = [\"full\"] }\n</code></pre>"},{"location":"getting-started/#for-rt-actor-runtime","title":"For RT (Actor Runtime)","text":"<pre><code>[dependencies]\nairssys-rt = \"0.1.0\"\nasync-trait = \"0.1\"\ntokio = { version = \"1.47\", features = [\"full\"] }\n</code></pre>"},{"location":"getting-started/#for-both","title":"For Both","text":"<pre><code>[dependencies]\nairssys-osl = { version = \"0.1\", features = [\"macros\"] }\nairssys-rt = \"0.1.0\"\nasync-trait = \"0.1\"\ntokio = { version = \"1.47\", features = [\"full\"] }\n</code></pre>"},{"location":"getting-started/#your-first-osl-application","title":"Your First OSL Application","text":"<p>Create a new project and add the following to <code>src/main.rs</code>:</p> <pre><code>use airssys_osl::helpers::*;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Write a file with built-in security\n    let message = b\"Hello from AirsSys OSL!\".to_vec();\n    write_file(\"/tmp/airssys_test.txt\", message, \"admin\").await?;\n    println!(\"\u2713 File written successfully\");\n\n    // Read the file back\n    let content = read_file(\"/tmp/airssys_test.txt\", \"admin\").await?;\n    println!(\"\u2713 File content: {}\", String::from_utf8_lossy(&amp;content));\n\n    // Clean up\n    delete_file(\"/tmp/airssys_test.txt\", \"admin\").await?;\n    println!(\"\u2713 File deleted successfully\");\n\n    Ok(())\n}\n</code></pre> <p>Run it: <pre><code>cargo run\n</code></pre></p>"},{"location":"getting-started/#your-first-rt-application","title":"Your First RT Application","text":"<p>Create a new project and add the following to <code>src/main.rs</code>:</p> <pre><code>use airssys_rt::prelude::*;\nuse async_trait::async_trait;\n\n// 1. Define your message type\n#[derive(Debug, Clone)]\nenum CounterMsg {\n    Increment,\n    GetCount(tokio::sync::oneshot::Sender&lt;u64&gt;),\n}\n\nimpl Message for CounterMsg {\n    const MESSAGE_TYPE: &amp;'static str = \"counter\";\n}\n\n// 2. Define your actor\nstruct CounterActor {\n    count: u64,\n}\n\n// 3. Implement the Actor trait\n#[async_trait]\nimpl Actor for CounterActor {\n    type Message = CounterMsg;\n    type Error = std::io::Error;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        msg: Self::Message,\n        ctx: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        match msg {\n            CounterMsg::Increment =&gt; {\n                self.count += 1;\n                println!(\"Count incremented to: {}\", self.count);\n            }\n            CounterMsg::GetCount(reply) =&gt; {\n                let _ = reply.send(self.count);\n            }\n        }\n        Ok(())\n    }\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create message broker\n    let broker = InMemoryMessageBroker::&lt;CounterMsg&gt;::new();\n\n    // Create and start actor\n    let actor = CounterActor { count: 0 };\n    let address = ActorAddress::new(\"counter-1\");\n\n    // Spawn actor\n    spawn_actor(actor, address.clone(), broker.clone()).await?;\n\n    // Send messages\n    broker.publish(CounterMsg::Increment, address.clone()).await?;\n    broker.publish(CounterMsg::Increment, address.clone()).await?;\n\n    // Query count\n    let (tx, rx) = tokio::sync::oneshot::channel();\n    broker.publish(CounterMsg::GetCount(tx), address).await?;\n\n    let count = rx.await?;\n    println!(\"\u2713 Final count: {}\", count);\n\n    Ok(())\n}\n</code></pre> <p>Run it: <pre><code>cargo run\n</code></pre></p>"},{"location":"getting-started/#integrated-application","title":"Integrated Application","text":"<p>Combine OSL and RT for a complete system:</p> <pre><code>use airssys_osl::helpers::*;\nuse airssys_rt::prelude::*;\nuse airssys_rt::supervisor::OSLSupervisor;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create message broker\n    let broker = InMemoryMessageBroker::new();\n\n    // Create OSL supervisor with RT\n    let supervisor = OSLSupervisor::new(broker.clone());\n    supervisor.start().await?;\n\n    // Now FileSystem, Process, and Network actors are running\n    // with fault tolerance from the supervisor\n\n    println!(\"\u2713 AirsSys integrated system running\");\n\n    // Use OSL operations with RT supervision\n    let content = read_file(\"/etc/hosts\", \"admin\").await?;\n    println!(\"\u2713 Read {} bytes with supervision\", content.len());\n\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/#development-workflow","title":"Development Workflow","text":""},{"location":"getting-started/#project-structure","title":"Project Structure","text":"<p>Recommended project structure:</p> <pre><code>my-airssys-app/\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.rs\n\u2502   \u251c\u2500\u2500 actors/          # RT actors\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u2502   \u2514\u2500\u2500 my_actor.rs\n\u2502   \u2514\u2500\u2500 operations/      # OSL operations\n\u2502       \u251c\u2500\u2500 mod.rs\n\u2502       \u2514\u2500\u2500 my_ops.rs\n\u251c\u2500\u2500 examples/            # Usage examples\n\u2514\u2500\u2500 tests/               # Integration tests\n</code></pre>"},{"location":"getting-started/#running-examples","title":"Running Examples","text":"<p>AirsSys includes comprehensive examples:</p> <pre><code># OSL examples\ncargo run --example helper_functions_comprehensive\ncargo run --example security_middleware_comprehensive\ncargo run --example custom_executor_with_macro --features macros\n\n# RT examples\ncargo run --example actor_basic\ncargo run --example supervisor_basic\ncargo run --example osl_integration_example\n</code></pre>"},{"location":"getting-started/#testing","title":"Testing","text":"<pre><code># Run all tests\ncargo test\n\n# Run specific component tests\ncargo test --package airssys-osl\ncargo test --package airssys-rt\n\n# Run with verbose output\ncargo test -- --nocapture\n</code></pre>"},{"location":"getting-started/#building-documentation","title":"Building Documentation","text":"<pre><code># Build API documentation\ncargo doc --open\n\n# View component examples\nls examples/\n</code></pre>"},{"location":"getting-started/#configuration","title":"Configuration","text":""},{"location":"getting-started/#osl-configuration","title":"OSL Configuration","text":"<p>Configure security policies:</p> <pre><code>use airssys_osl::middleware::security::*;\n\n// Create ACL policy\nlet acl = AccessControlList::new()\n    .add_entry(AclEntry::new(\n        \"alice\".to_string(),\n        \"/data/*\".to_string(),\n        vec![\"read\".to_string(), \"write\".to_string()],\n        AclPolicy::Allow,\n    ));\n\n// Build security middleware\nlet security = SecurityMiddlewareBuilder::new()\n    .add_policy(Box::new(acl))\n    .build()?;\n</code></pre>"},{"location":"getting-started/#rt-configuration","title":"RT Configuration","text":"<p>Configure actor system:</p> <pre><code>use airssys_rt::system::{ActorSystemConfig, ActorSystemBuilder};\n\nlet config = ActorSystemConfig {\n    max_actors: 10000,\n    default_mailbox_size: 1000,\n    enable_monitoring: true,\n};\n\nlet system = ActorSystemBuilder::new()\n    .with_config(config)\n    .build()?;\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have AirsSys running, explore:</p> <ol> <li>OSL Documentation - Deep dive into secure OS operations</li> <li>RT Documentation - Master actor-based concurrency</li> <li>Examples - Learn from real-world patterns</li> <li>Integration Guide - Combine components effectively</li> </ol>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/#common-issues","title":"Common Issues","text":"<p>Issue: <code>error: future cannot be sent between threads safely</code></p> <p>Solution: Ensure your actors implement <code>Send + Sync</code>: <pre><code>#[async_trait]\nimpl Actor for MyActor {\n    // Actor methods must be Send + Sync\n}\n</code></pre></p> <p>Issue: OSL operation denied</p> <p>Solution: Check security policies allow the operation: <pre><code>// Operations denied by default\n// Explicitly allow in ACL or RBAC policy\n</code></pre></p> <p>Issue: Actor not receiving messages</p> <p>Solution: Verify broker and address are correctly configured: <pre><code>// Ensure same broker instance and correct address\nbroker.publish(msg, address.clone()).await?;\n</code></pre></p>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Examples: Check <code>/examples</code> directory for working code</li> <li>API Docs: Run <code>cargo doc --open</code> for detailed API reference</li> <li>Issues: Report bugs on GitHub</li> </ul>"},{"location":"getting-started/#performance-tips","title":"Performance Tips","text":""},{"location":"getting-started/#osl-performance","title":"OSL Performance","text":"<ul> <li>Use helper functions for simple operations</li> <li>Batch operations when possible</li> <li>Configure appropriate log levels</li> </ul>"},{"location":"getting-started/#rt-performance","title":"RT Performance","text":"<ul> <li>Tune mailbox sizes for workload</li> <li>Use appropriate supervisor strategies</li> <li>Monitor actor metrics</li> </ul> <p>See Performance Guide for detailed optimization strategies.</p>"},{"location":"overview/","title":"AirsSys Overview","text":"<p>AirsSys is a comprehensive system programming framework designed for the AirsStack ecosystem. It provides secure, modular components for building high-performance concurrent applications with strong security guarantees.</p>"},{"location":"overview/#what-is-airssys","title":"What is AirsSys?","text":"<p>AirsSys addresses the critical challenges of modern system programming:</p> <ul> <li>Security: Direct OS interactions expose applications to security threats</li> <li>Complexity: Low-level programming is error-prone and platform-specific  </li> <li>Concurrency: Building fault-tolerant concurrent systems is difficult</li> <li>Auditability: Most OS operations lack comprehensive logging</li> </ul> <p>AirsSys solves these challenges through:</p> <ol> <li>OSL (OS Layer) - Secure, audited OS abstractions</li> <li>RT (Actor Runtime) - Fault-tolerant concurrency</li> <li>Integration - Components work together seamlessly</li> </ol>"},{"location":"overview/#components","title":"Components","text":""},{"location":"overview/#osl-os-layer-framework","title":"OSL - OS Layer Framework","text":"<p>Purpose: Secure abstraction over operating system functionality</p> <p>The OS Layer provides a cross-platform interface to system operations with built-in security policies and comprehensive audit logging. Instead of using raw <code>std::fs</code> or <code>std::process</code>, applications use OSL's helper functions that automatically enforce ACL/RBAC policies and log all activities.</p> <p>Architecture: <pre><code>Application Code\n     \u2193\nHelper Functions API\n     \u2193\nMiddleware Pipeline (Logger \u2192 Security)\n     \u2193\nExecutors (Filesystem, Process, Network)\n     \u2193\nOperating System\n</code></pre></p> <p>Key capabilities: - File I/O with path-based access control - Process spawning with security context - Network operations with capability enforcement - Extensible middleware for custom logic</p> <p>Security model: - Deny-by-default access control - ACL (Access Control Lists) with glob patterns - RBAC (Role-Based Access Control) with inheritance - JSON audit logs for compliance</p>"},{"location":"overview/#rt-actor-runtime-system","title":"RT - Actor Runtime System","text":"<p>Purpose: Erlang-inspired actor model for fault-tolerant concurrency</p> <p>The Actor Runtime implements lightweight virtual processes with BEAM-inspired supervision. Applications build actor systems where isolated processes communicate through message passing, and supervisor trees automatically restart failed actors.</p> <p>Architecture: <pre><code>Supervisor Tree\n     \u2193\n  Actors (isolated state)\n     \u2193\nMessage Broker (routing)\n     \u2193\n  Mailboxes (backpressure)\n</code></pre></p> <p>Key capabilities: - Zero-cost actor abstraction (~625ns spawn) - High throughput (4.7M messages/sec) - Supervision strategies (OneForOne, OneForAll, RestForOne) - Automatic failure recovery - Broker-based pub/sub messaging</p> <p>Concurrency model: - Encapsulated actor state (no shared memory) - Asynchronous message passing - Sequential message processing - Fault isolation with supervisors</p>"},{"location":"overview/#integration-patterns","title":"Integration Patterns","text":"<p>AirsSys components are designed to work independently or together:</p>"},{"location":"overview/#standalone-usage","title":"Standalone Usage","text":"<p>OSL standalone: <pre><code>use airssys_osl::helpers::*;\n\n// Secure file operations\nlet content = read_file(\"/data/config.toml\", \"admin\").await?;\n</code></pre></p> <p>RT standalone: <pre><code>use airssys_rt::prelude::*;\n\n// Actor-based service\nlet actor = MyActor::new();\nlet address = spawn_actor(actor, broker).await?;\n</code></pre></p>"},{"location":"overview/#combined-usage","title":"Combined Usage","text":"<p>OSL actors supervised by RT: <pre><code>use airssys_rt::supervisor::OSLSupervisor;\n\n// RT supervisor manages OSL operations\nlet supervisor = OSLSupervisor::new(broker);\nsupervisor.start().await?;\n\n// Filesystem, Process, Network actors with fault tolerance\n</code></pre></p> <p>This pattern provides: - Secure OS operations (OSL) - Fault tolerance (RT supervision) - Automatic recovery from failures - Comprehensive audit trails</p>"},{"location":"overview/#design-principles","title":"Design Principles","text":""},{"location":"overview/#security-by-default","title":"Security by Default","text":"<p>All operations are denied unless explicitly allowed. Security policies are enforced at the middleware layer before execution. Every operation is logged with security context for audit trails.</p>"},{"location":"overview/#zero-cost-abstractions","title":"Zero-Cost Abstractions","text":"<p>AirsSys uses Rust's generics and compile-time monomorphization to eliminate runtime overhead. The high-level API compiles to the same machine code as hand-written low-level code.</p>"},{"location":"overview/#modularity","title":"Modularity","text":"<p>Each component has a clear purpose and can be used independently. OSL doesn't require RT, and RT doesn't require OSL. Integration is opt-in through well-defined interfaces.</p>"},{"location":"overview/#fault-tolerance","title":"Fault Tolerance","text":"<p>Following Erlang/OTP, AirsSys embraces the \"let it crash\" philosophy: - Write simple code for the happy path - Let failures propagate cleanly - Use supervisors to detect and recover from failures - Isolate failures to prevent cascade effects</p>"},{"location":"overview/#use-cases","title":"Use Cases","text":""},{"location":"overview/#enterprise-applications","title":"Enterprise Applications","text":"<p>Requirements: - Secure file processing with compliance logging - Multi-tenant access control - Audit trails for SOC 2 / HIPAA</p> <p>Solution: OSL with ACL policies and audit logging</p>"},{"location":"overview/#high-concurrency-services","title":"High-Concurrency Services","text":"<p>Requirements: - Handle 10,000+ concurrent connections - Graceful failure recovery - Low latency (&lt;100ms p99)</p> <p>Solution: RT with supervisor trees</p>"},{"location":"overview/#system-administration","title":"System Administration","text":"<p>Requirements: - Automate system operations - Secure script execution - Monitor all activities</p> <p>Solution: OSL for operations, RT for workflow orchestration</p>"},{"location":"overview/#microservices","title":"Microservices","text":"<p>Requirements: - Service-to-service communication - Circuit breakers and retries - Distributed coordination</p> <p>Solution: RT actors with message broker</p>"},{"location":"overview/#component-comparison","title":"Component Comparison","text":"Feature OSL RT Primary Focus OS abstraction &amp; security Concurrency &amp; fault tolerance Security Model ACL/RBAC policies Actor isolation Performance OS-bound ~4.7M msgs/sec Fault Tolerance Error propagation Supervision trees State Management Stateless operations Encapsulated actor state Logging Activity audit logs Event monitoring Use Alone \u2705 Yes \u2705 Yes Use Together \u2705 Yes \u2705 Yes"},{"location":"overview/#technology-stack","title":"Technology Stack","text":"<p>AirsSys is built on proven Rust ecosystem crates:</p> <ul> <li>Tokio - Async runtime foundation</li> <li>async-trait - Trait async fn support</li> <li>serde - Serialization for logging</li> <li>Platform-specific - <code>nix</code> for Unix, <code>winapi</code> for Windows</li> </ul>"},{"location":"overview/#getting-started","title":"Getting Started","text":"<p>Ready to start using AirsSys?</p> <ol> <li>Getting Started Guide - Installation and first steps</li> <li>OSL Documentation - Secure OS operations</li> <li>RT Documentation - Actor concurrency</li> <li>Examples - Working code samples</li> </ol>"},{"location":"overview/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture deep dive: Architecture</li> <li>Integration patterns: Integration Guide</li> <li>Performance tuning: Performance Guide</li> <li>Security best practices: Security Guide</li> </ul>"},{"location":"components/","title":"AirsSys Components","text":"<p>AirsSys consists of multiple specialized components designed to work independently or together. This section provides detailed documentation for each component.</p>"},{"location":"components/#completed-components","title":"Completed Components","text":"<p>These components are production-ready and fully documented:</p>"},{"location":"components/#osl-os-layer-framework","title":"OSL (OS Layer Framework)","text":"<p>Secure, cross-platform abstraction over operating system functionality.</p> <p>Status: \u2705 Complete Version: 0.1.0 Key Features: - Cross-platform OS abstractions - Built-in security (ACL/RBAC) - Comprehensive audit logging - Middleware pipeline - Helper functions API</p> <p>View OSL Documentation \u2192</p>"},{"location":"components/#rt-actor-runtime","title":"RT (Actor Runtime)","text":"<p>Lightweight Erlang-Actor model runtime for high-concurrency applications.</p> <p>Status: \u2705 Complete Version: 0.1.0 Key Features: - Zero-cost actor abstractions - BEAM-inspired supervision - High performance (4.7M msgs/sec) - Fault tolerance - Message broker</p> <p>View RT Documentation \u2192</p>"},{"location":"components/#components-in-development","title":"Components in Development","text":"<p>These components are under active development and not yet covered in this unified documentation:</p>"},{"location":"components/#airssys-wasm","title":"airssys-wasm","text":"<p>WebAssembly Component Framework for pluggable systems.</p> <p>Status: \u23f3 In Development Documentation: See individual mdbook docs in <code>airssys-wasm/docs/</code></p>"},{"location":"components/#airssys-wasm-cli","title":"airssys-wasm-cli","text":"<p>CLI tools for WASM component management.</p> <p>Status: \u23f3 In Development Documentation: Coming soon</p>"},{"location":"components/#airssys-osl-macros","title":"airssys-osl-macros","text":"<p>Procedural macros for OSL custom executors.</p> <p>Status: \u23f3 In Development Documentation: See crate-level docs</p>"},{"location":"components/#airssys-wasm-component","title":"airssys-wasm-component","text":"<p>Procedural macros for WASM component development.</p> <p>Status: \u23f3 In Development Documentation: Coming soon</p>"},{"location":"components/#component-comparison","title":"Component Comparison","text":"Feature OSL RT Purpose OS abstraction &amp; security Actor concurrency API Style Helper functions Trait-based actors Security ACL/RBAC policies Actor isolation Performance OS-bound operations 4.7M msgs/sec State Stateless operations Encapsulated state Async Tokio-based Tokio-based Testing 60+ tests 336+ tests"},{"location":"components/#integration","title":"Integration","text":"<p>Components are designed to integrate seamlessly:</p> <pre><code>// RT supervises OSL operations\nuse airssys_rt::supervisor::OSLSupervisor;\n\nlet supervisor = OSLSupervisor::new(broker);\nsupervisor.start().await?;\n</code></pre> <p>See Integration Guide for detailed patterns.</p>"},{"location":"components/#choosing-components","title":"Choosing Components","text":""},{"location":"components/#use-osl-when-you-need","title":"Use OSL when you need:","text":"<ul> <li>Secure file I/O operations</li> <li>Process spawning with audit trails</li> <li>Network operations with ACL</li> <li>Cross-platform OS abstractions</li> </ul>"},{"location":"components/#use-rt-when-you-need","title":"Use RT when you need:","text":"<ul> <li>High-concurrency actor systems</li> <li>Fault-tolerant services</li> <li>Message-based architectures</li> <li>Supervision trees</li> </ul>"},{"location":"components/#use-both-when-you-need","title":"Use both when you need:","text":"<ul> <li>Secure concurrent operations</li> <li>Fault-tolerant system programming</li> <li>Complete AirsStack integration</li> </ul>"},{"location":"components/#component-roadmap","title":"Component Roadmap","text":""},{"location":"components/#immediate-current","title":"Immediate (Current)","text":"<ul> <li>\u2705 OSL core functionality</li> <li>\u2705 RT actor system</li> <li>\u2705 OSL-RT integration</li> </ul>"},{"location":"components/#short-term-q1-2026","title":"Short-term (Q1 2026)","text":"<ul> <li>\u23f3 WASM component system</li> <li>\u23f3 CLI tools</li> <li>\u23f3 Macro enhancements</li> </ul>"},{"location":"components/#long-term-2026","title":"Long-term (2026+)","text":"<ul> <li>Distributed actor system</li> <li>Advanced WASM capabilities</li> <li>Cloud-native features</li> </ul>"},{"location":"components/#getting-started","title":"Getting Started","text":"<p>Choose your starting point:</p> <ol> <li>New to AirsSys? Start with Getting Started</li> <li>Want secure OS ops? Go to OSL Documentation</li> <li>Need concurrency? Go to RT Documentation</li> <li>Integrating both? See Integration Guide</li> </ol>"},{"location":"components/osl/","title":"Introduction","text":"<p>Welcome to AirsSys OSL (OS Layer Framework), a secure foundation for system programming that addresses the critical challenges of modern operating system interaction.</p>"},{"location":"components/osl/#problem-statement","title":"Problem Statement","text":"<p>Modern system programming requires direct interaction with operating system primitives, but this comes with significant risks:</p> <ul> <li>Security Vulnerabilities: Direct OS calls can expose applications to security threats</li> <li>Platform Inconsistencies: Different operating systems provide different APIs and behaviors  </li> <li>Audit Trail Gaps: Most OS operations lack comprehensive logging for security monitoring</li> <li>Error-Prone Operations: Low-level system programming is susceptible to memory safety and resource management errors</li> <li>Complexity Overhead: Applications must implement security, logging, and cross-platform compatibility repeatedly</li> </ul>"},{"location":"components/osl/#solution-approach","title":"Solution Approach","text":"<p>AirsSys OSL addresses these challenges by providing a secure, cross-platform, and well-instrumented abstraction layer over operating system functionality. It enables applications to perform system-level operations safely while maintaining comprehensive audit trails and enforcing security policies.</p>"},{"location":"components/osl/#target-use-cases","title":"Target Use Cases","text":""},{"location":"components/osl/#secure-application-development","title":"Secure Application Development","text":"<ul> <li>Applications requiring file system operations with security guarantees</li> <li>Network services needing controlled access to system resources</li> <li>Process management with audit trails and security policies</li> <li>External tool integration with sandboxing and monitoring</li> </ul>"},{"location":"components/osl/#airsstack-ecosystem-integration","title":"AirsStack Ecosystem Integration","text":"<ul> <li>Foundation layer for airssys-rt actor system process management</li> <li>Security primitives for airssys-wasm component sandboxing</li> <li>Comprehensive logging for ecosystem-wide security monitoring</li> <li>Standardized resource management across all AirsStack components</li> </ul>"},{"location":"components/osl/#enterprise-system-administration","title":"Enterprise System Administration","text":"<ul> <li>Automated system management with comprehensive audit trails</li> <li>Secure script execution with policy enforcement</li> <li>Resource monitoring and management</li> <li>Integration with enterprise security and monitoring systems</li> </ul>"},{"location":"components/osl/#user-experience-goals","title":"User Experience Goals","text":""},{"location":"components/osl/#developer-experience","title":"Developer Experience","text":"<ul> <li>Simple API: Intuitive interfaces that abstract OS complexity</li> <li>Safety by Default: Secure defaults that prevent common vulnerabilities</li> <li>Comprehensive Documentation: Clear examples and usage patterns</li> <li>Excellent Error Messages: Detailed, actionable error information</li> <li>Performance Transparency: Clear understanding of performance characteristics</li> </ul>"},{"location":"components/osl/#operations-experience","title":"Operations Experience","text":"<ul> <li>Comprehensive Logging: Detailed activity logs for all system operations</li> <li>Policy Configuration: Flexible security policy configuration</li> <li>Monitoring Integration: Easy integration with existing monitoring systems</li> <li>Troubleshooting Support: Rich diagnostic information for issue resolution</li> <li>Compliance Support: Audit trails meeting enterprise compliance requirements</li> </ul>"},{"location":"components/osl/#quick-start","title":"Quick Start","text":""},{"location":"components/osl/#installation","title":"Installation","text":"<p>Add AirsSys OSL to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nairssys-osl = { version = \"0.1\", features = [\"macros\"] }\ntokio = { version = \"1.0\", features = [\"full\"] }\n</code></pre>"},{"location":"components/osl/#basic-usage-helper-functions-api-recommended","title":"Basic Usage - Helper Functions API (Recommended)","text":"<p>The helper functions API provides the easiest way to get started with AirsSys OSL:</p> <pre><code>use airssys_osl::helpers::*;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Simple file operations with built-in security\n    let data = b\"Hello, World!\".to_vec();\n    write_file(\"/tmp/test.txt\", data, \"admin\").await?;\n\n    let content = read_file(\"/tmp/test.txt\", \"admin\").await?;\n    println!(\"Read: {}\", String::from_utf8_lossy(&amp;content));\n\n    Ok(())\n}\n</code></pre>"},{"location":"components/osl/#advanced-usage-core-primitives-api","title":"Advanced Usage - Core Primitives API","text":"<p>For advanced use cases requiring custom middleware or fine-grained control:</p> <pre><code>use airssys_osl::core::{\n    context::{SecurityContext, ExecutionContext},\n    operation::OperationType,\n    executor::ExecutionResult,\n};\n\nlet security_context = SecurityContext::new(\"user123\".to_string());\nlet execution_context = ExecutionContext::new(security_context);\n\nassert_eq!(execution_context.principal(), \"user123\");\n</code></pre>"},{"location":"components/osl/#current-status","title":"Current Status","text":"<p>Phase: Core Foundation Implemented Helper Functions API: \u2705 Fully functional (10 helper functions available) Core Primitives: \u2705 Fully functional with comprehensive testing (60 tests passing) Framework API: \u23f3 Planned for OSL-TASK-006</p>"},{"location":"components/osl/#what-works-today","title":"What Works Today","text":"<ul> <li>\u2705 Core primitives: Full execution context, security context, and operation abstractions</li> <li>\u2705 Logger middleware: Complete implementation with Console, File, and Tracing loggers</li> <li>\u2705 Security middleware: ACL and RBAC implementation with audit logging  </li> <li>\u2705 Helper functions: 10 functions for filesystem, process, and network operations</li> <li>\u2705 Comprehensive testing: 60 tests covering all implemented functionality</li> </ul>"},{"location":"components/osl/#coming-soon","title":"Coming Soon","text":"<ul> <li>\ud83d\udd04 OSLFramework builder API: High-level framework with middleware orchestration (OSL-TASK-006)</li> </ul>"},{"location":"components/osl/#getting-help","title":"Getting Help","text":"<ul> <li>Repository: GitHub Repository</li> <li>Issues: Report bugs and request features on GitHub Issues</li> </ul>"},{"location":"components/osl/#license","title":"License","text":"<p>AirsSys OSL is dual-licensed under the Apache License 2.0 and MIT License.</p>"},{"location":"components/osl/api/","title":"API Reference","text":"<p>This section provides API documentation based on the documented architecture and implementation specifications.</p> <p>Note: AirsSys OSL is currently in foundation setup phase. The APIs shown represent the documented planned interfaces.</p>"},{"location":"components/osl/api/#core-modules","title":"Core Modules","text":"<p>Based on the documented core module structure:</p> <ul> <li>Core Types: Essential trait abstractions and types (<code>src/core/</code>)</li> <li>Filesystem Operations: File system operations (planned)</li> <li>Process Management: Process spawning and management (planned)</li> <li>Security Framework: Consolidated security middleware (<code>middleware/security/</code>)</li> <li>Activity Logging: Activity logging subsystem (<code>middleware/logger/</code>)</li> </ul>"},{"location":"components/osl/api/#documented-api-patterns","title":"Documented API Patterns","text":""},{"location":"components/osl/api/#generic-first-design-pattern","title":"Generic-First Design Pattern","text":"<p>Following Microsoft Rust Guidelines M-DI-HIERARCHY:</p> <pre><code>// \u2705 DOCUMENTED: Generic constraints pattern\npub trait OSExecutor&lt;O&gt;: Debug + Send + Sync + 'static \nwhere O: Operation\n{\n    async fn execute(&amp;self, operation: O, context: &amp;ExecutionContext) -&gt; OSResult&lt;ExecutionResult&gt;;\n}\n\n// \u274c AVOIDED: dyn patterns\n// pub trait OSExecutor {\n//     async fn execute(&amp;self, operation: &amp;dyn Operation) -&gt; OSResult&lt;ExecutionResult&gt;;\n// }\n</code></pre>"},{"location":"components/osl/api/#error-handling","title":"Error Handling","text":"<p>Following Microsoft Guidelines M-ERRORS-CANONICAL-STRUCTS:</p> <pre><code>#[derive(Error, Debug)]\npub enum OSError {\n    #[error(\"Security policy violation: {reason}\")]\n    SecurityViolation { reason: String },\n\n    #[error(\"Middleware failed: {middleware}: {reason}\")]\n    MiddlewareFailed { middleware: String, reason: String },\n\n    #[error(\"Filesystem operation failed: {operation} on {path}: {source}\")]\n    FilesystemError {\n        operation: String,\n        path: std::path::PathBuf,\n        #[source]\n        source: std::io::Error,\n    },\n}\n\n// Contextual helper methods\nimpl OSError {\n    pub fn is_security_violation(&amp;self) -&gt; bool;\n    pub fn is_filesystem_error(&amp;self) -&gt; bool;\n}\n</code></pre>"},{"location":"components/osl/api/#async-operations","title":"Async Operations","text":"<p>Based on tech context documentation:</p> <pre><code>use tokio; // Primary async runtime\nuse chrono::{DateTime, Utc}; // Workspace standard \u00a73.2\n\n#[tokio::main]\nasync fn main() -&gt; OSResult&lt;()&gt; {\n    // Async-first design pattern\n    // Implementation pending completion of core foundation\n    Ok(())\n}\n</code></pre>"},{"location":"components/osl/api/#security-context-integration","title":"Security Context Integration","text":"<p>Based on documented security-consolidated architecture:</p> <pre><code>// Security handled within middleware/security/\n// No separate SecurityPolicy trait - integrated into SecurityMiddleware\n// Security middleware processes all operations before execution\n</code></pre>"},{"location":"components/osl/api/#implementation-status","title":"Implementation Status","text":"<p>Current Phase: Core module foundation (OSL-TASK-001) implementation Priority: Essential trait abstractions in <code>src/core/</code> Next: Security and logging middleware implementation</p> <p>For detailed API specifications, see the individual module sections. APIs will be updated as implementation progresses following the documented architecture.</p>"},{"location":"components/osl/api/core-types/","title":"Core Types","text":"<p>This section documents the core trait abstractions and types in AirsSys OSL.</p>"},{"location":"components/osl/api/core-types/#current-status","title":"Current Status","text":"<p>Implementation Phase: \u2705 Implemented Module Location: <code>src/core/</code> RustDoc: Run <code>cargo doc --open</code> in <code>airssys-osl</code> for complete API documentation</p>"},{"location":"components/osl/api/core-types/#overview","title":"Overview","text":"<p>The core module provides the foundational abstractions for the OSL framework:</p> <ul> <li>Operation Trait: Core Operation trait defining operations that can be executed</li> <li>OSExecutor Trait: Generic-based executor interface for running operations  </li> <li>Middleware Trait: Core middleware abstraction for operation interception</li> <li>Context Types: Execution contexts and security context for operation metadata</li> <li>Error Types: Structured error types following canonical error patterns</li> </ul>"},{"location":"components/osl/api/core-types/#generic-first-pattern","title":"Generic-First Pattern","text":"<p>The core types follow a generic-first design pattern to enable zero-cost abstractions:</p> <pre><code>pub trait OSExecutor&lt;O&gt;: Debug + Send + Sync + 'static \nwhere O: Operation\n{\n    async fn execute(&amp;self, operation: O, context: &amp;ExecutionContext) -&gt; OSResult&lt;ExecutionResult&gt;;\n}\n</code></pre>"},{"location":"components/osl/api/core-types/#key-traits","title":"Key Traits","text":""},{"location":"components/osl/api/core-types/#operation-trait","title":"Operation Trait","text":"<p>Defines the interface for operations that can be executed:</p> <pre><code>pub trait Operation: Debug + Send + Sync + 'static {\n    fn operation_type(&amp;self) -&gt; OperationType;\n    fn requires_privilege(&amp;self) -&gt; bool;\n}\n</code></pre>"},{"location":"components/osl/api/core-types/#osexecutor-trait","title":"OSExecutor Trait","text":"<p>Generic executor interface:</p> <pre><code>pub trait OSExecutor&lt;O: Operation&gt;: Debug + Send + Sync + 'static {\n    async fn execute(&amp;self, operation: O, context: &amp;ExecutionContext) \n        -&gt; OSResult&lt;ExecutionResult&gt;;\n}\n</code></pre>"},{"location":"components/osl/api/core-types/#middleware-trait","title":"Middleware Trait","text":"<p>Operation interception interface:</p> <pre><code>#[async_trait]\npub trait Middleware&lt;O: Operation&gt;: Send + Sync {\n    fn name(&amp;self) -&gt; &amp;str;\n    fn priority(&amp;self) -&gt; u32;\n\n    async fn before_execution(&amp;self, operation: O, context: &amp;ExecutionContext) \n        -&gt; MiddlewareResult&lt;Option&lt;O&gt;&gt;;\n\n    async fn after_execution(&amp;self, operation: &amp;O, result: ExecutionResult, context: &amp;ExecutionContext) \n        -&gt; MiddlewareResult&lt;ExecutionResult&gt;;\n}\n</code></pre>"},{"location":"components/osl/api/core-types/#context-types","title":"Context Types","text":""},{"location":"components/osl/api/core-types/#executioncontext","title":"ExecutionContext","text":"<p>Contains metadata for operation execution:</p> <pre><code>pub struct ExecutionContext {\n    security: SecurityContext,\n    metadata: HashMap&lt;String, String&gt;,\n    // ... additional fields\n}\n</code></pre>"},{"location":"components/osl/api/core-types/#securitycontext","title":"SecurityContext","text":"<p>Encapsulates security information:</p> <pre><code>pub struct SecurityContext {\n    principal: String,\n    roles: Vec&lt;String&gt;,\n    permissions: Vec&lt;String&gt;,\n}\n</code></pre>"},{"location":"components/osl/api/core-types/#error-types","title":"Error Types","text":"<p>Structured error handling with <code>OSError</code> and <code>OSResult&lt;T&gt;</code>:</p> <pre><code>pub type OSResult&lt;T&gt; = Result&lt;T, OSError&gt;;\n\npub enum OSError {\n    PermissionDenied { operation: String, principal: String },\n    NotFound { resource: String },\n    ExecutionFailed { details: String },\n    // ... other variants\n}\n</code></pre> <p>For complete API documentation with all methods and examples, see the generated RustDoc (<code>cargo doc --open</code>).</p>"},{"location":"components/osl/api/filesystem/","title":"Filesystem Operations","text":""},{"location":"components/osl/api/logging/","title":"Activity Logging","text":""},{"location":"components/osl/api/macros/","title":"Macros API Reference","text":"<p>This page provides the API reference for procedural macros available in the <code>airssys-osl-macros</code> crate.</p>"},{"location":"components/osl/api/macros/#overview","title":"Overview","text":"<p>The <code>airssys-osl-macros</code> crate provides procedural macros that simplify the development of custom OS executors by automatically generating boilerplate implementation code.</p>"},{"location":"components/osl/api/macros/#feature-flag","title":"Feature Flag","text":"<p>To use macros in your project, enable the <code>macros</code> feature:</p> <pre><code>[dependencies]\nairssys-osl = { version = \"0.1\", features = [\"macros\"] }\n</code></pre>"},{"location":"components/osl/api/macros/#available-macros","title":"Available Macros","text":""},{"location":"components/osl/api/macros/#executor","title":"<code>#[executor]</code>","text":"<p>The <code>#[executor]</code> attribute macro automatically implements the <code>OSExecutor</code> trait for custom executor types.</p>"},{"location":"components/osl/api/macros/#basic-usage","title":"Basic Usage","text":"<pre><code>use airssys_osl::prelude::*;\n\n#[executor]\nstruct MyExecutor;\n</code></pre> <p>This generates implementations for all 11 supported operations across 3 operation domains.</p>"},{"location":"components/osl/api/macros/#syntax","title":"Syntax","text":"<pre><code>#[executor]\n#[executor(name = \"CustomName\")]\n#[executor(operations = [Domain1, Domain2])]\n#[executor(name = \"CustomName\", operations = [Domain1, Domain2])]\n</code></pre>"},{"location":"components/osl/api/macros/#attributes","title":"Attributes","text":"Attribute Type Required Description <code>name</code> String literal No Custom executor name for logging/debugging <code>operations</code> Array of operation domains No Limit to specific operation domains"},{"location":"components/osl/api/macros/#operation-domains","title":"Operation Domains","text":"<p>The macro supports these operation domains:</p> Domain Operations Count <code>Filesystem</code> <code>FileRead</code>, <code>FileWrite</code>, <code>FileDelete</code>, <code>DirectoryCreate</code>, <code>DirectoryList</code> 5 <code>Process</code> <code>ProcessSpawn</code>, <code>ProcessKill</code>, <code>ProcessSignal</code> 3 <code>Network</code> <code>NetworkConnect</code>, <code>NetworkListen</code>, <code>NetworkSocket</code> 3 <p>Total: 11 operations across 3 domains</p>"},{"location":"components/osl/api/macros/#method-signature-requirements","title":"Method Signature Requirements","text":"<p>For each operation you want to handle, implement a method with this exact signature:</p> <pre><code>async fn {operation_name}(\n    &amp;self,\n    operation: {OperationType},\n    context: &amp;ExecutionContext,\n) -&gt; OSResult&lt;ExecutionResult&gt;\n</code></pre> <p>Requirements: - Method must be <code>async</code> - Method name must match the operation name (e.g., <code>file_read</code>, not <code>execute_file_read</code>) - First parameter must be named <code>operation</code> - Second parameter must be named <code>context</code> and type <code>&amp;ExecutionContext</code> - Return type must be <code>OSResult&lt;ExecutionResult&gt;</code></p>"},{"location":"components/osl/api/macros/#operation-method-mapping","title":"Operation Method Mapping","text":"Operation Domain Method Name Operation Type Filesystem File Read <code>file_read</code> <code>FileReadOperation</code> File Write <code>file_write</code> <code>FileWriteOperation</code> File Delete <code>file_delete</code> <code>FileDeleteOperation</code> Directory Create <code>directory_create</code> <code>DirectoryCreateOperation</code> Directory List <code>directory_list</code> <code>DirectoryListOperation</code> Process Process Spawn <code>process_spawn</code> <code>ProcessSpawnOperation</code> Process Kill <code>process_kill</code> <code>ProcessKillOperation</code> Process Signal <code>process_signal</code> <code>ProcessSignalOperation</code> Network Network Connect <code>network_connect</code> <code>NetworkConnectOperation</code> Network Listen <code>network_listen</code> <code>NetworkListenOperation</code> Network Socket <code>network_socket</code> <code>NetworkSocketOperation</code>"},{"location":"components/osl/api/macros/#examples","title":"Examples","text":""},{"location":"components/osl/api/macros/#single-domain-executor","title":"Single Domain Executor","text":"<pre><code>use airssys_osl::prelude::*;\n\n#[executor(operations = [Filesystem])]\nstruct FileSystemExecutor;\n\nimpl FileSystemExecutor {\n    async fn file_read(\n        &amp;self,\n        operation: FileReadOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Custom implementation\n        Ok(ExecutionResult::success(vec![]))\n    }\n\n    async fn file_write(\n        &amp;self,\n        operation: FileWriteOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Custom implementation\n        Ok(ExecutionResult::success(vec![]))\n    }\n}\n</code></pre>"},{"location":"components/osl/api/macros/#multi-domain-executor","title":"Multi-Domain Executor","text":"<pre><code>use airssys_osl::prelude::*;\n\n#[executor(\n    name = \"MultiDomainExecutor\",\n    operations = [Filesystem, Process, Network]\n)]\nstruct MyExecutor;\n\nimpl MyExecutor {\n    // Implement required methods for Filesystem operations\n    async fn file_read(\n        &amp;self,\n        operation: FileReadOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Implementation\n        Ok(ExecutionResult::success(vec![]))\n    }\n\n    // Implement required methods for Process operations\n    async fn process_spawn(\n        &amp;self,\n        operation: ProcessSpawnOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Implementation\n        Ok(ExecutionResult::success(vec![]))\n    }\n\n    // Implement required methods for Network operations\n    async fn network_connect(\n        &amp;self,\n        operation: NetworkConnectOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Implementation\n        Ok(ExecutionResult::success(vec![]))\n    }\n\n    // ... other required methods\n}\n</code></pre>"},{"location":"components/osl/api/macros/#executor-with-helper-methods","title":"Executor with Helper Methods","text":"<pre><code>use airssys_osl::prelude::*;\nuse std::collections::HashMap;\n\n#[executor(operations = [Filesystem])]\nstruct CachedExecutor {\n    cache: HashMap&lt;String, Vec&lt;u8&gt;&gt;,\n}\n\nimpl CachedExecutor {\n    // Helper methods are preserved\n    pub fn new() -&gt; Self {\n        Self {\n            cache: HashMap::new(),\n        }\n    }\n\n    fn get_from_cache(&amp;self, path: &amp;str) -&gt; Option&lt;&amp;Vec&lt;u8&gt;&gt; {\n        self.cache.get(path)\n    }\n\n    async fn file_read(\n        &amp;self,\n        operation: FileReadOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Use helper method\n        if let Some(cached) = self.get_from_cache(&amp;operation.path) {\n            return Ok(ExecutionResult::success(cached.clone()));\n        }\n        // ... fallback logic\n        Ok(ExecutionResult::success(vec![]))\n    }\n}\n</code></pre>"},{"location":"components/osl/api/macros/#error-messages","title":"Error Messages","text":"<p>The macro provides helpful error messages for common mistakes:</p>"},{"location":"components/osl/api/macros/#missing-method-implementation","title":"Missing Method Implementation","text":"<pre><code>error: No operation methods found\n  --&gt; src/lib.rs:5:1\n   |\n5  | #[executor]\n   | ^^^^^^^^^^^\n   |\n   = note: Expected methods named: file_read, file_write, file_delete, \n           directory_create, directory_list, process_spawn, process_kill, \n           process_signal, network_connect, network_listen, network_socket\n</code></pre>"},{"location":"components/osl/api/macros/#invalid-method-signature","title":"Invalid Method Signature","text":"<pre><code>error: First parameter must be named 'operation', found 'op'\n  --&gt; src/lib.rs:10:5\n   |\n10 |     async fn file_read(&amp;self, op: FileReadOperation, context: &amp;ExecutionContext) {\n   |                               ^^\n   |\n   = help: Parameter names must be exactly 'operation' and 'context'\n</code></pre>"},{"location":"components/osl/api/macros/#invalid-operations-attribute","title":"Invalid Operations Attribute","text":"<pre><code>error: Unknown operation type 'InvalidDomain'\n  --&gt; src/lib.rs:3:11\n   |\n3  | #[executor(operations = [InvalidDomain])]\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: Valid domains: Filesystem, Process, Network\n   = help: Example: #[executor(operations = [Filesystem, Process])]\n</code></pre>"},{"location":"components/osl/api/macros/#generated-code","title":"Generated Code","text":"<p>The <code>#[executor]</code> macro generates:</p> <ol> <li>OSExecutor trait implementations for each specified operation</li> <li>Type-safe delegations to user-defined methods</li> <li>Error context enrichment with operation metadata</li> <li>Debug implementations for better diagnostics</li> </ol>"},{"location":"components/osl/api/macros/#example-generated-code","title":"Example Generated Code","text":"<p>For this input:</p> <pre><code>#[executor(operations = [Filesystem])]\nstruct MyExecutor;\n\nimpl MyExecutor {\n    async fn file_read(\n        &amp;self,\n        operation: FileReadOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        Ok(ExecutionResult::success(vec![]))\n    }\n}\n</code></pre> <p>The macro generates (simplified):</p> <pre><code>#[automatically_derived]\n#[async_trait::async_trait]\nimpl airssys_osl::core::executor::OSExecutor&lt;FileReadOperation&gt; for MyExecutor {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"MyExecutor\"\n    }\n\n    fn supported_operation_types(&amp;self) -&gt; Vec&lt;OperationType&gt; {\n        vec![OperationType::Filesystem]\n    }\n\n    async fn execute(\n        &amp;self,\n        operation: FileReadOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        self.file_read(operation, context).await\n    }\n}\n\n// Similar implementations for other operations...\n</code></pre>"},{"location":"components/osl/api/macros/#best-practices","title":"Best Practices","text":""},{"location":"components/osl/api/macros/#1-start-with-single-domain","title":"1. Start with Single Domain","text":"<p>Begin with one operation domain and expand as needed:</p> <pre><code>#[executor(operations = [Filesystem])]\nstruct MyExecutor;\n</code></pre>"},{"location":"components/osl/api/macros/#2-use-custom-names-for-debugging","title":"2. Use Custom Names for Debugging","text":"<p>Provide descriptive names for logging:</p> <pre><code>#[executor(name = \"EncryptedFileSystemExecutor\")]\nstruct MyExecutor;\n</code></pre>"},{"location":"components/osl/api/macros/#3-preserve-state-with-structs","title":"3. Preserve State with Structs","text":"<p>Use struct fields for stateful executors:</p> <pre><code>#[executor(operations = [Filesystem])]\nstruct StatefulExecutor {\n    config: Config,\n    cache: Cache,\n}\n</code></pre>"},{"location":"components/osl/api/macros/#4-implement-helper-methods","title":"4. Implement Helper Methods","text":"<p>Extract common logic into helper methods:</p> <pre><code>impl MyExecutor {\n    fn validate_path(&amp;self, path: &amp;str) -&gt; OSResult&lt;()&gt; {\n        // Validation logic\n        Ok(())\n    }\n\n    async fn file_read(&amp;self, operation: FileReadOperation, context: &amp;ExecutionContext) -&gt; OSResult&lt;ExecutionResult&gt; {\n        self.validate_path(&amp;operation.path)?;\n        // Implementation\n        Ok(ExecutionResult::success(vec![]))\n    }\n}\n</code></pre>"},{"location":"components/osl/api/macros/#5-use-type-annotations-for-multi-domain","title":"5. Use Type Annotations for Multi-Domain","text":"<p>When implementing multiple domains, use explicit type annotations to avoid ambiguity:</p> <pre><code>let result = &lt;MyExecutor as OSExecutor&lt;FileReadOperation&gt;&gt;::execute(\n    &amp;executor,\n    operation,\n    context\n).await?;\n</code></pre>"},{"location":"components/osl/api/macros/#see-also","title":"See Also","text":"<ul> <li>Custom Executor Guide - Comprehensive guide with examples</li> <li>Core Types - Operation and result types reference</li> <li>Examples - Full working examples</li> </ul>"},{"location":"components/osl/api/macros/#crate-documentation","title":"Crate Documentation","text":"<p>For detailed crate-level documentation, see: - airssys-osl-macros on docs.rs - Source code: <code>airssys-osl-macros/src/lib.rs</code></p>"},{"location":"components/osl/api/process/","title":"Process Management","text":""},{"location":"components/osl/api/security/","title":"Security Framework","text":"<p>This section documents the consolidated security middleware in AirsSys OSL.</p>"},{"location":"components/osl/api/security/#current-status","title":"Current Status","text":"<p>Implementation Phase: \u2705 Implemented Module Location: <code>middleware/security/</code> (consolidated approach) RustDoc: Run <code>cargo doc --open</code> in <code>airssys-osl</code> for complete API documentation</p> <p>The security middleware provides comprehensive security controls through a consolidated architecture.</p>"},{"location":"components/osl/api/security/#security-integration-pattern","title":"Security Integration Pattern","text":"<p>All security concerns are handled within the security middleware: - No separate <code>SecurityPolicy</code> trait - integrated into <code>SecurityMiddleware</code> - Security middleware processes all operations before execution - Unified security decision-making point</p>"},{"location":"components/osl/api/security/#module-structure","title":"Module Structure","text":"<pre><code>middleware/security/\n\u251c\u2500\u2500 mod.rs          # Security middleware exports and orchestration\n\u251c\u2500\u2500 policy.rs       # Policy evaluation\n\u251c\u2500\u2500 acl.rs          # Access Control Lists implementation\n\u251c\u2500\u2500 rbac.rs         # Role-Based Access Control implementation\n\u251c\u2500\u2500 middleware.rs   # Core security middleware implementation\n\u2514\u2500\u2500 audit.rs        # Security audit logging\n</code></pre>"},{"location":"components/osl/api/security/#security-middleware","title":"Security Middleware","text":"<p>The main security middleware implementation:</p> <pre><code>use airssys_osl::middleware::security::SecurityMiddleware;\n\n// Create ACL-based security\nlet acl_security = SecurityMiddleware::with_acl(acl_policy);\n\n// Create RBAC-based security\nlet rbac_security = SecurityMiddleware::with_rbac(rbac_policy);\n\n// Use with executor\nlet executor = FilesystemExecutor::new()\n    .with_middleware(acl_security);\n</code></pre>"},{"location":"components/osl/api/security/#access-control-lists-acl","title":"Access Control Lists (ACL)","text":"<p>Fine-grained permission management:</p> <pre><code>use airssys_osl::middleware::security::acl::{AclPolicy, Permission};\n\nlet mut acl = AclPolicy::new();\nacl.grant_permission(\"user1\", \"/data\", Permission::Read);\nacl.grant_permission(\"admin\", \"/data\", Permission::ReadWrite);\n</code></pre>"},{"location":"components/osl/api/security/#role-based-access-control-rbac","title":"Role-Based Access Control (RBAC)","text":"<p>Role-based permission management:</p> <pre><code>use airssys_osl::middleware::security::rbac::{RbacPolicy, Role};\n\nlet mut rbac = RbacPolicy::new();\nrbac.assign_role(\"user1\", Role::Reader);\nrbac.assign_role(\"admin\", Role::Administrator);\n</code></pre>"},{"location":"components/osl/api/security/#security-audit","title":"Security Audit","text":"<p>Comprehensive audit logging:</p> <pre><code>use airssys_osl::middleware::security::audit::AuditLogger;\n\nlet audit = AuditLogger::new();\n// All security decisions are automatically logged\n</code></pre>"},{"location":"components/osl/api/security/#security-principles","title":"Security Principles","text":"<p>The implementation follows these principles: - Deny by default: All operations require explicit permission - Comprehensive auditing: All system operations logged - Policy enforcement: Runtime security policy validation - Threat detection: Built-in detection of suspicious activities</p>"},{"location":"components/osl/api/security/#examples","title":"Examples","text":"<p>See the security examples: - <code>examples/security_acl.rs</code> - ACL-based security - <code>examples/security_rbac.rs</code> - RBAC-based security - Security guide: Security Setup Guide</p> <p>For complete API documentation with all methods and configuration options, see the generated RustDoc (<code>cargo doc --open</code>).</p>"},{"location":"components/osl/architecture/","title":"Architecture Overview","text":"<p>This section provides the documented architecture overview for AirsSys OSL based on the established memory bank documentation and architectural decisions.</p>"},{"location":"components/osl/architecture/#layered-architecture","title":"Layered Architecture","text":"<p>AirsSys OSL follows a layered architecture pattern with clear separation of concerns:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502           Application Layer             \u2502 \u2190 Client Applications\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502           API Abstraction Layer         \u2502 \u2190 High-level APIs\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         Security &amp; Policy Layer         \u2502 \u2190 Security enforcement\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         Activity Logging Layer          \u2502 \u2190 Comprehensive logging\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502          Platform Abstraction           \u2502 \u2190 OS-specific implementations\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502          Operating System               \u2502 \u2190 Linux, macOS, Windows\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"components/osl/architecture/#core-module-structure","title":"Core Module Structure","text":"<p>Based on the documented architecture, the system is organized in priority-based modules:</p> <pre><code>src/\n\u251c\u2500\u2500 core/           # PRIORITY 1: Essential trait abstractions only\n\u2502   \u251c\u2500\u2500 operation.rs    # Core Operation trait and basic types\n\u2502   \u251c\u2500\u2500 executor.rs     # Core OSExecutor trait (simplified)\n\u2502   \u251c\u2500\u2500 middleware.rs   # Core Middleware trait\n\u2502   \u251c\u2500\u2500 context.rs      # Execution contexts\n\u2502   \u2514\u2500\u2500 result.rs       # Core result and error types\n\u251c\u2500\u2500 middleware/     # PRIORITY 2: Standalone middleware modules\n\u2502   \u251c\u2500\u2500 logger/         # Activity logging subsystem\n\u2502   \u2514\u2500\u2500 security/       # Security validation subsystem (consolidated)\n\u251c\u2500\u2500 api/           # PRIORITY 3: High-level user APIs\n\u251c\u2500\u2500 executor/      # PRIORITY 3: OS-specific implementations\n\u2514\u2500\u2500 config/        # PRIORITY 4: Configuration management\n</code></pre>"},{"location":"components/osl/architecture/#design-principles","title":"Design Principles","text":""},{"location":"components/osl/architecture/#generic-first-design-pattern","title":"Generic-First Design Pattern","text":"<p>Following Microsoft Rust Guidelines M-DI-HIERARCHY and workspace standard \u00a76.2:</p> <p>Hierarchy of Abstraction: 1. Concrete types - Use specific implementations when behavior is fixed 2. Generic constraints - Use <code>impl Trait</code> or <code>&lt;T: Trait&gt;</code> for flexibility 3. <code>dyn</code> traits - Only when generics cause excessive nesting (last resort)</p>"},{"location":"components/osl/architecture/#security-first-approach","title":"Security-First Approach","text":"<p>All system operations are designed with security as the primary concern: - Deny-by-default access control - Comprehensive audit logging integrated into security middleware - Input validation at all boundaries - Consolidated security concerns within <code>middleware/security/</code></p>"},{"location":"components/osl/architecture/#cross-platform-consistency","title":"Cross-Platform Consistency","text":"<p>Platform abstraction provides unified APIs across: - Linux: Primary platform with full feature support - macOS: Secondary platform with feature parity - Windows: Tertiary platform with core functionality</p>"},{"location":"components/osl/architecture/#performance-targets","title":"Performance Targets","text":"<p>Based on documented requirements: - File Operations: &lt;1ms latency for basic operations - Process Spawning: &lt;10ms for simple process creation - Memory Usage: Bounded memory growth under load</p>"},{"location":"components/osl/architecture/#architecture-status","title":"Architecture Status","text":"<p>Current Phase: Foundation Setup and Architecture Design Implementation Status: Core module foundation (OSL-TASK-001) ready for implementation</p> <p>The architecture documentation reflects the established memory bank specifications and will be updated as implementation progresses.</p>"},{"location":"components/osl/architecture/core-framework/","title":"Core Framework","text":""},{"location":"components/osl/architecture/platform-abstractions/","title":"Platform Abstractions","text":""},{"location":"components/osl/architecture/security-model/","title":"Security Model","text":""},{"location":"components/osl/guides/","title":"User Guides","text":"<p>This section provides guidance for working with AirsSys OSL based on the documented architecture and current development status.</p> <p>Note: AirsSys OSL is currently in foundation setup phase. These guides represent the planned approach based on the documented specifications.</p>"},{"location":"components/osl/guides/#available-guides","title":"Available Guides","text":"<ul> <li>Getting Started: Installation, setup, and development environment</li> <li>Configuration: Configuration management (implementation planned)</li> <li>Security Setup: Security middleware configuration (implementation planned)</li> <li>Logging Configuration: Activity logging configuration (implementation planned)</li> <li>Testing Guide: Testing strategies for OSL-based applications</li> </ul>"},{"location":"components/osl/guides/#current-development-status","title":"Current Development Status","text":"<p>Phase: Foundation Setup and Architecture Design Active Task: Core Module Foundation (OSL-TASK-001)</p>"},{"location":"components/osl/guides/#architecture-implementation-progress","title":"Architecture Implementation Progress","text":"<ol> <li>Core Module (<code>src/core/</code>) - Ready for implementation</li> <li>Essential trait abstractions only</li> <li>Generic-first design pattern</li> <li> <p>Following workspace standards \u00a72.1-\u00a76.3</p> </li> <li> <p>Middleware Modules - Planned next phase</p> </li> <li>Security middleware (consolidated approach)</li> <li>Activity logging middleware</li> <li> <p>Standalone middleware modules</p> </li> <li> <p>API Layer - Future implementation</p> </li> <li>High-level user APIs</li> <li>Platform-specific implementations</li> </ol>"},{"location":"components/osl/guides/#documented-patterns","title":"Documented Patterns","text":""},{"location":"components/osl/guides/#security-first-approach","title":"Security-First Approach","text":"<p>Based on documented security requirements: - Deny-by-default access control - Comprehensive audit logging - All security concerns consolidated in <code>middleware/security/</code> - Security middleware processes all operations before execution</p>"},{"location":"components/osl/guides/#technology-stack","title":"Technology Stack","text":"<p>Based on tech context documentation: - Rust 2021 Edition with MSRV 1.75+ - Tokio async runtime with full features - Tracing for structured logging - Chrono for all time operations (workspace standard \u00a73.2)</p>"},{"location":"components/osl/guides/#cross-platform-support","title":"Cross-Platform Support","text":"<p>Platform priority based on documentation: - Linux: Primary platform with full feature support - macOS: Secondary platform with feature parity - Windows: Tertiary platform with core functionality</p>"},{"location":"components/osl/guides/#getting-started-with-development","title":"Getting Started with Development","text":"<p>For contributors interested in the current development phase:</p> <ol> <li>Review Memory Bank: Read <code>.copilot/memory_bank/sub_projects/airssys-osl/</code></li> <li>Check Current Task: Review OSL-TASK-001 implementation specifications</li> <li>Follow Standards: Adhere to workspace standards \u00a72.1-\u00a76.3</li> <li>Contribute: Follow the documented architecture and task priorities</li> </ol> <p>Each guide will be expanded as the implementation progresses following the established architectural documentation.</p>"},{"location":"components/osl/guides/configuration/","title":"Configuration","text":""},{"location":"components/osl/guides/custom-executors/","title":"Custom Executors","text":"<p>This guide explains how to create custom executors for airssys-osl using the <code>#[executor]</code> macro.</p>"},{"location":"components/osl/guides/custom-executors/#table-of-contents","title":"Table of Contents","text":"<ul> <li>The Problem: Boilerplate Code</li> <li>The Solution: #[executor] Macro</li> <li>Basic Usage</li> <li>Method Signature Requirements</li> <li>Custom Configuration</li> <li>Supported Operations</li> <li>Advanced Features</li> </ul>"},{"location":"components/osl/guides/custom-executors/#the-problem-boilerplate-code","title":"The Problem: Boilerplate Code","text":"<p>Without the <code>#[executor]</code> macro, implementing a custom executor requires significant boilerplate:</p> <pre><code>use airssys_osl::prelude::*;\nuse async_trait::async_trait;\n\nstruct MyExecutor;\n\n// Manual trait implementation for EACH operation type\n#[async_trait]\nimpl OSExecutor&lt;FileReadOperation&gt; for MyExecutor {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"MyExecutor\"\n    }\n\n    fn supported_operation_types(&amp;self) -&gt; Vec&lt;OperationType&gt; {\n        vec![OperationType::Filesystem]\n    }\n\n    async fn execute(\n        &amp;self,\n        operation: FileReadOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Your implementation\n        todo!()\n    }\n}\n\n// Repeat for FileWriteOperation, FileDeleteOperation, etc.\n// Each operation requires ~20 lines of boilerplate!\n</code></pre> <p>This can result in 100+ lines of repetitive code for a multi-operation executor.</p>"},{"location":"components/osl/guides/custom-executors/#the-solution-executor-macro","title":"The Solution: #[executor] Macro","text":"<p>The <code>#[executor]</code> macro automatically generates all trait implementations by detecting operation methods based on their signatures:</p> <pre><code>use airssys_osl::prelude::*;\n\n#[derive(Debug)]\nstruct MyExecutor;\n\n#[executor]\nimpl MyExecutor {\n    async fn file_read(\n        &amp;self,\n        operation: FileReadOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Your implementation\n        todo!()\n    }\n\n    async fn file_write(\n        &amp;self,\n        operation: FileWriteOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Your implementation\n        todo!()\n    }\n}\n</code></pre> <p>Result: ~85% code reduction with full compile-time safety!</p>"},{"location":"components/osl/guides/custom-executors/#basic-usage","title":"Basic Usage","text":""},{"location":"components/osl/guides/custom-executors/#single-operation-executor","title":"Single Operation Executor","text":"<p>The simplest use case - an executor that handles one type of operation:</p> <pre><code>use airssys_osl::prelude::*;\n\n#[derive(Debug)]\nstruct SimpleFileReader;\n\n#[executor]\nimpl SimpleFileReader {\n    async fn file_read(\n        &amp;self,\n        operation: FileReadOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Read the file\n        let content = std::fs::read(&amp;operation.path)\n            .map_err(|e| OSError::io_error(format!(\"Failed to read file: {}\", e)))?;\n\n        Ok(ExecutionResult::success(content))\n    }\n}\n</code></pre>"},{"location":"components/osl/guides/custom-executors/#multiple-operations-executor","title":"Multiple Operations Executor","text":"<p>Handle multiple operations in the same executor:</p> <pre><code>#[derive(Debug)]\nstruct FilesystemExecutor;\n\n#[executor]\nimpl FilesystemExecutor {\n    async fn file_read(\n        &amp;self,\n        operation: FileReadOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Implementation\n        todo!()\n    }\n\n    async fn file_write(\n        &amp;self,\n        operation: FileWriteOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Implementation\n        todo!()\n    }\n\n    async fn file_delete(\n        &amp;self,\n        operation: FileDeleteOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Implementation\n        todo!()\n    }\n}\n</code></pre> <p>The macro generates 3 separate trait implementations automatically!</p>"},{"location":"components/osl/guides/custom-executors/#method-signature-requirements","title":"Method Signature Requirements","text":"<p>For the macro to detect operation methods, they must follow strict signature rules:</p>"},{"location":"components/osl/guides/custom-executors/#required-elements","title":"Required Elements","text":"<ol> <li> <p><code>async</code> keyword: Method must be async    <pre><code>async fn file_read(...)  // \u2705 Correct\nfn file_read(...)        // \u274c Error: must be async\n</code></pre></p> </li> <li> <p><code>&amp;self</code> receiver: Must use shared reference    <pre><code>async fn file_read(&amp;self, ...)      // \u2705 Correct\nasync fn file_read(&amp;mut self, ...)  // \u274c Error: cannot mutate\nasync fn file_read(self, ...)       // \u274c Error: must be reference\n</code></pre></p> </li> <li> <p>Exactly 2 parameters with exact names:    <pre><code>async fn file_read(\n    &amp;self,\n    operation: FileReadOperation,  // \u2705 Must be named 'operation'\n    context: &amp;ExecutionContext,    // \u2705 Must be named 'context'\n) -&gt; OSResult&lt;ExecutionResult&gt;\n</code></pre></p> </li> <li> <p>Return type: Must be <code>OSResult&lt;ExecutionResult&gt;</code> <pre><code>-&gt; OSResult&lt;ExecutionResult&gt;  // \u2705 Correct\n-&gt; Result&lt;...&gt;                // \u274c Error: wrong return type\n</code></pre></p> </li> </ol>"},{"location":"components/osl/guides/custom-executors/#operation-method-names","title":"Operation Method Names","text":"<p>The macro recognizes these operation method names:</p> <p>Filesystem Operations (5): - <code>file_read</code> \u2192 <code>FileReadOperation</code> - <code>file_write</code> \u2192 <code>FileWriteOperation</code> - <code>file_delete</code> \u2192 <code>FileDeleteOperation</code> - <code>directory_create</code> \u2192 <code>DirectoryCreateOperation</code> - <code>directory_list</code> \u2192 <code>DirectoryListOperation</code></p> <p>Process Operations (3): - <code>process_spawn</code> \u2192 <code>ProcessSpawnOperation</code> - <code>process_kill</code> \u2192 <code>ProcessKillOperation</code> - <code>process_signal</code> \u2192 <code>ProcessSignalOperation</code></p> <p>Network Operations (3): - <code>network_connect</code> \u2192 <code>NetworkConnectOperation</code> - <code>network_listen</code> \u2192 <code>NetworkListenOperation</code> - <code>network_socket</code> \u2192 <code>NetworkSocketOperation</code></p>"},{"location":"components/osl/guides/custom-executors/#custom-configuration","title":"Custom Configuration","text":"<p>The macro supports custom configuration via attributes:</p>"},{"location":"components/osl/guides/custom-executors/#custom-executor-name","title":"Custom Executor Name","text":"<p>Override the auto-detected executor name:</p> <pre><code>#[derive(Debug)]\nstruct MyExecutor;\n\n#[executor(name = \"AdvancedFileSystem\")]\nimpl MyExecutor {\n    async fn file_read(\n        &amp;self,\n        operation: FileReadOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        todo!()\n    }\n}\n\n// executor.name() returns \"AdvancedFileSystem\" instead of \"MyExecutor\"\n</code></pre>"},{"location":"components/osl/guides/custom-executors/#custom-operation-types","title":"Custom Operation Types","text":"<p>Explicitly specify which operation types the executor supports:</p> <pre><code>#[executor(operations = [Filesystem, Process])]\nimpl MyExecutor {\n    async fn file_read(...) { }\n    async fn process_spawn(...) { }\n}\n</code></pre> <p>Valid operation types: <code>Filesystem</code>, <code>Process</code>, <code>Network</code></p>"},{"location":"components/osl/guides/custom-executors/#combined-configuration","title":"Combined Configuration","text":"<p>Use both <code>name</code> and <code>operations</code> together:</p> <pre><code>#[executor(name = \"CustomExecutor\", operations = [Filesystem])]\nimpl MyExecutor {\n    async fn file_read(...) { }\n}\n</code></pre>"},{"location":"components/osl/guides/custom-executors/#supported-operations","title":"Supported Operations","text":"<p>The macro currently supports 11 operations across 3 domains:</p> Domain Operations Count Filesystem file_read, file_write, file_delete, directory_create, directory_list 5 Process process_spawn, process_kill, process_signal 3 Network network_connect, network_listen, network_socket 3 Total 11"},{"location":"components/osl/guides/custom-executors/#cross-domain-executors","title":"Cross-Domain Executors","text":"<p>You can mix operations from different domains in a single executor:</p> <pre><code>#[derive(Debug)]\nstruct MultiDomainExecutor;\n\n#[executor]\nimpl MultiDomainExecutor {\n    // Filesystem\n    async fn file_read(\n        &amp;self,\n        operation: FileReadOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        todo!()\n    }\n\n    // Process\n    async fn process_spawn(\n        &amp;self,\n        operation: ProcessSpawnOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        todo!()\n    }\n\n    // Network\n    async fn network_connect(\n        &amp;self,\n        operation: NetworkConnectOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        todo!()\n    }\n}\n</code></pre> <p>The macro generates trait implementations for all 3 operation types!</p>"},{"location":"components/osl/guides/custom-executors/#advanced-features","title":"Advanced Features","text":""},{"location":"components/osl/guides/custom-executors/#helper-methods","title":"Helper Methods","text":"<p>You can add helper methods alongside operation methods - the macro ignores non-operation methods:</p> <pre><code>#[derive(Debug)]\nstruct CachedExecutor {\n    cache: HashMap&lt;String, Vec&lt;u8&gt;&gt;,\n}\n\n#[executor]\nimpl CachedExecutor {\n    // Operation method - detected by macro\n    async fn file_read(\n        &amp;self,\n        operation: FileReadOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Use helper method\n        if let Some(cached) = self.get_from_cache(&amp;operation.path) {\n            return Ok(ExecutionResult::success(cached.clone()));\n        }\n\n        // Read from disk\n        todo!()\n    }\n\n    // Helper method - ignored by macro\n    fn get_from_cache(&amp;self, path: &amp;str) -&gt; Option&lt;&amp;Vec&lt;u8&gt;&gt; {\n        self.cache.get(path)\n    }\n\n    // Another helper\n    fn cache_size(&amp;self) -&gt; usize {\n        self.cache.len()\n    }\n}\n</code></pre> <p>Only methods matching the operation signature pattern are treated as operations.</p>"},{"location":"components/osl/guides/custom-executors/#stateful-executors","title":"Stateful Executors","text":"<p>Executors can have state:</p> <pre><code>#[derive(Debug)]\nstruct StatefulExecutor {\n    config: ExecutorConfig,\n    metrics: Arc&lt;Mutex&lt;Metrics&gt;&gt;,\n}\n\nimpl StatefulExecutor {\n    fn new(config: ExecutorConfig) -&gt; Self {\n        Self {\n            config,\n            metrics: Arc::new(Mutex::new(Metrics::default())),\n        }\n    }\n}\n\n#[executor]\nimpl StatefulExecutor {\n    async fn file_read(\n        &amp;self,\n        operation: FileReadOperation,\n        context: &amp;ExecutionContext,\n    ) -&gt; OSResult&lt;ExecutionResult&gt; {\n        // Access state\n        if !self.config.allow_reads {\n            return Err(OSError::permission_denied(\"Reads disabled\"));\n        }\n\n        // Update metrics\n        self.metrics.lock().unwrap().reads += 1;\n\n        // Perform operation\n        todo!()\n    }\n}\n</code></pre>"},{"location":"components/osl/guides/custom-executors/#error-messages","title":"Error Messages","text":"<p>The macro provides helpful compile-time error messages:</p> <pre><code>#[executor]\nimpl MyExecutor {\n    // \u274c Error: Method must be async\n    fn file_read(&amp;self, operation: FileReadOperation, context: &amp;ExecutionContext) \n        -&gt; OSResult&lt;ExecutionResult&gt; { }\n\n    // \u274c Error: Second parameter must be named 'context', found 'ctx'\n    async fn file_write(&amp;self, operation: FileWriteOperation, ctx: &amp;ExecutionContext) \n        -&gt; OSResult&lt;ExecutionResult&gt; { }\n\n    // \u274c Error: Expected exactly 2 parameters, found 1\n    async fn file_delete(&amp;self, operation: FileDeleteOperation) \n        -&gt; OSResult&lt;ExecutionResult&gt; { }\n}\n</code></pre>"},{"location":"components/osl/guides/custom-executors/#feature-flag","title":"Feature Flag","text":"<p>The macro is enabled by default via the <code>macros</code> feature:</p> <pre><code>[dependencies]\nairssys-osl = \"0.1\"  # Macros enabled\n\n# Or explicitly disable:\nairssys-osl = { version = \"0.1\", default-features = false }\n</code></pre>"},{"location":"components/osl/guides/custom-executors/#complete-example","title":"Complete Example","text":"<p>See <code>examples/custom_executor_with_macro.rs</code> for a comprehensive demonstration covering:</p> <ul> <li>Simple single-operation executors</li> <li>Multi-operation executors</li> <li>Custom configuration</li> <li>Cross-domain executors</li> <li>Executors with helper methods</li> <li>Stateful executors</li> </ul>"},{"location":"components/osl/guides/custom-executors/#next-steps","title":"Next Steps","text":"<ul> <li>Review API Reference for detailed macro documentation</li> <li>Explore Examples</li> <li>Learn about Middleware integration</li> <li>Understand Security Context usage</li> </ul>"},{"location":"components/osl/guides/logging-config/","title":"Logging Configuration","text":""},{"location":"components/osl/guides/middleware/","title":"Middleware Guide","text":"<p>This guide explains how to use and compose middleware in AirsSys OSL to add cross-cutting concerns like logging, security, metrics, and custom processing to your executors.</p>"},{"location":"components/osl/guides/middleware/#overview","title":"Overview","text":"<p>Middleware in AirsSys OSL provides a flexible way to add functionality to executors without modifying their core logic. Middleware can:</p> <ul> <li>Log operations and results</li> <li>Validate security policies</li> <li>Collect metrics and telemetry</li> <li>Transform operations before execution</li> <li>Handle errors with custom logic</li> <li>Add retry, timeout, or rate-limiting capabilities</li> </ul>"},{"location":"components/osl/guides/middleware/#core-concepts","title":"Core Concepts","text":""},{"location":"components/osl/guides/middleware/#middleware-trait","title":"Middleware Trait","text":"<p>All middleware must implement the <code>Middleware&lt;O&gt;</code> trait where <code>O</code> is the operation type:</p> <pre><code>use airssys_osl::core::middleware::{Middleware, MiddlewareResult, ErrorAction};\n\n#[async_trait]\npub trait Middleware&lt;O: Operation&gt;: Send + Sync + std::fmt::Debug {\n    fn name(&amp;self) -&gt; &amp;str;\n    fn priority(&amp;self) -&gt; u32;\n\n    async fn can_process(&amp;self, operation: &amp;O, context: &amp;ExecutionContext) -&gt; bool;\n\n    async fn before_execution(\n        &amp;self,\n        operation: O,\n        context: &amp;ExecutionContext,\n    ) -&gt; MiddlewareResult&lt;Option&lt;O&gt;&gt;;\n\n    async fn after_execution(\n        &amp;self,\n        context: &amp;ExecutionContext,\n        result: &amp;OSResult&lt;ExecutionResult&gt;,\n    ) -&gt; MiddlewareResult&lt;()&gt;;\n\n    async fn handle_error(\n        &amp;self,\n        error: OSError,\n        context: &amp;ExecutionContext,\n    ) -&gt; ErrorAction;\n}\n</code></pre>"},{"location":"components/osl/guides/middleware/#middleware-lifecycle","title":"Middleware Lifecycle","text":"<p>When an operation is executed through a middleware-wrapped executor:</p> <ol> <li>can_process - Check if middleware applies to this operation</li> <li>before_execution - Transform or validate operation before execution</li> <li>execute - Core executor runs the operation</li> <li>after_execution - Post-process results and log outcomes</li> <li>handle_error - Handle any errors that occurred (if applicable)</li> </ol>"},{"location":"components/osl/guides/middleware/#basic-usage","title":"Basic Usage","text":""},{"location":"components/osl/guides/middleware/#using-built-in-middleware","title":"Using Built-in Middleware","text":"<p>AirsSys OSL provides several built-in middleware implementations:</p>"},{"location":"components/osl/guides/middleware/#logger-middleware","title":"Logger Middleware","text":"<p>The <code>LoggerMiddleware</code> logs all operations and their results:</p> <pre><code>use airssys_osl::middleware::logger::{ConsoleActivityLogger, LoggerMiddleware};\nuse airssys_osl::middleware::ext::ExecutorExt;\nuse airssys_osl::executors::filesystem::FilesystemExecutor;\nuse airssys_osl::operations::filesystem::FileReadOperation;\nuse airssys_osl::core::context::{SecurityContext, ExecutionContext};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create logger\n    let logger = ConsoleActivityLogger::default();\n    let middleware = LoggerMiddleware::with_default_config(logger);\n\n    // Create executor with logging middleware\n    let executor = FilesystemExecutor::new(\"my-executor\")\n        .with_middleware(middleware);\n\n    // Execute operation - automatically logs activity\n    let operation = FileReadOperation::new(\"/tmp/test.txt\");\n    let context = ExecutionContext::new(SecurityContext::new(\"user\".to_string()));\n    let result = executor.execute(operation, &amp;context).await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"components/osl/guides/middleware/#available-loggers","title":"Available Loggers","text":"<ul> <li>ConsoleActivityLogger - Logs to stdout with configurable format</li> <li>FileActivityLogger - Logs to a file with rotation support</li> <li>TracingActivityLogger - Integrates with the <code>tracing</code> ecosystem</li> </ul>"},{"location":"components/osl/guides/middleware/#middleware-chaining","title":"Middleware Chaining","text":"<p>One of the most powerful features is the ability to chain multiple middleware together. This creates a processing pipeline where each middleware can add its own functionality.</p>"},{"location":"components/osl/guides/middleware/#how-chaining-works","title":"How Chaining Works","text":"<p>The <code>ExecutorExt</code> trait provides the <code>.with_middleware()</code> method that can be called multiple times:</p> <pre><code>use airssys_osl::prelude::*;\nuse airssys_osl::middleware::ext::ExecutorExt;\n\nlet executor = FilesystemExecutor::new(\"filesystem-executor\")\n    .with_middleware(middleware1)\n    .with_middleware(middleware2)\n    .with_middleware(middleware3);\n</code></pre>"},{"location":"components/osl/guides/middleware/#execution-order","title":"Execution Order","text":"<p>When multiple middleware are chained, they execute in a nested/onion-like pattern:</p> <pre><code>Request Flow:\n  \u2192 middleware3.before_execution()\n    \u2192 middleware2.before_execution()\n      \u2192 middleware1.before_execution()\n        \u2192 [Core Executor]\n      \u2190 middleware1.after_execution()\n    \u2190 middleware2.after_execution()\n  \u2190 middleware3.after_execution()\n</code></pre> <p>Key Points: - Outermost middleware runs first for <code>before_execution</code> hooks - Innermost middleware is closest to the actual executor - Reverse order for <code>after_execution</code> and error handling - Each middleware can transform the operation or short-circuit the chain</p>"},{"location":"components/osl/guides/middleware/#chaining-example","title":"Chaining Example","text":"<pre><code>use airssys_osl::prelude::*;\nuse airssys_osl::middleware::logger::{\n    ConsoleActivityLogger, FileActivityLogger, LoggerMiddleware\n};\nuse airssys_osl::middleware::ext::ExecutorExt;\nuse airssys_osl::core::executor::OSExecutor;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), OSError&gt; {\n    // Create multiple middleware\n    let console_logger = ConsoleActivityLogger::default();\n    let console_middleware = LoggerMiddleware::with_default_config(console_logger);\n\n    let file_logger = FileActivityLogger::new(\"/tmp/ops.log\").await?;\n    let file_middleware = LoggerMiddleware::with_default_config(file_logger);\n\n    // Chain them together\n    let executor = FilesystemExecutor::new(\"filesystem-executor\")\n        .with_middleware(console_middleware)  // Logs to console\n        .with_middleware(file_middleware);     // Also logs to file\n\n    // Execute operation - both middleware will process it\n    let operation = FileWriteOperation::new(\n        \"/tmp/test.txt\".to_string(),\n        b\"Hello, Middleware!\".to_vec()\n    );\n    let context = ExecutionContext::new(SecurityContext::new(\"user\".to_string()));\n    let result = executor.execute(operation, &amp;context).await?;\n\n    // Both console and file will have logged this operation\n    Ok(())\n}\n</code></pre>"},{"location":"components/osl/guides/middleware/#middleware-across-executor-types","title":"Middleware Across Executor Types","text":"<p>The same middleware can be used with different executor types:</p> <pre><code>use airssys_osl::prelude::*;\nuse airssys_osl::executors::{FilesystemExecutor, ProcessExecutor};\nuse airssys_osl::middleware::logger::{TracingActivityLogger, LoggerMiddleware};\nuse airssys_osl::middleware::ext::ExecutorExt;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), OSError&gt; {\n    let logger = TracingActivityLogger::new();\n\n    // Same middleware, different executors\n    let fs_executor = FilesystemExecutor::new(\"filesystem-executor\")\n        .with_middleware(LoggerMiddleware::with_default_config(logger.clone()));\n\n    let process_executor = ProcessExecutor::new(\"my-executor\")\n        .with_middleware(LoggerMiddleware::with_default_config(logger));\n\n    // Both executors now have logging capabilities\n    Ok(())\n}\n</code></pre>"},{"location":"components/osl/guides/middleware/#creating-custom-middleware","title":"Creating Custom Middleware","text":"<p>Custom middleware allows you to implement your own cross-cutting concerns like rate limiting, caching, metrics collection, retry logic, and more. This section provides a comprehensive guide to creating production-ready custom middleware.</p>"},{"location":"components/osl/guides/middleware/#step-by-step-guide","title":"Step-by-Step Guide","text":""},{"location":"components/osl/guides/middleware/#1-define-your-middleware-struct","title":"1. Define Your Middleware Struct","text":"<p>Create a struct to hold your middleware state and configuration:</p> <pre><code>use std::sync::Arc;\nuse tokio::sync::Mutex;\nuse std::collections::HashMap;\nuse tokio::time::{Duration, Instant};\n\n#[derive(Debug, Clone)]\npub struct RateLimitMiddleware {\n    /// Maximum operations allowed per second\n    max_ops_per_second: u32,\n    /// Shared state tracking operation timestamps\n    state: Arc&lt;Mutex&lt;RateLimitState&gt;&gt;,\n}\n\n#[derive(Debug)]\nstruct RateLimitState {\n    /// Track timestamps of recent operations per user\n    operation_times: HashMap&lt;String, Vec&lt;Instant&gt;&gt;,\n}\n</code></pre> <p>Key Points: - Use <code>#[derive(Debug, Clone)]</code> for middleware that will be shared across executors - Use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> for thread-safe shared state - Separate state into its own struct for clarity</p>"},{"location":"components/osl/guides/middleware/#2-implement-the-constructor","title":"2. Implement the Constructor","text":"<p>Provide a clear API for creating your middleware:</p> <pre><code>impl RateLimitMiddleware {\n    /// Create a new rate limiter with specified operations per second limit.\n    pub fn new(max_ops_per_second: u32) -&gt; Self {\n        Self {\n            max_ops_per_second,\n            state: Arc::new(Mutex::new(RateLimitState {\n                operation_times: HashMap::new(),\n            })),\n        }\n    }\n}\n</code></pre>"},{"location":"components/osl/guides/middleware/#3-implement-the-middleware-trait","title":"3. Implement the Middleware Trait","text":"<p>Implement the <code>Middleware&lt;O&gt;</code> trait for your middleware:</p> <pre><code>use airssys_osl::core::middleware::{Middleware, MiddlewareResult, MiddlewareError, ErrorAction};\nuse airssys_osl::core::operation::Operation;\nuse airssys_osl::core::context::ExecutionContext;\nuse airssys_osl::core::result::OSResult;\nuse async_trait::async_trait;\n\n#[async_trait]\nimpl&lt;O: Operation&gt; Middleware&lt;O&gt; for RateLimitMiddleware {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"rate_limiter\"\n    }\n\n    fn priority(&amp;self) -&gt; u32 {\n        // High priority (75) - run before most middleware but after security (100)\n        75\n    }\n\n    async fn can_process(&amp;self, _operation: &amp;O, _context: &amp;ExecutionContext) -&gt; bool {\n        // Process all operations\n        true\n    }\n\n    async fn before_execution(\n        &amp;self,\n        operation: O,\n        context: &amp;ExecutionContext,\n    ) -&gt; MiddlewareResult&lt;Option&lt;O&gt;&gt; {\n        let user = &amp;context.security_context.principal;\n\n        // Check rate limit\n        if self.check_rate_limit(user).await {\n            // Under limit - allow operation\n            Ok(Some(operation))\n        } else {\n            // Rate limit exceeded - reject operation\n            Err(MiddlewareError::NonFatal(format!(\n                \"Rate limit exceeded for user '{}': max {} operations per second\",\n                user, self.max_ops_per_second\n            )))\n        }\n    }\n\n    async fn after_execution(\n        &amp;self,\n        _context: &amp;ExecutionContext,\n        _result: &amp;OSResult&lt;airssys_osl::core::executor::ExecutionResult&gt;,\n    ) -&gt; MiddlewareResult&lt;()&gt; {\n        // No post-processing needed for rate limiting\n        Ok(())\n    }\n\n    async fn handle_error(\n        &amp;self,\n        _error: OSError,\n        _context: &amp;ExecutionContext,\n    ) -&gt; ErrorAction {\n        // Let errors propagate\n        ErrorAction::Stop\n    }\n}\n</code></pre> <p>Trait Method Guide:</p> <ul> <li><code>name()</code>: Unique identifier for your middleware (used in logging and debugging)</li> <li><code>priority()</code>: Determines execution order (0-100, higher = outer layer)</li> <li>100: Security middleware</li> <li>75: Rate limiting, caching</li> <li>50: Metrics, logging</li> <li>25: Retry logic</li> <li><code>can_process()</code>: Filter which operations this middleware handles (return false to skip)</li> <li><code>before_execution()</code>: Validate, transform, or reject operations before execution</li> <li>Return <code>Ok(Some(operation))</code> to continue</li> <li>Return <code>Ok(None)</code> to short-circuit (cached result, etc.)</li> <li>Return <code>Err(...)</code> to reject the operation</li> <li><code>after_execution()</code>: Process results, update metrics, log outcomes</li> <li><code>handle_error()</code>: Custom error handling</li> <li><code>ErrorAction::Stop</code>: Propagate error immediately</li> <li><code>ErrorAction::Continue</code>: Log and continue</li> <li><code>ErrorAction::Retry</code>: Attempt to retry operation</li> </ul>"},{"location":"components/osl/guides/middleware/#4-implement-helper-methods","title":"4. Implement Helper Methods","text":"<p>Add helper methods for your middleware logic:</p> <pre><code>impl RateLimitMiddleware {\n    /// Check if the user has exceeded their rate limit.\n    async fn check_rate_limit(&amp;self, user: &amp;str) -&gt; bool {\n        let mut state = self.state.lock().await;\n        let now = Instant::now();\n        let one_second_ago = now - Duration::from_secs(1);\n\n        // Get or create user's operation history\n        let times = state\n            .operation_times\n            .entry(user.to_string())\n            .or_insert_with(Vec::new);\n\n        // Remove operations older than 1 second (sliding window)\n        times.retain(|&amp;time| time &gt; one_second_ago);\n\n        // Check if under limit\n        if times.len() &lt; self.max_ops_per_second as usize {\n            // Record this operation\n            times.push(now);\n            true\n        } else {\n            false\n        }\n    }\n}\n</code></pre>"},{"location":"components/osl/guides/middleware/#real-world-middleware-examples","title":"Real-World Middleware Examples","text":""},{"location":"components/osl/guides/middleware/#example-1-rate-limiting-complete-implementation","title":"Example 1: Rate Limiting (Complete Implementation)","text":"<p>See the complete working example in <code>examples/custom_middleware.rs</code> which demonstrates:</p> <ul> <li>Thread-safe state management with <code>Arc&lt;Mutex&lt;HashMap&gt;&gt;</code></li> <li>Per-user rate tracking with sliding window</li> <li>Configurable operations per second limit</li> <li>Integration with ExecutorExt and helper functions</li> </ul> <p>Usage:</p> <pre><code>use airssys_osl::middleware::ext::ExecutorExt;\n\n// Create rate limiter: 100 operations per second\nlet rate_limiter = RateLimitMiddleware::new(100);\n\n// Use with executor\nlet executor = FilesystemExecutor::new(\"filesystem-executor\")\n    .with_middleware(rate_limiter);\n\n// Or use with helper functions\nlet data = read_file_with_middleware(\n    \"/path/to/file\",\n    \"user\",\n    RateLimitMiddleware::new(50)\n).await?;\n</code></pre>"},{"location":"components/osl/guides/middleware/#example-2-caching-middleware-conceptual","title":"Example 2: Caching Middleware (Conceptual)","text":"<pre><code>use std::sync::Arc;\nuse tokio::sync::RwLock;\nuse std::collections::HashMap;\nuse tokio::time::{Duration, Instant};\nuse async_trait::async_trait;\nuse airssys_osl::middleware::{Middleware, MiddlewareResult};\nuse airssys_osl::core::{Operation, ExecutionContext, OperationType};\n\n#[derive(Debug, Clone)]\npub struct CachingMiddleware {\n    cache: Arc&lt;RwLock&lt;HashMap&lt;String, CachedResult&gt;&gt;&gt;,\n    ttl: Duration,\n}\n\n#[derive(Debug, Clone)]\nstruct CachedResult {\n    data: Vec&lt;u8&gt;,\n    cached_at: Instant,\n}\n\nimpl CachingMiddleware {\n    pub fn new(ttl: Duration) -&gt; Self {\n        Self {\n            cache: Arc::new(RwLock::new(HashMap::new())),\n            ttl,\n        }\n    }\n\n    async fn get_cached(&amp;self, key: &amp;str) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {\n        let cache = self.cache.read().await;\n        if let Some(entry) = cache.get(key) {\n            if entry.cached_at.elapsed() &lt; self.ttl {\n                return Some(entry.data.clone());\n            }\n        }\n        None\n    }\n\n    async fn set_cached(&amp;self, key: String, data: Vec&lt;u8&gt;) {\n        let mut cache = self.cache.write().await;\n        cache.insert(key, CachedResult {\n            data,\n            cached_at: Instant::now(),\n        });\n    }\n}\n\n#[async_trait]\nimpl&lt;O: Operation&gt; Middleware&lt;O&gt; for CachingMiddleware {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"caching\"\n    }\n\n    fn priority(&amp;self) -&gt; u32 {\n        75 // High priority to check cache early\n    }\n\n    async fn can_process(&amp;self, operation: &amp;O, _context: &amp;ExecutionContext) -&gt; bool {\n        // Only cache read operations\n        operation.operation_type() == OperationType::Filesystem\n    }\n\n    async fn before_execution(\n        &amp;self,\n        operation: O,\n        _context: &amp;ExecutionContext,\n    ) -&gt; MiddlewareResult&lt;Option&lt;O&gt;&gt; {\n        // Check cache - if hit, return None to skip execution\n        let cache_key = format!(\"{:?}\", operation);\n\n        if self.get_cached(&amp;cache_key).await.is_some() {\n            // Cache hit - skip execution (would need to return cached result)\n            // Note: This is simplified - real implementation needs result injection\n            Ok(None)\n        } else {\n            // Cache miss - continue to executor\n            Ok(Some(operation))\n        }\n    }\n\n    async fn after_execution(\n        &amp;self,\n        _context: &amp;ExecutionContext,\n        result: &amp;OSResult&lt;ExecutionResult&gt;,\n    ) -&gt; MiddlewareResult&lt;()&gt; {\n        // Cache successful results\n        if let Ok(exec_result) = result {\n            let cache_key = format!(\"{}\", exec_result.operation_id);\n            self.set_cached(cache_key, exec_result.output.clone()).await;\n        }\n        Ok(())\n    }\n\n    async fn handle_error(\n        &amp;self,\n        _error: OSError,\n        _context: &amp;ExecutionContext,\n    ) -&gt; ErrorAction {\n        ErrorAction::Continue\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>// Cache file reads for 60 seconds\nlet caching = CachingMiddleware::new(Duration::from_secs(60));\n\nlet executor = FilesystemExecutor::new(\"filesystem-executor\")\n    .with_middleware(caching);\n</code></pre>"},{"location":"components/osl/guides/middleware/#example-3-metrics-collection-middleware-conceptual","title":"Example 3: Metrics Collection Middleware (Conceptual)","text":"<pre><code>use std::sync::Arc;\nuse tokio::sync::Mutex;\nuse std::collections::HashMap;\n\n#[derive(Debug, Clone)]\npub struct MetricsMiddleware {\n    metrics: Arc&lt;Mutex&lt;OperationMetrics&gt;&gt;,\n}\n\n#[derive(Debug, Default)]\nstruct OperationMetrics {\n    total_ops: u64,\n    successful_ops: u64,\n    failed_ops: u64,\n    total_duration_ms: u64,\n}\n\nimpl MetricsMiddleware {\n    pub fn new() -&gt; Self {\n        Self {\n            metrics: Arc::new(Mutex::new(OperationMetrics::default())),\n        }\n    }\n\n    pub async fn get_stats(&amp;self) -&gt; OperationMetrics {\n        self.metrics.lock().await.clone()\n    }\n}\n\n#[async_trait]\nimpl&lt;O: Operation&gt; Middleware&lt;O&gt; for MetricsMiddleware {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"metrics\"\n    }\n\n    fn priority(&amp;self) -&gt; u32 {\n        50 // Medium priority\n    }\n\n    async fn can_process(&amp;self, _operation: &amp;O, _context: &amp;ExecutionContext) -&gt; bool {\n        true // Collect metrics for all operations\n    }\n\n    async fn before_execution(\n        &amp;self,\n        operation: O,\n        _context: &amp;ExecutionContext,\n    ) -&gt; MiddlewareResult&lt;Option&lt;O&gt;&gt; {\n        let mut metrics = self.metrics.lock().await;\n        metrics.total_ops += 1;\n        Ok(Some(operation))\n    }\n\n    async fn after_execution(\n        &amp;self,\n        _context: &amp;ExecutionContext,\n        result: &amp;OSResult&lt;ExecutionResult&gt;,\n    ) -&gt; MiddlewareResult&lt;()&gt; {\n        let mut metrics = self.metrics.lock().await;\n\n        match result {\n            Ok(exec_result) =&gt; {\n                metrics.successful_ops += 1;\n                metrics.total_duration_ms += exec_result.duration.as_millis() as u64;\n            }\n            Err(_) =&gt; {\n                metrics.failed_ops += 1;\n            }\n        }\n\n        Ok(())\n    }\n\n    async fn handle_error(\n        &amp;self,\n        _error: OSError,\n        _context: &amp;ExecutionContext,\n    ) -&gt; ErrorAction {\n        ErrorAction::Continue\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>let metrics = MetricsMiddleware::new();\n\nlet executor = FilesystemExecutor::new(\"filesystem-executor\")\n    .with_middleware(metrics.clone());\n\n// ... perform operations ...\n\n// Get statistics\nlet stats = metrics.get_stats().await;\nprintln!(\"Total operations: {}\", stats.total_ops);\nprintln!(\"Success rate: {:.2}%\", \n    (stats.successful_ops as f64 / stats.total_ops as f64) * 100.0);\n</code></pre>"},{"location":"components/osl/guides/middleware/#example-4-retry-middleware-conceptual","title":"Example 4: Retry Middleware (Conceptual)","text":"<pre><code>#[derive(Debug, Clone)]\npub struct RetryMiddleware {\n    max_attempts: u32,\n    backoff_ms: u64,\n}\n\nimpl RetryMiddleware {\n    pub fn new(max_attempts: u32, backoff_ms: u64) -&gt; Self {\n        Self { max_attempts, backoff_ms }\n    }\n}\n\n#[async_trait]\nimpl&lt;O: Operation&gt; Middleware&lt;O&gt; for RetryMiddleware {\n    fn name(&amp;self) -&gt; &amp;str {\n        \"retry\"\n    }\n\n    fn priority(&amp;self) -&gt; u32 {\n        25 // Low priority - retry failed operations\n    }\n\n    async fn can_process(&amp;self, _operation: &amp;O, _context: &amp;ExecutionContext) -&gt; bool {\n        true\n    }\n\n    async fn before_execution(\n        &amp;self,\n        operation: O,\n        _context: &amp;ExecutionContext,\n    ) -&gt; MiddlewareResult&lt;Option&lt;O&gt;&gt; {\n        Ok(Some(operation))\n    }\n\n    async fn after_execution(\n        &amp;self,\n        _context: &amp;ExecutionContext,\n        _result: &amp;OSResult&lt;ExecutionResult&gt;,\n    ) -&gt; MiddlewareResult&lt;()&gt; {\n        Ok(())\n    }\n\n    async fn handle_error(\n        &amp;self,\n        error: OSError,\n        _context: &amp;ExecutionContext,\n    ) -&gt; ErrorAction {\n        // Retry on transient errors\n        match error {\n            OSError::NetworkError { .. } | OSError::Timeout { .. } =&gt; {\n                ErrorAction::Retry\n            }\n            _ =&gt; ErrorAction::Stop\n        }\n    }\n}\n</code></pre>"},{"location":"components/osl/guides/middleware/#testing-custom-middleware","title":"Testing Custom Middleware","text":""},{"location":"components/osl/guides/middleware/#unit-testing","title":"Unit Testing","text":"<p>Test your middleware in isolation:</p> <pre><code>#[tokio::test]\nasync fn test_rate_limit_enforcement() {\n    let limiter = RateLimitMiddleware::new(2); // 2 ops/sec\n\n    // First two operations should succeed\n    assert!(limiter.check_rate_limit(\"testuser\").await);\n    assert!(limiter.check_rate_limit(\"testuser\").await);\n\n    // Third operation should fail\n    assert!(!limiter.check_rate_limit(\"testuser\").await);\n}\n\n#[tokio::test]\nasync fn test_rate_limit_per_user() {\n    let limiter = RateLimitMiddleware::new(1); // 1 op/sec\n\n    // Different users have separate limits\n    assert!(limiter.check_rate_limit(\"user1\").await);\n    assert!(limiter.check_rate_limit(\"user2\").await);\n\n    // Same user should be limited\n    assert!(!limiter.check_rate_limit(\"user1\").await);\n}\n</code></pre>"},{"location":"components/osl/guides/middleware/#integration-testing","title":"Integration Testing","text":"<p>Test middleware with actual operations:</p> <pre><code>#[tokio::test]\nasync fn test_middleware_integration() {\n    let limiter = RateLimitMiddleware::new(5);\n    let executor = FilesystemExecutor::new(\"filesystem-executor\")\n        .with_middleware(limiter);\n\n    let context = ExecutionContext::new(\n        SecurityContext::new(\"test\".to_string())\n    );\n\n    // Create a test file\n    let temp_file = std::env::temp_dir().join(\"middleware_test.txt\");\n    std::fs::write(&amp;temp_file, b\"test data\")\n        .expect(\"Failed to create test file\");\n\n    // Operation should succeed\n    let operation = FileReadOperation::new(\n        temp_file.to_str().unwrap().to_string()\n    );\n    let result = executor.execute(operation, &amp;context).await;\n\n    // Cleanup\n    let _ = std::fs::remove_file(&amp;temp_file);\n\n    assert!(result.is_ok(), \"Operation should succeed within rate limit\");\n}\n</code></pre>"},{"location":"components/osl/guides/middleware/#middleware-priority-guidelines","title":"Middleware Priority Guidelines","text":"<p>When setting priority values, follow these guidelines:</p> Priority Range Purpose Examples 90-100 Critical security and validation SecurityMiddleware (100) 70-89 Resource management RateLimitMiddleware (75), CachingMiddleware (75) 50-69 Observability and metrics MetricsMiddleware (50), LoggerMiddleware (50) 25-49 Error handling and recovery RetryMiddleware (25) 0-24 Low-priority cross-cutting concerns Custom audit trails, cleanup"},{"location":"components/osl/guides/middleware/#integration-with-helper-functions","title":"Integration with Helper Functions","text":"<p>Custom middleware can be used with all three API levels:</p> <p>Level 1 - Simple Helpers (uses default middleware): <pre><code>// Cannot use custom middleware - uses defaults only\nlet data = read_file(\"/path\", \"user\").await?;\n</code></pre></p> <p>Level 2 - Custom Middleware Helpers: <pre><code>// Use with *_with_middleware variants\nlet custom = RateLimitMiddleware::new(100);\nlet data = read_file_with_middleware(\"/path\", \"user\", custom).await?;\n</code></pre></p> <p>Level 3 - Trait Composition (Future): <pre><code>// Build reusable pipelines\nlet helper = FileHelper::new()\n    .with_middleware(RateLimitMiddleware::new(100))\n    .with_middleware(MetricsMiddleware::new());\n\nlet data = helper.read(\"/path\", \"user\").await?;\n</code></pre></p>"},{"location":"components/osl/guides/middleware/#common-patterns","title":"Common Patterns","text":""},{"location":"components/osl/guides/middleware/#pattern-1-conditional-processing","title":"Pattern 1: Conditional Processing","text":"<pre><code>async fn can_process(&amp;self, operation: &amp;O, context: &amp;ExecutionContext) -&gt; bool {\n    // Only process operations from specific users\n    context.security_context.principal == \"admin\"\n}\n</code></pre>"},{"location":"components/osl/guides/middleware/#pattern-2-operation-transformation","title":"Pattern 2: Operation Transformation","text":"<pre><code>async fn before_execution(\n    &amp;self,\n    mut operation: O,\n    _context: &amp;ExecutionContext,\n) -&gt; MiddlewareResult&lt;Option&lt;O&gt;&gt; {\n    // Modify operation before execution\n    // (requires mutable operation type)\n    Ok(Some(operation))\n}\n</code></pre>"},{"location":"components/osl/guides/middleware/#pattern-3-short-circuit-execution","title":"Pattern 3: Short-Circuit Execution","text":"<pre><code>async fn before_execution(\n    &amp;self,\n    operation: O,\n    _context: &amp;ExecutionContext,\n) -&gt; MiddlewareResult&lt;Option&lt;O&gt;&gt; {\n    if should_skip(&amp;operation) {\n        // Return None to skip executor\n        return Ok(None);\n    }\n    Ok(Some(operation))\n}\n</code></pre>"},{"location":"components/osl/guides/middleware/#complete-working-example","title":"Complete Working Example","text":"<p>For a complete, production-ready example of custom middleware, see: - <code>examples/custom_middleware.rs</code> - Full RateLimitMiddleware implementation with tests</p> <p>This example demonstrates: - Thread-safe state management - Sliding window rate limiting - Integration with ExecutorExt - Middleware chaining - Helper function integration - Comprehensive testing patterns</p>"},{"location":"components/osl/guides/middleware/#best-practices","title":"Best Practices","text":""},{"location":"components/osl/guides/middleware/#middleware-ordering","title":"Middleware Ordering","text":"<p>Order your middleware chain carefully based on concerns:</p> <pre><code>// Recommended order:\nlet executor = FilesystemExecutor::new(\"filesystem-executor\")\n    .with_middleware(metrics_middleware)      // Outermost - measure everything\n    .with_middleware(security_middleware)     // Security validation\n    .with_middleware(retry_middleware)        // Retry failed operations\n    .with_middleware(logging_middleware);     // Innermost - detailed logging\n</code></pre>"},{"location":"components/osl/guides/middleware/#error-handling","title":"Error Handling","text":"<p>Middleware can decide how to handle errors:</p> <ul> <li>ErrorAction::Stop - Stop processing and return the error</li> <li>ErrorAction::Continue - Continue with the error</li> <li>ErrorAction::Retry - Attempt to retry the operation</li> </ul>"},{"location":"components/osl/guides/middleware/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Keep <code>can_process()</code> lightweight - it's called for every operation</li> <li>Avoid blocking operations in middleware hooks</li> <li>Use async operations for I/O (logging to files, network calls)</li> <li>Consider middleware overhead when chaining many middleware</li> </ul>"},{"location":"components/osl/guides/middleware/#testing-middleware","title":"Testing Middleware","text":"<p>Test your middleware in isolation:</p> <pre><code>#[tokio::test]\nasync fn test_custom_middleware() {\n    let middleware = MyCustomMiddleware::new();\n    let operation = FileReadOperation::new(\"/test\".to_string());\n    let context = ExecutionContext::new(SecurityContext::new(\"test\".to_string()));\n\n    // Test can_process\n    assert!(middleware.can_process(&amp;operation, &amp;context).await);\n\n    // Test before_execution\n    let result = middleware.before_execution(operation, &amp;context).await;\n    assert!(result.is_ok());\n}\n</code></pre>"},{"location":"components/osl/guides/middleware/#additional-examples","title":"Additional Examples","text":"<p>See the complete working examples in the repository:</p> <ul> <li>middleware_extension.rs - Demonstrates basic usage, chaining, and cross-executor middleware</li> <li>helper_functions.rs - Shows helper functions that use middleware internally</li> </ul>"},{"location":"components/osl/guides/middleware/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about Security Setup for security middleware</li> <li>Explore Logging Configuration for advanced logging patterns</li> <li>Read about Custom Executors to build executor/middleware combinations</li> </ul>"},{"location":"components/osl/guides/middleware/#related-documentation","title":"Related Documentation","text":"<ul> <li>Core Types API</li> <li>Activity Logging API</li> <li>Architecture Overview</li> </ul>"},{"location":"components/osl/guides/security-setup/","title":"Security Setup","text":""},{"location":"components/osl/guides/testing/","title":"Testing Guide","text":""},{"location":"components/osl/reference/compatibility/","title":"Platform Compatibility","text":""},{"location":"components/osl/reference/error-handling/","title":"Error Handling","text":""},{"location":"components/osl/reference/performance/","title":"Performance Guidelines","text":""},{"location":"components/osl/reference/security-practices/","title":"Security Best Practices","text":""},{"location":"components/rt/","title":"Introduction","text":"<p>airssys-rt is a lightweight Erlang-Actor model runtime system designed for high-concurrency applications within the AirsSys ecosystem. This component provides an in-memory process management system inspired by the BEAM virtual machine, focusing on actor-based concurrency patterns and supervisor tree fault tolerance.</p>"},{"location":"components/rt/#what-is-airssys-rt","title":"What is airssys-rt?","text":"<p><code>airssys-rt</code> implements core concepts from the Erlang/OTP runtime in Rust, specifically:</p> <ul> <li>Virtual Process Management: Lightweight, isolated processes similar to BEAM's green threads</li> <li>Actor Model: Encapsulated state with asynchronous message passing</li> <li>Supervisor Trees: Hierarchical fault tolerance and automatic recovery</li> <li>Mailbox Pattern: Sequential message processing with backpressure control</li> </ul>"},{"location":"components/rt/#design-philosophy","title":"Design Philosophy","text":""},{"location":"components/rt/#lightweight-focused","title":"Lightweight &amp; Focused","text":"<p>Unlike attempting to recreate the entire BEAM runtime, <code>airssys-rt</code> focuses on the essential patterns that make Erlang/OTP systems resilient and scalable. It provides a Rust-native implementation that integrates seamlessly with the async/await ecosystem.</p>"},{"location":"components/rt/#in-memory-process-model","title":"In-Memory Process Model","text":"<p>The \"processes\" in <code>airssys-rt</code> are virtual processes - lightweight units of execution managed entirely in memory, similar to: - Erlang processes in BEAM - Green threads in Go - Actors in Akka/Actor model frameworks</p> <p>These are not OS processes, but rather managed execution contexts with isolated state.</p>"},{"location":"components/rt/#integration-with-airssys-ecosystem","title":"Integration with AirsSys Ecosystem","text":"<p><code>airssys-rt</code> is designed to work closely with other AirsSys components: - airssys-osl: Provides OS-level integration and security context - airssys-wasm: Future integration for WebAssembly component hosting</p>"},{"location":"components/rt/#core-principles","title":"Core Principles","text":""},{"location":"components/rt/#1-encapsulation","title":"1. Encapsulation","text":"<p>Each actor maintains private internal state that cannot be directly accessed by other actors. State mutations happen only through message processing.</p>"},{"location":"components/rt/#2-asynchronous-message-passing","title":"2. Asynchronous Message Passing","text":"<p>Actors communicate exclusively through immutable messages. No shared memory, no locks, no race conditions.</p>"},{"location":"components/rt/#3-mailbox-sequential-processing","title":"3. Mailbox &amp; Sequential Processing","text":"<p>Every actor has a mailbox that queues incoming messages. Messages are processed one at a time, ensuring state consistency.</p>"},{"location":"components/rt/#4-fault-isolation-supervision","title":"4. Fault Isolation &amp; Supervision","text":"<p>Failures are contained within individual actors. Supervisor actors monitor their children and implement restart strategies.</p>"},{"location":"components/rt/#key-features","title":"Key Features","text":"<ul> <li>High Concurrency: Support for 10,000+ concurrent actors</li> <li>Low Latency: Sub-millisecond message delivery for local communication</li> <li>Fault Tolerance: Supervisor-based fault recovery and isolation</li> <li>Memory Efficiency: Minimal overhead per actor (&lt;1KB baseline)</li> <li>Async Integration: Built on Tokio for seamless async/await compatibility</li> </ul>"},{"location":"components/rt/#use-cases","title":"Use Cases","text":"<p><code>airssys-rt</code> is ideal for: - High-concurrency servers requiring fault tolerance - Event-driven architectures with complex state management - System programming requiring reliable process supervision - Microservice coordination within the AirsSys ecosystem - Real-time applications with soft latency requirements</p>"},{"location":"components/rt/#getting-started","title":"Getting Started","text":"<p>To begin using <code>airssys-rt</code>, see the Getting Started guide in the Implementation section.</p> <p>For architectural details, explore the Core Concepts and Actor Model Design sections.</p> <p>To understand the research and design decisions behind <code>airssys-rt</code>, review the Research Overview section.</p>"},{"location":"components/rt/api/","title":"API Reference","text":"<p>This API reference documents the actual, implemented APIs in <code>airssys-rt</code>. All code examples are from real, working implementations.</p> <p>\ud83d\udca1 Tip: For the most up-to-date API documentation, run <code>cargo doc --open --package airssys-rt</code> to view the generated Rustdoc.</p>"},{"location":"components/rt/api/#core-api-overview","title":"Core API Overview","text":"<p>The <code>airssys-rt</code> API is organized into several key modules:</p> <ul> <li><code>actor</code> - Core actor trait and context</li> <li><code>message</code> - Message types and envelopes</li> <li><code>broker</code> - Message broker for pub/sub</li> <li><code>mailbox</code> - Message queue implementations</li> <li><code>supervisor</code> - Supervision and fault tolerance</li> <li><code>monitoring</code> - Health checks and metrics</li> <li><code>util</code> - Utilities (addressing, IDs)</li> </ul>"},{"location":"components/rt/api/#actor-api","title":"Actor API","text":""},{"location":"components/rt/api/#actor-trait","title":"Actor Trait","text":"<p>The foundational trait for all actors (from <code>src/actor/traits.rs</code>):</p> <pre><code>use airssys_rt::{Actor, ActorContext, Message, ErrorAction};\nuse async_trait::async_trait;\n\n#[async_trait]\npub trait Actor: Send + Sync + 'static {\n    /// The type of messages this actor handles\n    type Message: Message;\n\n    /// The error type for actor operations\n    type Error: Error + Send + Sync + 'static;\n\n    /// Handle an incoming message\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt;;\n\n    /// Lifecycle hook: called before actor starts (optional)\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        Ok(())\n    }\n\n    /// Lifecycle hook: called when actor stops (optional)\n    async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        Ok(())\n    }\n\n    /// Error handler: return supervision decision (optional)\n    async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        error: Self::Error,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; ErrorAction {\n        ErrorAction::Restart\n    }\n}\n</code></pre>"},{"location":"components/rt/api/#actorcontext","title":"ActorContext","text":"<p>Context provided to actors during message handling:</p> <pre><code>pub struct ActorContext&lt;M: Message, B: MessageBroker&lt;M&gt;&gt; {\n    // Fields are private, access via methods\n}\n\nimpl&lt;M: Message, B: MessageBroker&lt;M&gt;&gt; ActorContext&lt;M, B&gt; {\n    /// Get the actor's address\n    pub fn address(&amp;self) -&gt; &amp;ActorAddress;\n\n    /// Get the actor's unique ID\n    pub fn id(&amp;self) -&gt; &amp;ActorId;\n\n    /// Get when the actor was created\n    pub fn created_at(&amp;self) -&gt; DateTime&lt;Utc&gt;;\n\n    /// Get when the last message was processed\n    pub fn last_message_at(&amp;self) -&gt; Option&lt;DateTime&lt;Utc&gt;&gt;;\n\n    /// Get total number of messages processed\n    pub fn message_count(&amp;self) -&gt; u64;\n\n    /// Record that a message was processed\n    pub fn record_message(&amp;mut self);\n\n    /// Send a message to another actor\n    pub async fn send(&amp;self, message: M, recipient: ActorAddress) \n        -&gt; Result&lt;(), String&gt;;\n}\n</code></pre>"},{"location":"components/rt/api/#actorlifecycle","title":"ActorLifecycle","text":"<p>State management for actor lifecycle:</p> <pre><code>pub enum ActorState {\n    Starting,   // Actor is initializing\n    Running,    // Actor is active\n    Stopping,   // Actor is shutting down\n    Stopped,    // Actor has stopped\n    Failed,     // Actor has failed\n}\n\npub struct ActorLifecycle {\n    // Implementation details hidden\n}\n\nimpl ActorLifecycle {\n    pub fn new() -&gt; Self;\n    pub fn state(&amp;self) -&gt; ActorState;\n    pub fn transition_to(&amp;mut self, new_state: ActorState);\n    pub fn restart_count(&amp;self) -&gt; u32;\n    pub fn last_state_change(&amp;self) -&gt; DateTime&lt;Utc&gt;;\n    pub fn is_terminal(&amp;self) -&gt; bool;\n    pub fn is_running(&amp;self) -&gt; bool;\n}\n</code></pre>"},{"location":"components/rt/api/#erroraction","title":"ErrorAction","text":"<p>Control supervision behavior on errors:</p> <pre><code>pub enum ErrorAction {\n    Resume,     // Continue processing (ignore error)\n    Restart,    // Restart the actor\n    Stop,       // Stop the actor permanently\n    Escalate,   // Pass error to supervisor\n}\n</code></pre>"},{"location":"components/rt/api/#message-api","title":"Message API","text":""},{"location":"components/rt/api/#message-trait","title":"Message Trait","text":"<p>All messages must implement this trait:</p> <pre><code>pub trait Message: Clone + Send + Sync + 'static \n    + serde::Serialize + for&lt;'de&gt; serde::Deserialize&lt;'de&gt; \n{\n    const MESSAGE_TYPE: &amp;'static str;\n}\n</code></pre> <p>Example implementation:</p> <pre><code>use serde::{Serialize, Deserialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct MyMessage {\n    data: String,\n}\n\nimpl Message for MyMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"my_message\";\n}\n</code></pre>"},{"location":"components/rt/api/#messageenvelope","title":"MessageEnvelope","text":"<p>Messages are wrapped in envelopes for routing:</p> <pre><code>pub struct MessageEnvelope&lt;M: Message&gt; {\n    /// The actual message payload\n    pub payload: M,\n\n    /// Optional sender address for reply capability\n    pub sender: Option&lt;ActorAddress&gt;,\n\n    /// Optional recipient for reply-to pattern\n    pub reply_to: Option&lt;ActorAddress&gt;,\n\n    /// Message creation timestamp (UTC)\n    pub timestamp: DateTime&lt;Utc&gt;,\n\n    /// Optional correlation ID for request/response tracking\n    pub correlation_id: Option&lt;Uuid&gt;,\n\n    /// Message priority (extracted from payload)\n    pub priority: MessagePriority,\n\n    /// Optional time-to-live in seconds\n    pub ttl: Option&lt;u64&gt;,\n}\n\nimpl&lt;M: Message&gt; MessageEnvelope&lt;M&gt; {\n    /// Create new envelope with current timestamp\n    pub fn new(payload: M) -&gt; Self;\n\n    /// Builder methods for adding metadata\n    pub fn with_sender(self, sender: ActorAddress) -&gt; Self;\n    pub fn with_reply_to(self, reply_to: ActorAddress) -&gt; Self;\n    pub fn with_correlation_id(self, id: Uuid) -&gt; Self;\n    pub fn with_ttl(self, ttl_seconds: u64) -&gt; Self;\n\n    /// Check if message has expired based on TTL\n    pub fn is_expired(&amp;self) -&gt; bool;\n}\n</code></pre>"},{"location":"components/rt/api/#messageid","title":"MessageId","text":"<p>Unique identifier for messages:</p> <pre><code>pub struct MessageId(uuid::Uuid);\n\nimpl MessageId {\n    pub fn new() -&gt; Self;\n}\n</code></pre>"},{"location":"components/rt/api/#broker-api","title":"Broker API","text":""},{"location":"components/rt/api/#messagebroker-trait","title":"MessageBroker Trait","text":"<p>Pub/sub system for actor communication:</p> <pre><code>#[async_trait]\npub trait MessageBroker&lt;M: Message&gt;: Clone + Send + Sync + 'static {\n    type Error: Error + Send + Sync + 'static;\n\n    /// Publish a message to all subscribers\n    async fn publish(&amp;self, envelope: MessageEnvelope&lt;M&gt;) \n        -&gt; Result&lt;(), Self::Error&gt;;\n\n    /// Subscribe to messages (returns a stream)\n    async fn subscribe(&amp;self) \n        -&gt; Result&lt;MessageStream&lt;M&gt;, Self::Error&gt;;\n\n    /// Request-reply pattern with timeout\n    async fn request&lt;R: Message&gt;(\n        &amp;self,\n        envelope: MessageEnvelope&lt;M&gt;,\n        timeout: Duration,\n    ) -&gt; Result&lt;MessageEnvelope&lt;R&gt;, Self::Error&gt;;\n} \n        -&gt; Result&lt;mpsc::Receiver&lt;MessageEnvelope&lt;M&gt;&gt;, Self::Error&gt;;\n}\n</code></pre>"},{"location":"components/rt/api/#inmemorymessagebroker","title":"InMemoryMessageBroker","text":"<p>Current broker implementation:</p> <pre><code>use airssys_rt::broker::InMemoryMessageBroker;\n\nlet broker = InMemoryMessageBroker::&lt;MyMessage&gt;::new();\n</code></pre>"},{"location":"components/rt/api/#mailbox-api","title":"Mailbox API","text":""},{"location":"components/rt/api/#mailbox-types","title":"Mailbox Types","text":"<p>Two mailbox implementations are provided:</p> <p>UnboundedMailbox: <pre><code>use airssys_rt::mailbox::UnboundedMailbox;\n\nlet mailbox = UnboundedMailbox::&lt;MyMessage&gt;::new();\n</code></pre></p> <p>BoundedMailbox: <pre><code>use airssys_rt::mailbox::{BoundedMailbox, BackpressureStrategy};\n\nlet mailbox = BoundedMailbox::&lt;MyMessage&gt;::new(\n    100,  // capacity\n    BackpressureStrategy::Block,\n);\n</code></pre></p>"},{"location":"components/rt/api/#backpressurestrategy","title":"BackpressureStrategy","text":"<p>Control behavior when mailbox is full:</p> <pre><code>pub enum BackpressureStrategy {\n    Block,      // Block sender when mailbox full\n    Drop,       // Drop new messages when full\n    DropOldest, // Drop oldest message to make room\n}\n</code></pre>"},{"location":"components/rt/api/#mailbox-traits","title":"Mailbox Traits","text":"<p>Generic interfaces for mailboxes:</p> <pre><code>#[async_trait]\npub trait MailboxReceiver&lt;M: Message&gt;: Send {\n    async fn recv(&amp;mut self) -&gt; Option&lt;MessageEnvelope&lt;M&gt;&gt;;\n    fn try_recv(&amp;mut self) -&gt; Result&lt;MessageEnvelope&lt;M&gt;, TryRecvError&gt;;\n}\n\n#[async_trait]\npub trait MailboxSender&lt;M: Message&gt;: Clone + Send + Sync {\n    async fn send(&amp;self, envelope: MessageEnvelope&lt;M&gt;) \n        -&gt; Result&lt;(), MailboxError&gt;;\n}\n</code></pre>"},{"location":"components/rt/api/#supervisor-api","title":"Supervisor API","text":""},{"location":"components/rt/api/#child-trait","title":"Child Trait","text":"<p>Any entity can be supervised by implementing <code>Child</code>:</p> <pre><code>#[async_trait]\npub trait Child: Send + Sync {\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt;;\n    async fn stop(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt;;\n    async fn health_check(&amp;self) -&gt; ChildHealth;\n}\n</code></pre> <p>Note: Actors automatically implement <code>Child</code> via blanket implementation.</p>"},{"location":"components/rt/api/#childspec","title":"ChildSpec","text":"<p>Configuration for supervised children:</p> <pre><code>pub struct ChildSpec {\n    pub id: ChildId,\n    pub restart_policy: RestartPolicy,\n    pub shutdown_policy: ShutdownPolicy,\n    pub significant: bool,\n}\n</code></pre>"},{"location":"components/rt/api/#restartpolicy","title":"RestartPolicy","text":"<p>Control when children should be restarted:</p> <pre><code>pub enum RestartPolicy {\n    Permanent,   // Always restart on failure\n    Transient,   // Restart only on abnormal termination\n    Temporary,   // Never restart\n}\n</code></pre>"},{"location":"components/rt/api/#restartstrategy","title":"RestartStrategy","text":"<p>Choose how supervisor handles child failures:</p> <pre><code>// OneForOne - Restart only the failed child\nuse airssys_rt::supervisor::OneForOne;\nlet strategy = OneForOne::new();\n\n// OneForAll - Restart all children when one fails\nuse airssys_rt::supervisor::OneForAll;\nlet strategy = OneForAll::new();\n\n// RestForOne - Restart failed child and those started after it\nuse airssys_rt::supervisor::RestForOne;\nlet strategy = RestForOne::new();\n</code></pre>"},{"location":"components/rt/api/#supervisornode","title":"SupervisorNode","text":"<p>Create and manage supervision trees:</p> <pre><code>use airssys_rt::supervisor::{SupervisorNode, SupervisorId};\n\nlet mut supervisor = SupervisorNode::new(\n    SupervisorId::new(),\n    OneForOne::new(),\n);\n\nsupervisor.add_child(child_spec, child_instance).await?;\nsupervisor.start_all_children().await?;\n</code></pre>"},{"location":"components/rt/api/#childhealth","title":"ChildHealth","text":"<p>Health status for monitored actors:</p> <pre><code>pub enum ChildHealth {\n    Healthy,\n    Unhealthy(String),  // Contains error message\n}\n</code></pre>"},{"location":"components/rt/api/#addressing-api","title":"Addressing API","text":""},{"location":"components/rt/api/#actoraddress","title":"ActorAddress","text":"<p>Identify actors by address:</p> <pre><code>pub struct ActorAddress {\n    // Implementation details hidden\n}\n\nimpl ActorAddress {\n    /// Create anonymous address (UUID-based)\n    pub fn anonymous() -&gt; Self;\n\n    /// Create named address\n    pub fn named(name: impl Into&lt;String&gt;) -&gt; Self;\n\n    /// Get actor ID\n    pub fn id(&amp;self) -&gt; &amp;ActorId;\n\n    /// Get actor name (if any)\n    pub fn name(&amp;self) -&gt; Option&lt;&amp;str&gt;;\n}\n</code></pre>"},{"location":"components/rt/api/#actorid","title":"ActorId","text":"<p>Unique identifier using UUIDs:</p> <pre><code>pub struct ActorId(uuid::Uuid);\n\nimpl ActorId {\n    pub fn new() -&gt; Self;\n}\n</code></pre>"},{"location":"components/rt/api/#complete-api-example","title":"Complete API Example","text":"<p>Here's a complete example using the real APIs:</p> <pre><code>use airssys_rt::{\n    Actor, ActorContext, Message, ErrorAction,\n    broker::{InMemoryMessageBroker, MessageBroker},\n    util::ActorAddress,\n};\nuse async_trait::async_trait;\nuse serde::{Serialize, Deserialize};\nuse std::fmt;\n\n// 1. Define message\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct WorkMessage {\n    task: String,\n}\n\nimpl Message for WorkMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"work\";\n}\n\n// 2. Define actor\nstruct WorkerActor {\n    completed: usize,\n}\n\n// 3. Define error\n#[derive(Debug)]\nstruct WorkerError(String);\n\nimpl fmt::Display for WorkerError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        write!(f, \"WorkerError: {}\", self.0)\n    }\n}\n\nimpl std::error::Error for WorkerError {}\n\n// 4. Implement Actor trait\n#[async_trait]\nimpl Actor for WorkerActor {\n    type Message = WorkMessage;\n    type Error = WorkerError;\n\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"Worker {} starting\", \n            context.address().name().unwrap_or(\"anonymous\"));\n        Ok(())\n    }\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"Processing: {}\", message.task);\n        self.completed += 1;\n        context.record_message();\n        Ok(())\n    }\n\n    async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        error: Self::Error,\n        _context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; ErrorAction {\n        eprintln!(\"Error occurred: {}\", error);\n        ErrorAction::Restart\n    }\n}\n\n// 5. Use the actor\nasync fn run_actor() {\n    let address = ActorAddress::named(\"worker-1\");\n    let broker = InMemoryMessageBroker::new();\n    let mut context = ActorContext::new(address, broker);\n\n    let mut actor = WorkerActor { completed: 0 };\n\n    // Start actor\n    actor.pre_start(&amp;mut context).await.unwrap();\n\n    // Handle message\n    let message = WorkMessage { task: \"job-1\".to_string() };\n    actor.handle_message(message, &amp;mut context).await.unwrap();\n\n    println!(\"Messages processed: {}\", context.message_count());\n}\n</code></pre>"},{"location":"components/rt/api/#further-reading","title":"Further Reading","text":"<ul> <li>Generated Rustdoc: Run <code>cargo doc --open --package airssys-rt</code> for complete API documentation</li> <li>Examples: See <code>examples/</code> directory for real, working code</li> <li>Architecture: Read Core Concepts for design principles</li> <li>Implementation Guide: See Implementation for practical usage patterns</li> </ul> <p>All APIs documented here are implemented and tested. See the working examples for complete usage patterns.</p>"},{"location":"components/rt/architecture/","title":"Architecture Overview","text":"<p>This section provides comprehensive documentation of <code>airssys-rt</code>'s architecture, covering the fundamental design principles, core components, and system organization that make up the actor runtime.</p>"},{"location":"components/rt/architecture/#architectural-philosophy","title":"Architectural Philosophy","text":"<p><code>airssys-rt</code> is designed around the proven actor model principles from Erlang/OTP, adapted for Rust's type system and performance characteristics. The architecture emphasizes:</p> <ul> <li>Isolation: Each actor maintains private state with no shared memory</li> <li>Message Passing: Asynchronous communication through immutable messages</li> <li>Fault Tolerance: Hierarchical supervision for automatic recovery</li> <li>Scalability: Lightweight virtual processes for high concurrency</li> </ul>"},{"location":"components/rt/architecture/#system-components","title":"System Components","text":""},{"location":"components/rt/architecture/#virtual-process-management","title":"Virtual Process Management","text":"<p>The runtime manages lightweight virtual processes (not OS processes) that serve as execution contexts for actors. Each virtual process encapsulates: - Unique process identifier (PID) - Private actor state - Message mailbox - Supervision relationships</p>"},{"location":"components/rt/architecture/#actor-model-implementation","title":"Actor Model Implementation","text":"<p>The actor model provides the programming interface for building concurrent applications: - Actor Trait: Core interface for message handling - Message Types: Strongly-typed communication protocols - Lifecycle Management: Actor creation, execution, and termination - State Encapsulation: Private actor state with controlled access</p>"},{"location":"components/rt/architecture/#supervision-framework","title":"Supervision Framework","text":"<p>Hierarchical fault tolerance through supervisor trees: - Supervisor Actors: Monitor and manage child actors - Restart Strategies: Configurable failure recovery policies - Error Propagation: Structured error handling and escalation - System Resilience: Automatic recovery from component failures</p>"},{"location":"components/rt/architecture/#message-passing-system","title":"Message Passing System","text":"<p>Efficient asynchronous communication infrastructure: - Mailbox Queues: Per-actor message queues with backpressure - Message Routing: Efficient delivery to target actors - Zero-Copy Optimization: Ownership transfer for performance - Type Safety: Compile-time message type verification</p>"},{"location":"components/rt/architecture/#architecture-sections","title":"Architecture Sections","text":"<p>The architecture documentation is organized into the following detailed sections:</p>"},{"location":"components/rt/architecture/#core-concepts","title":"Core Concepts","text":"<p>Fundamental concepts and terminology used throughout the system: - Virtual processes and their characteristics - Actor model principles and implementation - Message passing semantics and patterns - Supervision tree organization - System architecture layers and performance considerations</p>"},{"location":"components/rt/architecture/#actor-model-design","title":"Actor Model Design","text":"<p>Detailed design of the actor programming model: - Actor trait architecture and lifecycle - Message design patterns and type safety - State management and encapsulation - Communication patterns and best practices - Performance optimizations and error handling</p>"},{"location":"components/rt/architecture/#message-passing-system_1","title":"Message Passing System","text":"<p>In-depth coverage of the message passing infrastructure: - Mailbox implementation and queuing strategies - Message routing and delivery mechanisms - Performance optimizations and zero-copy techniques - Backpressure and flow control</p>"},{"location":"components/rt/architecture/#supervisor-trees","title":"Supervisor Trees","text":"<p>Comprehensive supervision and fault tolerance design: - Supervision hierarchy and relationships - Restart strategies and policies - Error handling and recovery mechanisms - System-wide resilience patterns</p>"},{"location":"components/rt/architecture/#process-lifecycle","title":"Process Lifecycle","text":"<p>Complete actor lifecycle management: - Actor spawning and initialization - Execution phases and state transitions - Graceful shutdown and cleanup - Resource management and optimization</p>"},{"location":"components/rt/architecture/#design-principles","title":"Design Principles","text":""},{"location":"components/rt/architecture/#1-type-safety-first","title":"1. Type Safety First","text":"<p>Leverage Rust's type system to prevent common concurrency errors: - Compile-time message type verification - Actor state ownership and borrowing - Safe inter-actor communication - Memory safety without garbage collection</p>"},{"location":"components/rt/architecture/#2-performance-by-design","title":"2. Performance by Design","text":"<p>Optimize for high-throughput, low-latency scenarios: - Minimal per-actor memory overhead (&lt;1KB) - Zero-copy message passing where possible - Efficient scheduling and context switching - Integration with Tokio's async runtime</p>"},{"location":"components/rt/architecture/#3-fault-tolerance-as-default","title":"3. Fault Tolerance as Default","text":"<p>Build resilience into the system architecture: - Automatic failure detection and recovery - Hierarchical error handling and escalation - Isolation of failures to prevent cascading - Self-healing system characteristics</p>"},{"location":"components/rt/architecture/#4-ergonomic-apis","title":"4. Ergonomic APIs","text":"<p>Provide clean, intuitive interfaces for developers: - Minimal boilerplate for common patterns - Clear error handling and diagnostics - Comprehensive documentation and examples - Integration with Rust ecosystem tools</p>"},{"location":"components/rt/architecture/#integration-points","title":"Integration Points","text":""},{"location":"components/rt/architecture/#airssys-ecosystem","title":"AirsSys Ecosystem","text":"<p>Integration with other AirsSys components: - airssys-osl: OS-level operations and security context - airssys-wasm: WebAssembly component hosting (planned) - Shared Standards: Common error handling and logging patterns</p>"},{"location":"components/rt/architecture/#rust-ecosystem","title":"Rust Ecosystem","text":"<p>Compatibility with standard Rust tools and libraries: - Tokio Runtime: Async/await foundation and scheduling - Serde: Message serialization and configuration - Tracing: Observability and debugging support - Standard Library: File I/O, networking, and system APIs</p>"},{"location":"components/rt/architecture/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"components/rt/architecture/#scalability-targets","title":"Scalability Targets","text":"<ul> <li>Concurrent Actors: 10,000+ per runtime instance</li> <li>Message Throughput: 1M+ messages/second under optimal conditions</li> <li>Memory Efficiency: &lt;1KB baseline overhead per actor</li> <li>Startup Time: &lt;100\u03bcs for actor creation and initialization</li> </ul>"},{"location":"components/rt/architecture/#latency-goals","title":"Latency Goals","text":"<ul> <li>Message Delivery: &lt;1ms for local actor communication</li> <li>Actor Spawning: &lt;100\u03bcs from request to ready state</li> <li>Supervision Response: &lt;10ms for failure detection and restart</li> <li>System Overhead: &lt;5% CPU overhead for runtime management</li> </ul> <p>The architecture documentation provides the foundation for understanding how <code>airssys-rt</code> implements the actor model in Rust while maintaining high performance and strong fault tolerance guarantees.</p>"},{"location":"components/rt/chapter_1/","title":"Chapter 1","text":""},{"location":"components/rt/explanation/","title":"Explanation","text":"<p>This section provides understanding-oriented documentation that deepens your knowledge of <code>airssys-rt</code> concepts, design decisions, and architectural rationale.</p>"},{"location":"components/rt/explanation/#topics","title":"Topics","text":"<ul> <li>Future Use Cases - Conceptual examples and planned application patterns</li> <li>Design Philosophy - Core principles and architectural decisions (planned)</li> <li>Comparison with Other Runtimes - How airssys-rt differs from alternatives (planned)</li> </ul> <p>[!NOTE] This section contains conceptual and forward-looking content. For current working examples, see the Implementation Guide.</p>"},{"location":"components/rt/guides/","title":"How-To Guides","text":"<p>Task-oriented guides that show you how to accomplish specific goals.</p> <p>How-To Guides provide practical directions for solving real-world problems. Each guide: - Addresses a specific task or problem - Provides executable instructions - Assumes you know what you want to achieve - Adapts to real-world complexity and use-cases - Focuses on practical usability over completeness</p>"},{"location":"components/rt/guides/#available-guides","title":"Available Guides","text":""},{"location":"components/rt/guides/#actor-development","title":"Actor Development","text":""},{"location":"components/rt/guides/#actor-development-guide","title":"Actor Development Guide","text":"<p>Comprehensive guide to developing actors with best practices, lifecycle management, error handling, and testing strategies.</p> <p>What you'll learn: - Actor trait implementation patterns - Lifecycle hook usage (pre_start, post_stop, on_error) - Message handling best practices - Error handling and recovery - Testing actors effectively</p>"},{"location":"components/rt/guides/#supervision","title":"Supervision","text":""},{"location":"components/rt/guides/#supervisor-patterns-guide","title":"Supervisor Patterns Guide","text":"<p>Learn how to design and implement fault-tolerant supervision trees using different supervision strategies.</p> <p>What you'll learn: - Supervision strategy selection (OneForOne, OneForAll, RestForOne) - Restart policy configuration (Permanent, Transient, Temporary) - Supervisor tree design patterns - Child specification setup - Monitoring integration</p>"},{"location":"components/rt/guides/#messaging","title":"Messaging","text":""},{"location":"components/rt/guides/#message-passing-guide","title":"Message Passing Guide","text":"<p>Master message design, performance optimization, and communication patterns between actors.</p> <p>What you'll learn: - Message type design patterns - Performance optimization (small messages, Arc, batching) - Request/reply patterns - Pub/sub messaging via MessageBroker - Backpressure handling"},{"location":"components/rt/guides/#how-to-use-these-guides","title":"How to Use These Guides","text":""},{"location":"components/rt/guides/#if-you-want-to","title":"If you want to...","text":"<p>Build a new actor: \u2192 Start with Actor Development Guide</p> <p>Add supervision to your system: \u2192 See Supervisor Patterns Guide</p> <p>Optimize message passing: \u2192 Read Message Passing Guide</p> <p>Implement a specific pattern: \u2192 Check the examples in <code>examples/</code> directory: - <code>worker_pool.rs</code> - Load-balanced worker pool - <code>event_pipeline.rs</code> - Event processing pipeline - <code>examples/README.md</code> - Complete catalog</p>"},{"location":"components/rt/guides/#related-resources","title":"Related Resources","text":"<ul> <li>Tutorials: If you need to learn fundamentals first, see Tutorials</li> <li>Examples: Working code for common patterns in <code>examples/</code> directory</li> <li>API Reference: Detailed API specifications in Reference</li> <li>Explanation: Understand the \"why\" behind patterns in Explanation</li> </ul>"},{"location":"components/rt/guides/#diataxis-framework","title":"Di\u00e1taxis Framework","text":"<p>This section follows the How-To Guides category of the Di\u00e1taxis framework: - Purpose: Directions to guide readers through problems to achieve specific goals - User Need: \"I need to accomplish this specific task\" - Focus: Solving real-world problems for competent users - Approach: Practical, executable instructions adaptable to use-cases</p>"},{"location":"components/rt/implementation/","title":"Implementation Guide","text":"<p>This guide provides practical, step-by-step instructions for building applications with <code>airssys-rt</code>. All examples are based on the actual implementation and working code from the <code>examples/</code> directory.</p>"},{"location":"components/rt/implementation/#quick-start","title":"Quick Start","text":""},{"location":"components/rt/implementation/#add-dependency","title":"Add Dependency","text":"<p>Add <code>airssys-rt</code> to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nairssys-rt = { path = \"../airssys-rt\" }  # or version from crates.io when published\nasync-trait = \"0.1\"\ntokio = { version = \"1.47\", features = [\"full\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\n</code></pre>"},{"location":"components/rt/implementation/#your-first-actor","title":"Your First Actor","text":"<p>Create a simple counter actor (from <code>examples/actor_basic.rs</code>):</p> <pre><code>use airssys_rt::{Actor, ActorContext, Message};\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\n\n// 1. Define your message type\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct CounterMessage {\n    delta: i32,\n}\n\nimpl Message for CounterMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"counter\";\n}\n\n// 2. Define your actor\nstruct CounterActor {\n    value: i32,\n    max_value: i32,\n}\n\n// 3. Define error type\n#[derive(Debug)]\nstruct CounterError {\n    message: String,\n}\n\nimpl std::fmt::Display for CounterError {\n    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {\n        write!(f, \"CounterError: {}\", self.message)\n    }\n}\n\nimpl std::error::Error for CounterError {}\n\n// 4. Implement the Actor trait\n#[async_trait]\nimpl Actor for CounterActor {\n    type Message = CounterMessage;\n    type Error = CounterError;\n\n    async fn handle_message&lt;B: airssys_rt::broker::MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        self.value += message.delta;\n\n        if self.value &gt; self.max_value {\n            return Err(CounterError {\n                message: format!(\"Value {} exceeds maximum {}\", \n                    self.value, self.max_value),\n            });\n        }\n\n        context.record_message();\n        Ok(())\n    }\n}\n</code></pre> <p>Run the complete example: <pre><code>cargo run --example actor_basic\n</code></pre></p>"},{"location":"components/rt/implementation/#actor-lifecycle-hooks","title":"Actor Lifecycle Hooks","text":"<p>Actors can override lifecycle hooks for initialization and cleanup (from <code>examples/actor_lifecycle.rs</code>):</p> <pre><code>#[async_trait]\nimpl Actor for CounterActor {\n    type Message = CounterMessage;\n    type Error = CounterError;\n\n    // Called before actor starts processing messages\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\n            \"[Actor {}] Starting with initial value: {}\",\n            context.address().name().unwrap_or(\"anonymous\"),\n            self.value\n        );\n        // Initialize resources here (e.g., database connections)\n        Ok(())\n    }\n\n    // Called when actor stops\n    async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\n            \"[Actor {}] Stopping with final value: {} (processed {} messages)\",\n            context.address().name().unwrap_or(\"anonymous\"),\n            self.value,\n            context.message_count()\n        );\n        // Cleanup resources here (e.g., close connections)\n        Ok(())\n    }\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        // Message handling logic\n        self.value += message.delta;\n        context.record_message();\n        Ok(())\n    }\n}\n</code></pre> <p>Run the lifecycle example: <pre><code>cargo run --example actor_lifecycle\n</code></pre></p>"},{"location":"components/rt/implementation/#error-handling-and-supervision","title":"Error Handling and Supervision","text":""},{"location":"components/rt/implementation/#erroraction-for-fault-tolerance","title":"ErrorAction for Fault Tolerance","text":"<p>Actors return <code>ErrorAction</code> from <code>on_error</code> to control supervision behavior:</p> <pre><code>use airssys_rt::ErrorAction;\n\n#[async_trait]\nimpl Actor for CounterActor {\n    type Message = CounterMessage;\n    type Error = CounterError;\n\n    async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        error: Self::Error,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; ErrorAction {\n        eprintln!(\"[Actor {}] Error: {}\", \n            context.address().name().unwrap_or(\"anonymous\"), \n            error);\n\n        // Supervisor will restart this actor\n        ErrorAction::Restart\n    }\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        self.value += message.delta;\n\n        if self.value &gt; self.max_value {\n            return Err(CounterError {\n                message: format!(\"Value {} exceeds maximum\", self.value),\n            });\n        }\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"components/rt/implementation/#building-supervisor-trees","title":"Building Supervisor Trees","text":"<p>Create supervisors to manage child actors (from <code>examples/supervisor_basic.rs</code>):</p> <pre><code>use airssys_rt::supervisor::{\n    Child, ChildHealth, ChildSpec, RestartPolicy, \n    ShutdownPolicy, SupervisorNode, OneForOne\n};\nuse async_trait::async_trait;\n\n// 1. Define a worker that implements Child\nstruct SimpleWorker {\n    id: String,\n}\n\n#[async_trait]\nimpl Child for SimpleWorker {\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        println!(\"Worker {} started\", self.id);\n        Ok(())\n    }\n\n    async fn stop(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        println!(\"Worker {} stopped\", self.id);\n        Ok(())\n    }\n\n    async fn health_check(&amp;self) -&gt; ChildHealth {\n        ChildHealth::Healthy\n    }\n}\n\n// 2. Create supervisor and add children\nasync fn create_supervisor() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n    let mut supervisor = SupervisorNode::new(\n        SupervisorId::new(),\n        OneForOne::new(),  // Restart strategy\n    );\n\n    // Add a child worker\n    supervisor.add_child(\n        ChildSpec {\n            id: ChildId::new(),\n            restart_policy: RestartPolicy::Permanent,\n            shutdown_policy: ShutdownPolicy::default(),\n            significant: true,\n        },\n        Box::new(SimpleWorker {\n            id: \"worker-1\".to_string(),\n        }),\n    ).await?;\n\n    // Start all children\n    supervisor.start_all_children().await?;\n\n    Ok(())\n}\n</code></pre> <p>Run the supervisor example: <pre><code>cargo run --example supervisor_basic\n</code></pre></p>"},{"location":"components/rt/implementation/#restart-strategies","title":"Restart Strategies","text":"<p>Choose the appropriate strategy for your use case (from <code>examples/supervisor_strategies.rs</code>):</p> <p>OneForOne - Restart only the failed child: <pre><code>use airssys_rt::supervisor::OneForOne;\n\nlet supervisor = SupervisorNode::new(\n    SupervisorId::new(),\n    OneForOne::new(),\n);\n</code></pre></p> <p>OneForAll - Restart all children when one fails: <pre><code>use airssys_rt::supervisor::OneForAll;\n\nlet supervisor = SupervisorNode::new(\n    SupervisorId::new(),\n    OneForAll::new(),\n);\n</code></pre></p> <p>RestForOne - Restart failed child and those started after it: <pre><code>use airssys_rt::supervisor::RestForOne;\n\nlet supervisor = SupervisorNode::new(\n    SupervisorId::new(),\n    RestForOne::new(),\n);\n</code></pre></p> <p>Run the strategies example: <pre><code>cargo run --example supervisor_strategies\n</code></pre></p>"},{"location":"components/rt/implementation/#actor-monitoring","title":"Actor Monitoring","text":""},{"location":"components/rt/implementation/#health-checks","title":"Health Checks","text":"<p>Implement health checking for supervised actors (from <code>examples/supervisor_automatic_health.rs</code>):</p> <pre><code>use airssys_rt::supervisor::{Child, ChildHealth, HealthConfig};\n\nstruct MonitoredWorker {\n    is_healthy: bool,\n}\n\n#[async_trait]\nimpl Child for MonitoredWorker {\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        self.is_healthy = true;\n        Ok(())\n    }\n\n    async fn stop(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        self.is_healthy = false;\n        Ok(())\n    }\n\n    async fn health_check(&amp;self) -&gt; ChildHealth {\n        if self.is_healthy {\n            ChildHealth::Healthy\n        } else {\n            ChildHealth::Unhealthy(\"Worker is unhealthy\".to_string())\n        }\n    }\n}\n\n// Configure automatic health monitoring\nlet health_config = HealthConfig {\n    check_interval: Duration::from_secs(5),\n    unhealthy_threshold: 3,\n    restart_on_unhealthy: true,\n};\n</code></pre> <p>Run the health monitoring example: <pre><code>cargo run --example supervisor_automatic_health\n</code></pre></p>"},{"location":"components/rt/implementation/#monitoring-system","title":"Monitoring System","text":"<p>Use the monitoring system to track actor metrics (from <code>examples/monitoring_basic.rs</code> and <code>examples/monitoring_supervisor.rs</code>):</p> <pre><code>use airssys_rt::monitoring::{ActorMonitor, MonitoringConfig};\n\n// Monitor individual actors\nlet monitor = ActorMonitor::new(MonitoringConfig::default());\n\n// Monitor supervisors\ncargo run --example monitoring_basic\ncargo run --example monitoring_supervisor\n</code></pre>"},{"location":"components/rt/implementation/#integration-with-airssys-osl","title":"Integration with AirsSys OSL","text":"<p>Integrate with <code>airssys-osl</code> for secure system operations (from <code>examples/osl_integration_example.rs</code>):</p> <pre><code>use airssys_osl::prelude::*;\nuse airssys_rt::{Actor, ActorContext, Message};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nenum FileMessage {\n    ReadFile { path: String },\n    WriteFile { path: String, content: String },\n}\n\nimpl Message for FileMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"file_operation\";\n}\n\nstruct FileActor {\n    executor: OslExecutor,\n}\n\n#[async_trait]\nimpl Actor for FileActor {\n    type Message = FileMessage;\n    type Error = FileError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        match message {\n            FileMessage::ReadFile { path } =&gt; {\n                // Use OSL for secure file operations\n                let content = self.executor.read_file(&amp;path)?;\n                println!(\"Read {} bytes from {}\", content.len(), path);\n                Ok(())\n            }\n            FileMessage::WriteFile { path, content } =&gt; {\n                self.executor.write_file(&amp;path, content.as_bytes())?;\n                println!(\"Wrote to {}\", path);\n                Ok(())\n            }\n        }\n    }\n}\n</code></pre> <p>Run the OSL integration example: <pre><code>cargo run --example osl_integration_example\n</code></pre></p>"},{"location":"components/rt/implementation/#complete-examples-reference","title":"Complete Examples Reference","text":"<p>All working examples are in the <code>examples/</code> directory:</p> Example Description Run Command <code>actor_basic.rs</code> Basic actor implementation <code>cargo run --example actor_basic</code> <code>actor_lifecycle.rs</code> Lifecycle hooks (pre_start, post_stop) <code>cargo run --example actor_lifecycle</code> <code>supervisor_basic.rs</code> Basic supervision patterns <code>cargo run --example supervisor_basic</code> <code>supervisor_strategies.rs</code> Restart strategies comparison <code>cargo run --example supervisor_strategies</code> <code>supervisor_automatic_health.rs</code> Automatic health monitoring <code>cargo run --example supervisor_automatic_health</code> <code>monitoring_basic.rs</code> Actor monitoring basics <code>cargo run --example monitoring_basic</code> <code>monitoring_supervisor.rs</code> Supervisor monitoring <code>cargo run --example monitoring_supervisor</code> <code>osl_integration_example.rs</code> OSL integration for file operations <code>cargo run --example osl_integration_example</code>"},{"location":"components/rt/implementation/#next-steps","title":"Next Steps","text":"<ol> <li>Explore Examples: Run each example to see the runtime in action</li> <li>Build Your Actor: Start with <code>actor_basic.rs</code> as a template</li> <li>Add Supervision: Use <code>supervisor_basic.rs</code> for fault tolerance</li> <li>Monitor Health: Implement health checks for production readiness</li> <li>Integrate OSL: Use <code>osl_integration_example.rs</code> for system operations</li> </ol> <p>All examples demonstrate real, production-ready patterns using the actual <code>airssys-rt</code> implementation.</p>"},{"location":"components/rt/reference/","title":"Reference","text":"<p>Technical specifications and authoritative information about the AirsSys-RT system.</p> <p>Reference documentation provides neutral, objective descriptions of the system's machinery. Each reference page: - Describes and only describes (no instruction or explanation) - Adopts standard patterns for consistency - Respects the structure of the code itself - States facts, lists features, provides warnings - Serves as authoritative technical documentation</p>"},{"location":"components/rt/reference/#api-reference","title":"API Reference","text":"<p>Detailed specifications for all public APIs, organized by module:</p> <ul> <li>Core Types - Fundamental types (ActorId, ActorRef, ActorContext, ActorSystem)</li> <li>Actor Traits - Actor trait and lifecycle methods</li> <li>Message Types - Message trait, Envelope, MessageMetadata</li> <li>Supervisor API - Supervisor trait, configuration, builders</li> </ul>"},{"location":"components/rt/reference/#performance-reference","title":"Performance Reference","text":"<p>Performance characteristics and benchmarking data:</p> <ul> <li>Baseline Performance: Actor spawn (625ns), Message latency (737ns), Throughput (4.7M msg/sec)</li> <li>Scaling Characteristics: Linear scaling with 6% overhead (1\u219250 actors)</li> <li>Resource Usage: Memory footprint, CPU utilization patterns</li> </ul> <p>Note: Full performance guide will be available at <code>reference/performance.md</code></p>"},{"location":"components/rt/reference/#troubleshooting","title":"Troubleshooting","text":"<p>Common errors, debugging techniques, and problem resolution:</p> <ul> <li>Compilation errors and solutions</li> <li>Runtime error diagnosis</li> <li>Performance issue investigation  </li> <li>Common pitfalls and how to avoid them</li> </ul> <p>Note: Full troubleshooting guide will be available at <code>reference/troubleshooting.md</code></p>"},{"location":"components/rt/reference/#how-to-use-reference-documentation","title":"How to Use Reference Documentation","text":""},{"location":"components/rt/reference/#looking-for-specific-api-information","title":"Looking for specific API information?","text":"<p>\u2192 Navigate to the relevant API reference page \u2192 Use browser search (Ctrl+F / Cmd+F) to find specific types or methods</p>"},{"location":"components/rt/reference/#need-to-understand-how-something-works","title":"Need to understand how something works?","text":"<p>\u2192 Reference tells you what it is \u2192 For why and how to use, see Explanation and How-To Guides</p>"},{"location":"components/rt/reference/#comparing-options-or-features","title":"Comparing options or features?","text":"<p>\u2192 Reference provides neutral descriptions \u2192 For recommendations and tradeoffs, see Explanation</p>"},{"location":"components/rt/reference/#rustdoc-api-documentation","title":"Rustdoc API Documentation","text":"<p>For automatically generated API documentation, run:</p> <pre><code>cargo doc --open --no-deps\n</code></pre> <p>This provides: - Complete type signatures - Method documentation - Implementation details - Source code links</p>"},{"location":"components/rt/reference/#related-resources","title":"Related Resources","text":"<ul> <li>How-To Guides: Task-oriented instructions at Guides</li> <li>Tutorials: Learning-oriented exercises at Tutorials</li> <li>Explanation: Understanding-oriented content at Explanation</li> <li>Examples: Working code in <code>examples/</code> directory with <code>examples/README.md</code> catalog</li> </ul>"},{"location":"components/rt/reference/#diataxis-framework","title":"Di\u00e1taxis Framework","text":"<p>This section follows the Reference category of the Di\u00e1taxis framework: - Purpose: Technical descriptions of the machinery and how to operate it - User Need: \"I need accurate, authoritative information about this\" - Focus: Information-oriented, describes the product - Approach: Austere, uncompromising, wholly authoritative</p>"},{"location":"components/rt/researches/","title":"Research Overview","text":"<p>This section contains comprehensive research and analysis that forms the foundation of <code>airssys-rt</code>'s architectural design. Our approach is grounded in thorough understanding of both the Erlang/BEAM runtime model and the current Rust concurrency ecosystem.</p>"},{"location":"components/rt/researches/#research-methodology","title":"Research Methodology","text":"<p>Our research follows a systematic approach to understand and adapt proven concurrency patterns:</p> <ol> <li>Source Analysis: Deep dive into BEAM runtime architecture and OTP patterns</li> <li>Ecosystem Survey: Comprehensive analysis of existing Rust actor frameworks</li> <li>Gap Analysis: Identification of missing capabilities and opportunities</li> <li>Design Synthesis: Translation of BEAM principles to Rust-native patterns</li> </ol>"},{"location":"components/rt/researches/#key-research-documents","title":"Key Research Documents","text":"<p>Our research is organized into comprehensive analyses that inform every architectural decision:</p>"},{"location":"components/rt/researches/#beam-model-analysis","title":"BEAM Model Analysis","text":"<p>A comprehensive examination of the Erlang/BEAM runtime system, covering: - Fundamental Architecture: Virtual machine design and core components - Actor Model Implementation: How BEAM implements encapsulation and message passing - Process Isolation: Memory management and fault containment strategies - Preemptive Scheduling: Reduction-based fairness and responsiveness - Supervision Philosophy: \"Let it crash\" principles and recovery mechanisms</p> <p>Key Insights: - BEAM's success comes from integrated system design, not individual features - Process isolation through separate heaps is fundamental to fault tolerance - Preemptive scheduling ensures fairness under all workload conditions - Supervision trees enable self-healing system architectures</p>"},{"location":"components/rt/researches/#beam-inspired-runtime-implementation","title":"BEAM-Inspired Runtime Implementation","text":"<p>An in-depth architectural analysis and practical implementation guide covering: - Architectural Blueprints: Core design patterns from BEAM to Rust translation - Critical Design Decisions: Trade-offs between performance and BEAM-fidelity - Implementation Roadmap: Phased approach to building a production-ready runtime - Technology Integration: Leveraging Rust ecosystem while maintaining BEAM principles</p> <p>Key Insights: - Hybrid scheduling models can combine cooperative and preemptive benefits - WebAssembly provides promising path for true process isolation - Supervision must be runtime-integrated, not just library-level - Hot code loading requires fundamental architecture considerations</p>"},{"location":"components/rt/researches/#rust-actor-ecosystem-analysis","title":"Rust Actor Ecosystem Analysis","text":"<p>Comprehensive analysis of existing Rust actor frameworks and their design decisions: - Framework Comparison: Detailed analysis of Actix, Ractor, Bastion, Riker, and Xactor - Architectural Patterns: Common design approaches and their trade-offs - Performance Characteristics: Benchmarking and scalability analysis - Lessons Learned: Successful patterns and common pitfalls to avoid</p> <p>Key Insights: - Channel-based message passing is the proven standard approach - Runtime-integrated supervision enables better optimization than library-level - Type safety and zero-cost abstractions are crucial for adoption - Long-term maintenance and ecosystem support are critical success factors</p>"},{"location":"components/rt/researches/#research-findings-summary","title":"Research Findings Summary","text":""},{"location":"components/rt/researches/#validated-approaches","title":"\u2705 Validated Approaches","text":"<ul> <li>Actor Model Adaptation: Rust's ownership system provides natural state encapsulation</li> <li>Message Passing: Zero-copy semantics through ownership transfer</li> <li>Supervisor Integration: Runtime-aware supervision enables robust fault tolerance</li> <li>Tokio Foundation: Async/await provides solid base for cooperative scheduling</li> </ul>"},{"location":"components/rt/researches/#key-challenges-identified","title":"\u26a0\ufe0f Key Challenges Identified","text":"<ul> <li>Scheduling Model: Cooperative vs. preemptive trade-offs for fairness</li> <li>Process Isolation: Logical vs. physical memory boundaries</li> <li>Message Semantics: Move vs. clone for true \"share nothing\" behavior</li> <li>Hot Code Loading: Dynamic library limitations in Rust ecosystem</li> </ul>"},{"location":"components/rt/researches/#innovation-opportunities","title":"\ud83d\ude80 Innovation Opportunities","text":"<ul> <li>Hybrid Scheduling: Adaptive scheduling based on workload characteristics</li> <li>Tiered Isolation: Multiple isolation levels based on security requirements</li> <li>Type-Safe Messages: Leveraging Rust's type system for message safety</li> <li>Performance Optimization: Zero-cost abstractions for actor overhead</li> </ul>"},{"location":"components/rt/researches/#design-principles-derived-from-research","title":"Design Principles Derived from Research","text":""},{"location":"components/rt/researches/#1-pragmatic-beam-adaptation","title":"1. Pragmatic BEAM Adaptation","text":"<p>Not a clone, but a thoughtful adaptation that: - Preserves essential fault tolerance patterns - Leverages Rust's strengths (type safety, performance) - Integrates with existing async ecosystem - Focuses on system programming use cases</p>"},{"location":"components/rt/researches/#2-layered-architecture","title":"2. Layered Architecture","text":"<pre><code>// High-level: Application actors and supervision\nApplication Layer\n    \u2193\n// Mid-level: Actor runtime and message routing  \nRuntime Layer\n    \u2193\n// Low-level: Scheduling and memory management\nSystem Layer\n    \u2193\n// Foundation: Tokio and OS integration\nPlatform Layer\n</code></pre>"},{"location":"components/rt/researches/#3-progressive-complexity","title":"3. Progressive Complexity","text":"<p>Start simple, add sophistication incrementally: - Basic actor model with cooperative scheduling - Supervision trees and fault tolerance - Advanced scheduling and optimization - Distribution and hot code loading</p>"},{"location":"components/rt/researches/#research-informed-architectural-decisions","title":"Research-Informed Architectural Decisions","text":""},{"location":"components/rt/researches/#scheduling-strategy","title":"Scheduling Strategy","text":"<p>Decision: Hybrid cooperative-preemptive model - Rationale: Leverages Tokio ecosystem while enabling fairness guarantees - Implementation: Adaptive scheduling based on actor behavior patterns</p>"},{"location":"components/rt/researches/#isolation-model","title":"Isolation Model","text":"<p>Decision: Tiered isolation with logical default - Rationale: Performance by default, strong isolation when needed - Implementation: Multiple isolation levels (logical \u2192 sandboxed \u2192 process-based)</p>"},{"location":"components/rt/researches/#message-passing","title":"Message Passing","text":"<p>Decision: Zero-copy with optional cloning - Rationale: Rust-native performance with BEAM-compatible semantics - Implementation: Ownership transfer by default, explicit copying for isolation</p>"},{"location":"components/rt/researches/#supervision-integration","title":"Supervision Integration","text":"<p>Decision: Runtime-native supervision - Rationale: Enables deep integration and optimization - Implementation: Process registry maintains supervision hierarchy</p>"},{"location":"components/rt/researches/#validation-through-prototyping","title":"Validation Through Prototyping","text":"<p>Our research includes practical validation through: - Micro-benchmarks: Performance characteristics of different approaches - Prototype implementations: Feasibility testing of key concepts - Integration testing: Compatibility with Tokio and async ecosystem - Load testing: Scalability under high concurrency conditions</p>"},{"location":"components/rt/researches/#future-research-directions","title":"Future Research Directions","text":""},{"location":"components/rt/researches/#near-term-next-6-months","title":"Near-term (Next 6 months)","text":"<ul> <li>Performance optimization strategies for message passing</li> <li>Advanced scheduling algorithms for mixed workloads</li> <li>Integration patterns with airssys-osl security framework</li> </ul>"},{"location":"components/rt/researches/#medium-term-6-12-months","title":"Medium-term (6-12 months)","text":"<ul> <li>Distribution protocols and consensus mechanisms</li> <li>Hot code loading safety and state migration</li> <li>Advanced fault tolerance patterns beyond supervision trees</li> </ul>"},{"location":"components/rt/researches/#long-term-12-months","title":"Long-term (12+ months)","text":"<ul> <li>WebAssembly integration for maximum isolation</li> <li>Domain-specific optimizations for system programming</li> <li>Ecosystem standardization and interoperability</li> </ul>"},{"location":"components/rt/researches/#research-validation","title":"Research Validation","text":"<p>All architectural decisions in <code>airssys-rt</code> are backed by: - Literature review of actor model implementations - Empirical analysis of BEAM runtime behavior - Comparative benchmarking of Rust actor frameworks - Prototype validation of core concepts</p> <p>This research-driven approach ensures that <code>airssys-rt</code> is built on solid theoretical foundations while being optimized for practical system programming applications.</p>"},{"location":"components/rt/tutorials/","title":"Tutorials","text":"<p>Learning-oriented guides that take you through practical exercises step-by-step.</p> <p>Tutorials are designed for learning by doing. Each tutorial: - Has a clear learning objective - Provides step-by-step instructions - Delivers visible results early and often - Focuses on acquisition of skills and knowledge - Minimizes explanation (links to Explanation docs instead)</p>"},{"location":"components/rt/tutorials/#available-tutorials","title":"Available Tutorials","text":""},{"location":"components/rt/tutorials/#beginner-tutorials","title":"Beginner Tutorials","text":"<p>Start here if you're new to AirsSys-RT:</p>"},{"location":"components/rt/tutorials/#getting-started","title":"Getting Started","text":"<p>Your first steps with the runtime system. Install, configure, and run your first actor.</p>"},{"location":"components/rt/tutorials/#your-first-actor","title":"Your First Actor","text":"<p>Create a simple actor from scratch. Learn the Actor trait, message handling, and lifecycle hooks.</p>"},{"location":"components/rt/tutorials/#message-handling","title":"Message Handling","text":"<p>Understand how actors communicate through messages. Implement message types and handlers.</p>"},{"location":"components/rt/tutorials/#building-a-supervisor-tree","title":"Building a Supervisor Tree","text":"<p>Set up fault-tolerant supervisor hierarchies. Learn supervision strategies and restart policies.</p>"},{"location":"components/rt/tutorials/#learning-path","title":"Learning Path","text":"<p>We recommend following this order: 1. Getting Started - Set up your environment 2. Your First Actor - Learn Actor fundamentals 3. Message Handling - Master actor communication 4. Building a Supervisor Tree - Add fault tolerance</p>"},{"location":"components/rt/tutorials/#after-tutorials","title":"After Tutorials","text":"<p>Once you've completed these tutorials: - Explore How-To Guides for task-specific instructions - Read Explanation docs to deepen your understanding - Reference API Documentation for detailed specifications</p>"},{"location":"components/rt/tutorials/#related-resources","title":"Related Resources","text":"<ul> <li>Examples: See <code>examples/</code> directory for working code</li> <li><code>examples/actor_basic.rs</code> - Reinforces \"Your First Actor\"</li> <li><code>examples/supervisor_basic.rs</code> - Reinforces \"Building a Supervisor Tree\"</li> <li><code>examples/README.md</code> - Complete example catalog with learning progression</li> <li>How-To Guides: Practical solutions to specific problems</li> <li>Architecture: System design and component overview</li> </ul>"},{"location":"components/rt/tutorials/#diataxis-framework","title":"Di\u00e1taxis Framework","text":"<p>This section follows the Tutorials category of the Di\u00e1taxis framework: - Purpose: Learning experiences through practical steps - User Need: \"I want to learn by doing something meaningful\" - Focus: Skill acquisition and knowledge building - Approach: Teacher-student relationship with guided exercises</p>"},{"location":"components/rt/api/actor-traits/","title":"Actor Traits","text":"<p>This section documents the core traits that define actor behavior in <code>airssys-rt</code>.</p>"},{"location":"components/rt/api/actor-traits/#actor-trait","title":"Actor Trait","text":"<p>The fundamental trait that all actors must implement.</p> <pre><code>#[async_trait]\npub trait Actor: Send + Sync + 'static {\n    /// The type of messages this actor handles\n    type Message: Message;\n\n    /// The error type for actor operations\n    type Error: Error + Send + Sync + 'static;\n\n    /// Handle an incoming message (REQUIRED)\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt;;\n\n    /// Lifecycle hook: called before actor starts (optional)\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        Ok(())\n    }\n\n    /// Lifecycle hook: called when actor stops (optional)\n    async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        Ok(())\n    }\n\n    /// Error handler: return supervision decision (optional)\n    async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        error: Self::Error,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; ErrorAction {\n        ErrorAction::Stop  // Default: stop the actor\n    }\n}\n</code></pre>"},{"location":"components/rt/api/actor-traits/#required-methods","title":"Required Methods","text":"<ul> <li><code>handle_message</code>: Process incoming messages. This is the core method where your actor's business logic lives.</li> </ul>"},{"location":"components/rt/api/actor-traits/#optional-methods","title":"Optional Methods","text":"<ul> <li> <p><code>pre_start</code>: Called once before the actor starts processing messages. Use for initialization (e.g., connecting to databases, loading resources).</p> </li> <li> <p><code>post_stop</code>: Called when the actor stops. Use for cleanup (e.g., closing connections, releasing resources).</p> </li> <li> <p><code>on_error</code>: Called when <code>handle_message</code> returns an error. Return an <code>ErrorAction</code> to control supervision behavior.</p> </li> </ul>"},{"location":"components/rt/api/actor-traits/#example","title":"Example","text":"<p>See <code>examples/actor_basic.rs</code> for a complete actor implementation.</p> <pre><code>use airssys_rt::{Actor, ActorContext, Message, ErrorAction};\nuse async_trait::async_trait;\nuse serde::{Serialize, Deserialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct MyMessage {\n    data: String,\n}\n\nimpl Message for MyMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"my_message\";\n}\n\nstruct MyActor {\n    state: i32,\n}\n\n#[async_trait]\nimpl Actor for MyActor {\n    type Message = MyMessage;\n    type Error = std::io::Error;\n\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"Actor {} starting\", context.address().name().unwrap_or(\"anonymous\"));\n        Ok(())\n    }\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"Processing: {}\", message.data);\n        self.state += 1;\n        context.record_message();\n        Ok(())\n    }\n\n    async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        error: Self::Error,\n        _context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; ErrorAction {\n        eprintln!(\"Error: {}\", error);\n        ErrorAction::Stop  // Stop on error (can customize based on error type)\n    }\n}\n</code></pre>"},{"location":"components/rt/api/actor-traits/#child-trait","title":"Child Trait","text":"<p>Trait for entities that can be supervised.</p> <pre><code>#[async_trait]\npub trait Child: Send + Sync {\n    /// Start the child entity\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt;;\n\n    /// Stop the child entity\n    async fn stop(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt;;\n\n    /// Check the health status\n    async fn health_check(&amp;self) -&gt; ChildHealth;\n}\n</code></pre> <p>Note: Actors automatically implement <code>Child</code> via a blanket implementation, so you don't need to implement this manually for actors.</p>"},{"location":"components/rt/api/actor-traits/#example-custom-child","title":"Example (Custom Child)","text":"<pre><code>use airssys_rt::supervisor::{Child, ChildHealth};\nuse async_trait::async_trait;\n\nstruct Worker {\n    id: String,\n}\n\n#[async_trait]\nimpl Child for Worker {\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        println!(\"Worker {} started\", self.id);\n        Ok(())\n    }\n\n    async fn stop(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        println!(\"Worker {} stopped\", self.id);\n        Ok(())\n    }\n\n    async fn health_check(&amp;self) -&gt; ChildHealth {\n        ChildHealth::Healthy\n    }\n}\n</code></pre> <p>See <code>examples/supervisor_basic.rs</code> for complete usage.</p>"},{"location":"components/rt/api/actor-traits/#messagebroker-trait","title":"MessageBroker Trait","text":"<p>Trait for message routing and pub/sub.</p> <pre><code>#[async_trait]\npub trait MessageBroker&lt;M: Message&gt;: Clone + Send + Sync + 'static {\n    type Error: Error + Send + Sync + 'static;\n\n    /// Publish a message to all subscribers\n    async fn publish(&amp;self, envelope: MessageEnvelope&lt;M&gt;) \n        -&gt; Result&lt;(), Self::Error&gt;;\n\n    /// Subscribe to messages for an actor\n    async fn subscribe(&amp;self, subscriber_id: ActorId) \n        -&gt; Result&lt;mpsc::Receiver&lt;MessageEnvelope&lt;M&gt;&gt;, Self::Error&gt;;\n}\n</code></pre>"},{"location":"components/rt/api/actor-traits/#implementations","title":"Implementations","text":"<ul> <li><code>InMemoryMessageBroker&lt;M&gt;</code>: Default in-memory implementation using channels</li> </ul>"},{"location":"components/rt/api/actor-traits/#example_1","title":"Example","text":"<pre><code>use airssys_rt::broker::InMemoryMessageBroker;\n\nlet broker = InMemoryMessageBroker::&lt;MyMessage&gt;::new();\n</code></pre>"},{"location":"components/rt/api/actor-traits/#mailbox-traits","title":"Mailbox Traits","text":""},{"location":"components/rt/api/actor-traits/#mailboxreceiver","title":"MailboxReceiver","text":"<pre><code>#[async_trait]\npub trait MailboxReceiver&lt;M: Message&gt;: Send {\n    /// Receive next message (blocking)\n    async fn recv(&amp;mut self) -&gt; Option&lt;MessageEnvelope&lt;M&gt;&gt;;\n\n    /// Try to receive message (non-blocking)\n    fn try_recv(&amp;mut self) -&gt; Result&lt;MessageEnvelope&lt;M&gt;, TryRecvError&gt;;\n}\n</code></pre>"},{"location":"components/rt/api/actor-traits/#mailboxsender","title":"MailboxSender","text":"<pre><code>#[async_trait]\npub trait MailboxSender&lt;M: Message&gt;: Clone + Send + Sync {\n    /// Send a message to the mailbox\n    async fn send(&amp;self, envelope: MessageEnvelope&lt;M&gt;) \n        -&gt; Result&lt;(), MailboxError&gt;;\n}\n</code></pre>"},{"location":"components/rt/api/actor-traits/#implementations_1","title":"Implementations","text":"<ul> <li><code>UnboundedMailbox&lt;M&gt;</code>: Unlimited capacity mailbox</li> <li><code>BoundedMailbox&lt;M&gt;</code>: Fixed capacity mailbox with backpressure</li> </ul> <p>All traits use <code>async_trait</code> for async method support. See the generated Rustdoc (<code>cargo doc --open</code>) for complete trait documentation.</p>"},{"location":"components/rt/api/core-types/","title":"Core Types","text":"<p>This section documents the core types used throughout <code>airssys-rt</code>.</p>"},{"location":"components/rt/api/core-types/#actoraddress","title":"ActorAddress","text":"<p>Unique identifier and optional name for actors.</p> <p>Type: Enum with two variants</p> <pre><code>pub enum ActorAddress {\n    /// Named actor with string identifier\n    Named { id: ActorId, name: String },\n    /// Anonymous actor with only ID\n    Anonymous { id: ActorId },\n}\n</code></pre>"},{"location":"components/rt/api/core-types/#methods","title":"Methods","text":"<pre><code>impl ActorAddress {\n    /// Create an anonymous address (UUID-based)\n    pub fn anonymous() -&gt; Self;\n\n    /// Create a named address\n    pub fn named(name: impl Into&lt;String&gt;) -&gt; Self;\n\n    /// Get the actor's ID\n    pub fn id(&amp;self) -&gt; &amp;ActorId;\n\n    /// Get the actor's name (if named variant)\n    pub fn name(&amp;self) -&gt; Option&lt;&amp;str&gt;;\n\n    /// Check if this is a named address\n    pub fn is_named(&amp;self) -&gt; bool;\n\n    /// Check if this is an anonymous address\n    pub fn is_anonymous(&amp;self) -&gt; bool;\n}\n</code></pre>"},{"location":"components/rt/api/core-types/#example","title":"Example","text":"<pre><code>use airssys_rt::util::ActorAddress;\n\n// Anonymous actor\nlet addr1 = ActorAddress::anonymous();\nassert!(addr1.is_anonymous());\n\n// Named actor\nlet addr2 = ActorAddress::named(\"worker-1\");\nassert!(addr2.is_named());\nassert_eq!(addr2.name(), Some(\"worker-1\"));\n\n// Pattern matching on variants\nmatch addr2 {\n    ActorAddress::Named { id, name } =&gt; {\n        println!(\"Named actor: {} with ID: {:?}\", name, id);\n    }\n    ActorAddress::Anonymous { id } =&gt; {\n        println!(\"Anonymous actor with ID: {:?}\", id);\n    }\n}\n</code></pre>"},{"location":"components/rt/api/core-types/#actorid","title":"ActorId","text":"<p>Unique identifier for actors using UUIDs.</p> <pre><code>pub struct ActorId(uuid::Uuid);\n</code></pre>"},{"location":"components/rt/api/core-types/#methods_1","title":"Methods","text":"<pre><code>impl ActorId {\n    /// Generate a new unique actor ID\n    pub fn new() -&gt; Self;\n}\n</code></pre>"},{"location":"components/rt/api/core-types/#traits","title":"Traits","text":"<p>Implements: <code>Clone</code>, <code>Copy</code>, <code>Debug</code>, <code>PartialEq</code>, <code>Eq</code>, <code>Hash</code></p>"},{"location":"components/rt/api/core-types/#actorstate","title":"ActorState","text":"<p>Lifecycle states for actors.</p> <pre><code>pub enum ActorState {\n    Starting,   // Actor is initializing\n    Running,    // Actor is active and processing messages\n    Stopping,   // Actor is shutting down\n    Stopped,    // Actor has stopped successfully\n    Failed,     // Actor has failed (requires supervision)\n}\n</code></pre>"},{"location":"components/rt/api/core-types/#example_1","title":"Example","text":"<pre><code>use airssys_rt::ActorState;\n\nlet state = ActorState::Running;\nassert_eq!(state, ActorState::Running);\n</code></pre>"},{"location":"components/rt/api/core-types/#actorlifecycle","title":"ActorLifecycle","text":"<p>Tracks actor lifecycle state and transitions.</p> <pre><code>pub struct ActorLifecycle {\n    state: ActorState,\n    last_state_change: DateTime&lt;Utc&gt;,\n    restart_count: u32,\n}\n</code></pre>"},{"location":"components/rt/api/core-types/#methods_2","title":"Methods","text":"<pre><code>impl ActorLifecycle {\n    /// Create new lifecycle tracker\n    pub fn new() -&gt; Self;\n\n    /// Get current state\n    pub fn state(&amp;self) -&gt; ActorState;\n\n    /// Transition to new state\n    pub fn transition_to(&amp;mut self, new_state: ActorState);\n\n    /// Get restart count\n    pub fn restart_count(&amp;self) -&gt; u32;\n\n    /// Get last state change timestamp\n    pub fn last_state_change(&amp;self) -&gt; DateTime&lt;Utc&gt;;\n\n    /// Check if in terminal state (Stopped or Failed)\n    pub fn is_terminal(&amp;self) -&gt; bool;\n\n    /// Check if currently running\n    pub fn is_running(&amp;self) -&gt; bool;\n}\n</code></pre>"},{"location":"components/rt/api/core-types/#example_2","title":"Example","text":"<pre><code>use airssys_rt::{ActorLifecycle, ActorState};\n\nlet mut lifecycle = ActorLifecycle::new();\nassert_eq!(lifecycle.state(), ActorState::Starting);\n\nlifecycle.transition_to(ActorState::Running);\nassert!(lifecycle.is_running());\n</code></pre>"},{"location":"components/rt/api/core-types/#erroraction","title":"ErrorAction","text":"<p>Control supervision behavior when actor errors occur.</p> <pre><code>pub enum ErrorAction {\n    Resume,     // Continue processing (ignore error)\n    Restart,    // Restart the actor\n    Stop,       // Stop the actor permanently\n    Escalate,   // Pass error to supervisor\n}\n</code></pre>"},{"location":"components/rt/api/core-types/#example_3","title":"Example","text":"<pre><code>use airssys_rt::ErrorAction;\n\nasync fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    error: Self::Error,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; ErrorAction {\n    match error {\n        MyError::Temporary =&gt; ErrorAction::Resume,\n        MyError::Recoverable =&gt; ErrorAction::Restart,\n        MyError::Fatal =&gt; ErrorAction::Stop,\n        _ =&gt; ErrorAction::Escalate,\n    }\n}\n</code></pre>"},{"location":"components/rt/api/core-types/#messageid","title":"MessageId","text":"<p>Unique identifier for messages using UUIDs.</p> <pre><code>pub struct MessageId(uuid::Uuid);\n</code></pre>"},{"location":"components/rt/api/core-types/#methods_3","title":"Methods","text":"<pre><code>impl MessageId {\n    /// Generate a new unique message ID\n    pub fn new() -&gt; Self;\n}\n</code></pre>"},{"location":"components/rt/api/core-types/#childid","title":"ChildId","text":"<p>Unique identifier for supervised children.</p> <pre><code>pub struct ChildId(uuid::Uuid);\n</code></pre>"},{"location":"components/rt/api/core-types/#methods_4","title":"Methods","text":"<pre><code>impl ChildId {\n    /// Generate a new unique child ID\n    pub fn new() -&gt; Self;\n}\n</code></pre>"},{"location":"components/rt/api/core-types/#supervisorid","title":"SupervisorId","text":"<p>Unique identifier for supervisors.</p> <pre><code>pub struct SupervisorId(uuid::Uuid);\n</code></pre>"},{"location":"components/rt/api/core-types/#methods_5","title":"Methods","text":"<pre><code>impl SupervisorId {\n    /// Generate a new unique supervisor ID\n    pub fn new() -&gt; Self;\n}\n</code></pre> <p>All core types are defined in the respective modules and exported through the prelude for convenient access.</p>"},{"location":"components/rt/api/message-types/","title":"Message Types","text":"<p>This section documents the message system types in <code>airssys-rt</code>.</p>"},{"location":"components/rt/api/message-types/#message-trait","title":"Message Trait","text":"<p>All messages must implement this trait.</p> <pre><code>pub trait Message: Send + Sync + Clone + Debug + 'static {\n    const MESSAGE_TYPE: &amp;'static str;\n\n    fn priority(&amp;self) -&gt; MessagePriority {\n        MessagePriority::Normal\n    }\n}\n</code></pre>"},{"location":"components/rt/api/message-types/#requirements","title":"Requirements","text":"<ul> <li><code>Clone</code>: Messages can be cloned for broadcasting</li> <li><code>Send + Sync + 'static</code>: Messages can be sent across threads</li> <li><code>Debug</code>: Messages can be debugged and logged</li> <li><code>MESSAGE_TYPE</code>: Unique string identifier for the message type</li> <li><code>priority()</code>: Optional method to override message priority (default: Normal)</li> </ul> <p>Note: <code>Serialize + Deserialize</code> are NOT required by the trait. Add them only when you need serialization (e.g., for network transport or persistence).</p>"},{"location":"components/rt/api/message-types/#example-without-serialization","title":"Example Without Serialization","text":"<pre><code>use airssys_rt::Message;\n\n#[derive(Debug, Clone)]\nstruct CounterMessage {\n    delta: i32,\n}\n\nimpl Message for CounterMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"counter\";\n}\n</code></pre>"},{"location":"components/rt/api/message-types/#example-with-serialization","title":"Example With Serialization","text":"<pre><code>use airssys_rt::Message;\nuse serde::{Serialize, Deserialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct CounterMessage {\n    delta: i32,\n}\n\nimpl Message for CounterMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"counter\";\n}\n</code></pre>"},{"location":"components/rt/api/message-types/#example-with-priority","title":"Example With Priority","text":"<pre><code>use airssys_rt::message::{Message, MessagePriority};\n\n#[derive(Debug, Clone)]\nstruct ShutdownMessage;\n\nimpl Message for ShutdownMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"shutdown\";\n\n    fn priority(&amp;self) -&gt; MessagePriority {\n        MessagePriority::Critical  // Processed before other messages\n    }\n}\n</code></pre>"},{"location":"components/rt/api/message-types/#messageenvelope","title":"MessageEnvelope","text":"<p>Wrapper for messages with metadata.</p> <pre><code>pub struct MessageEnvelope&lt;M: Message&gt; {\n    /// The actual message payload\n    pub payload: M,\n\n    /// Optional sender address for reply capability\n    pub sender: Option&lt;ActorAddress&gt;,\n\n    /// Optional recipient for reply-to pattern\n    pub reply_to: Option&lt;ActorAddress&gt;,\n\n    /// Message creation timestamp (UTC)\n    pub timestamp: DateTime&lt;Utc&gt;,\n\n    /// Optional correlation ID for request/response tracking\n    pub correlation_id: Option&lt;Uuid&gt;,\n\n    /// Message priority (extracted from payload)\n    pub priority: MessagePriority,\n\n    /// Optional time-to-live in seconds\n    pub ttl: Option&lt;u64&gt;,\n}\n</code></pre>"},{"location":"components/rt/api/message-types/#methods","title":"Methods","text":"<pre><code>impl&lt;M: Message&gt; MessageEnvelope&lt;M&gt; {\n    /// Create new envelope with current timestamp\n    pub fn new(payload: M) -&gt; Self;\n\n    /// Builder methods for adding metadata\n    pub fn with_sender(self, sender: ActorAddress) -&gt; Self;\n    pub fn with_reply_to(self, reply_to: ActorAddress) -&gt; Self;\n    pub fn with_correlation_id(self, id: Uuid) -&gt; Self;\n    pub fn with_ttl(self, ttl_seconds: u64) -&gt; Self;\n\n    /// Check if message has expired based on TTL\n    pub fn is_expired(&amp;self) -&gt; bool;\n\n    /// Get message type string\n    pub fn message_type(&amp;self) -&gt; &amp;'static str;\n}\n</code></pre>"},{"location":"components/rt/api/message-types/#fields","title":"Fields","text":"<ul> <li><code>payload</code>: The actual message (generic type M)</li> <li><code>sender</code>: Optional sender address for replies</li> <li><code>reply_to</code>: Optional recipient for reply messages</li> <li><code>timestamp</code>: Message creation time (UTC, using chrono DateTime) <li><code>correlation_id</code>: Optional UUID for request/response tracking</li> <li><code>priority</code>: Message priority (from payload.priority())</li> <li><code>ttl</code>: Optional time-to-live in seconds</li>"},{"location":"components/rt/api/message-types/#example","title":"Example","text":"<pre><code>use airssys_rt::message::MessageEnvelope;\nuse airssys_rt::util::ActorAddress;\nuse uuid::Uuid;\n\nlet message = MyMessage { data: \"hello\".to_string() };\nlet sender = ActorAddress::named(\"sender\");\n\nlet envelope = MessageEnvelope::new(message)\n    .with_sender(sender)\n    .with_correlation_id(Uuid::new_v4())\n    .with_ttl(60); // 60 seconds TTL\n\nprintln!(\"Message type: {}\", envelope.message_type());\nprintln!(\"Timestamp: {}\", envelope.timestamp);\nprintln!(\"Expired: {}\", envelope.is_expired());\n</code></pre>"},{"location":"components/rt/api/message-types/#messageid","title":"MessageId","text":"<p>Unique identifier for messages.</p> <pre><code>pub struct MessageId(uuid::Uuid);\n</code></pre>"},{"location":"components/rt/api/message-types/#methods_1","title":"Methods","text":"<pre><code>impl MessageId {\n    /// Generate a new unique message ID\n    pub fn new() -&gt; Self;\n}\n</code></pre>"},{"location":"components/rt/api/message-types/#traits","title":"Traits","text":"<p>Implements: <code>Clone</code>, <code>Copy</code>, <code>Debug</code>, <code>PartialEq</code>, <code>Eq</code>, <code>Hash</code></p>"},{"location":"components/rt/api/message-types/#message-patterns","title":"Message Patterns","text":""},{"location":"components/rt/api/message-types/#simple-messages","title":"Simple Messages","text":"<p>Messages without responses:</p> <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct LogMessage {\n    level: String,\n    text: String,\n}\n\nimpl Message for LogMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"log\";\n}\n</code></pre>"},{"location":"components/rt/api/message-types/#request-response-pattern","title":"Request-Response Pattern","text":"<p>Messages that need responses (future feature):</p> <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct CalculateRequest {\n    x: i32,\n    y: i32,\n}\n\nimpl Message for CalculateRequest {\n    const MESSAGE_TYPE: &amp;'static str = \"calculate\";\n}\n\n// Response would be sent via separate mechanism\n</code></pre>"},{"location":"components/rt/api/message-types/#event-messages","title":"Event Messages","text":"<p>Messages for event broadcasting:</p> <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct UserCreatedEvent {\n    user_id: String,\n    timestamp: DateTime&lt;Utc&gt;,\n}\n\nimpl Message for UserCreatedEvent {\n    const MESSAGE_TYPE: &amp;'static str = \"user.created\";\n}\n</code></pre>"},{"location":"components/rt/api/message-types/#message-design-guidelines","title":"Message Design Guidelines","text":""},{"location":"components/rt/api/message-types/#1-keep-messages-small","title":"1. Keep Messages Small","text":"<p>Messages are cloned, so keep them lightweight:</p> <pre><code>// Good: Small, focused message\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct FilePathMessage {\n    path: String,\n}\n\n// Avoid: Large data in messages\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct FileDataMessage {\n    data: Vec&lt;u8&gt;,  // Could be megabytes!\n}\n</code></pre> <p>For large data, consider using <code>Arc</code>:</p> <pre><code>use std::sync::Arc;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct SharedDataMessage {\n    #[serde(skip)]  // Skip serialization for Arc\n    data: Arc&lt;Vec&lt;u8&gt;&gt;,\n}\n</code></pre>"},{"location":"components/rt/api/message-types/#2-use-descriptive-names","title":"2. Use Descriptive Names","text":"<p>Message type strings should be clear and unique:</p> <pre><code>impl Message for UserMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"user.action\";  // Good: namespaced\n}\n</code></pre>"},{"location":"components/rt/api/message-types/#3-version-your-messages","title":"3. Version Your Messages","text":"<p>For evolving systems, consider message versioning:</p> <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct UserMessageV2 {\n    version: u32,\n    data: String,\n}\n\nimpl Message for UserMessageV2 {\n    const MESSAGE_TYPE: &amp;'static str = \"user.v2\";\n}\n</code></pre>"},{"location":"components/rt/api/message-types/#complete-example","title":"Complete Example","text":"<pre><code>use airssys_rt::{Actor, ActorContext, Message, MessageBroker};\nuse async_trait::async_trait;\nuse serde::{Serialize, Deserialize};\n\n// Define message\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct WorkMessage {\n    task_id: String,\n    priority: u8,\n}\n\nimpl Message for WorkMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"work\";\n}\n\n// Use in actor\nstruct WorkerActor;\n\n#[async_trait]\nimpl Actor for WorkerActor {\n    type Message = WorkMessage;\n    type Error = std::io::Error;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"Processing task {} (priority: {})\", \n            message.task_id, message.priority);\n        context.record_message();\n        Ok(())\n    }\n}\n</code></pre> <p>See <code>examples/actor_basic.rs</code> for complete working examples.</p>"},{"location":"components/rt/api/supervisor-api/","title":"Supervisor API","text":"<p>This section documents the supervision and fault tolerance API in <code>airssys-rt</code>.</p>"},{"location":"components/rt/api/supervisor-api/#restartpolicy","title":"RestartPolicy","text":"<p>Defines when a child should be restarted after failure.</p> <pre><code>pub enum RestartPolicy {\n    Permanent,   // Always restart on failure\n    Transient,   // Restart only on abnormal termination\n    Temporary,   // Never restart\n}\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#usage","title":"Usage","text":"<pre><code>use airssys_rt::supervisor::RestartPolicy;\n\n// Critical service - always restart\nlet policy = RestartPolicy::Permanent;\n\n// Background task - restart only on crashes\nlet policy = RestartPolicy::Transient;\n\n// One-time operation - never restart\nlet policy = RestartPolicy::Temporary;\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#restartstrategy","title":"RestartStrategy","text":"<p>Defines how a supervisor handles child failures.</p>"},{"location":"components/rt/api/supervisor-api/#oneforone","title":"OneForOne","text":"<p>Restart only the failed child.</p> <pre><code>use airssys_rt::supervisor::OneForOne;\n\nlet strategy = OneForOne::new();\n</code></pre> <p>Use when: Children are independent and one child's failure doesn't affect others.</p>"},{"location":"components/rt/api/supervisor-api/#oneforall","title":"OneForAll","text":"<p>Restart all children when one fails.</p> <pre><code>use airssys_rt::supervisor::OneForAll;\n\nlet strategy = OneForAll::new();\n</code></pre> <p>Use when: Children are interdependent and must all restart together.</p>"},{"location":"components/rt/api/supervisor-api/#restforone","title":"RestForOne","text":"<p>Restart the failed child and all children started after it.</p> <pre><code>use airssys_rt::supervisor::RestForOne;\n\nlet strategy = RestForOne::new();\n</code></pre> <p>Use when: Children have startup dependencies (e.g., database \u2192 cache \u2192 API).</p>"},{"location":"components/rt/api/supervisor-api/#childspec","title":"ChildSpec","text":"<p>Configuration for a supervised child.</p> <p>Type: Generic struct with factory function</p> <pre><code>pub struct ChildSpec&lt;C, F&gt;\nwhere\n    F: Fn() -&gt; C + Send + Sync + 'static,\n{\n    /// Unique identifier for this child (for logging and monitoring)\n    pub id: String,\n\n    /// Factory function that creates new child instances\n    pub factory: F,\n\n    /// Restart policy determining when to restart this child\n    pub restart_policy: RestartPolicy,\n\n    /// Shutdown policy determining how to stop this child\n    pub shutdown_policy: ShutdownPolicy,\n\n    /// Maximum time to wait for child startup\n    pub start_timeout: Duration,\n\n    /// Maximum time to wait for child shutdown\n    pub shutdown_timeout: Duration,\n}\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#type-parameters","title":"Type Parameters","text":"<ul> <li><code>C</code>: Child type implementing the <code>Child</code> trait</li> <li><code>F</code>: Factory function type that creates new child instances</li> </ul>"},{"location":"components/rt/api/supervisor-api/#fields","title":"Fields","text":"<ul> <li><code>id</code>: String identifier for the child (not ChildId UUID)</li> <li><code>factory</code>: Closure that creates new child instances</li> <li><code>restart_policy</code>: When to restart the child</li> <li><code>shutdown_policy</code>: How to shutdown the child</li> <li><code>start_timeout</code>: Maximum time for child to start</li> <li><code>shutdown_timeout</code>: Maximum time for child to stop</li> </ul> <p>Note: The <code>significant</code> field does NOT exist in the implementation.</p>"},{"location":"components/rt/api/supervisor-api/#example","title":"Example","text":"<pre><code>use airssys_rt::supervisor::{ChildSpec, RestartPolicy, ShutdownPolicy};\nuse std::time::Duration;\n\nlet spec = ChildSpec {\n    id: \"worker-1\".into(),\n    factory: || MyWorker::new(),\n    restart_policy: RestartPolicy::Permanent,\n    shutdown_policy: ShutdownPolicy::Graceful(Duration::from_secs(5)),\n    start_timeout: Duration::from_secs(10),\n    shutdown_timeout: Duration::from_secs(10),\n};\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#shutdownpolicy","title":"ShutdownPolicy","text":"<p>Defines how a child should be shutdown.</p> <pre><code>pub enum ShutdownPolicy {\n    Graceful(Duration),\n    Immediate,\n    Infinity,\n}\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#variants","title":"Variants","text":"<ul> <li><code>Graceful(duration)</code>: Wait for graceful shutdown, force stop after timeout</li> <li><code>Immediate</code>: Immediately force stop (not \"Brutal\")</li> <li><code>Infinity</code>: Wait indefinitely for graceful shutdown</li> </ul>"},{"location":"components/rt/api/supervisor-api/#example_1","title":"Example","text":"<pre><code>use airssys_rt::supervisor::ShutdownPolicy;\nuse std::time::Duration;\n\n// Wait 5 seconds for graceful shutdown\nlet graceful = ShutdownPolicy::Graceful(Duration::from_secs(5));\n\n// Terminate immediately\nlet immediate = ShutdownPolicy::Immediate;\n\n// Wait forever\nlet infinity = ShutdownPolicy::Infinity;\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#childhealth","title":"ChildHealth","text":"<p>Health status of a supervised child.</p> <pre><code>pub enum ChildHealth {\n    Healthy,\n    Degraded(String),\n    Failed(String),\n}\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#variants_1","title":"Variants","text":"<ul> <li><code>Healthy</code>: Child is operating normally</li> <li><code>Degraded(message)</code>: Child is operational but showing signs of issues</li> <li><code>Failed(message)</code>: Child has failed and requires restart</li> </ul>"},{"location":"components/rt/api/supervisor-api/#example_2","title":"Example","text":"<pre><code>use airssys_rt::supervisor::{Child, ChildHealth};\n\n#[async_trait]\nimpl Child for MyWorker {\n    type Error = MyError;\n\n    async fn health_check(&amp;self) -&gt; ChildHealth {\n        if self.error_rate() &gt; 0.5 {\n            ChildHealth::Failed(\"Error rate too high\".into())\n        } else if self.error_rate() &gt; 0.1 {\n            ChildHealth::Degraded(\"Elevated error rate\".into())\n        } else {\n            ChildHealth::Healthy\n        }\n    }\n\n    // Required methods\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; { Ok(()) }\n    async fn stop(&amp;mut self, _timeout: Duration) -&gt; Result&lt;(), Self::Error&gt; { Ok(()) }\n}\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#child-trait","title":"Child Trait","text":"<p>Trait for entities that can be supervised.</p> <pre><code>#[async_trait]\npub trait Child: Send + Sync + 'static {\n    /// Error type for child lifecycle operations\n    type Error: Error + Send + Sync + 'static;\n\n    /// Start the child process\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt;;\n\n    /// Stop the child process gracefully\n    /// \n    /// # Parameters\n    /// - `timeout`: Maximum time to wait for graceful shutdown\n    async fn stop(&amp;mut self, timeout: Duration) -&gt; Result&lt;(), Self::Error&gt;;\n\n    /// Check the health status of the child (optional)\n    /// \n    /// Default implementation returns `ChildHealth::Healthy`\n    async fn health_check(&amp;self) -&gt; ChildHealth {\n        ChildHealth::Healthy\n    }\n}\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#required-methods","title":"Required Methods","text":"<ul> <li><code>start()</code>: Initialize and start the child (no timeout parameter)</li> <li><code>stop(timeout)</code>: Gracefully shutdown with timeout</li> </ul>"},{"location":"components/rt/api/supervisor-api/#optional-methods","title":"Optional Methods","text":"<ul> <li><code>health_check()</code>: Report health status (default: Healthy)</li> </ul> <p>Critical: The <code>stop()</code> method MUST accept a <code>timeout: Duration</code> parameter, not zero parameters as shown in some examples.</p>"},{"location":"components/rt/api/supervisor-api/#example-implementation","title":"Example Implementation","text":"<pre><code>use airssys_rt::supervisor::{Child, ChildHealth};\nuse async_trait::async_trait;\nuse std::time::Duration;\n\nstruct DatabaseWorker {\n    connected: bool,\n}\n\n#[derive(Debug)]\nstruct WorkerError(String);\n\nimpl std::fmt::Display for WorkerError {\n    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::error::Error for WorkerError {}\n\n#[async_trait]\nimpl Child for DatabaseWorker {\n    type Error = WorkerError;\n\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"Connecting to database...\");\n        self.connected = true;\n        Ok(())\n    }\n\n    async fn stop(&amp;mut self, timeout: Duration) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"Disconnecting from database (timeout: {:?})...\", timeout);\n        self.connected = false;\n        Ok(())\n    }\n\n    async fn health_check(&amp;self) -&gt; ChildHealth {\n        if self.connected {\n            ChildHealth::Healthy\n        } else {\n            ChildHealth::Failed(\"Not connected\".into())\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#supervisornode","title":"SupervisorNode","text":"<p>Main supervisor implementation.</p> <pre><code>pub struct SupervisorNode&lt;M, S&gt; \nwhere\n    M: Message,\n    S: SupervisionStrategy&lt;M&gt;,\n{\n    // Implementation details hidden\n}\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#methods","title":"Methods","text":"<pre><code>impl&lt;M: Message, S: SupervisionStrategy&lt;M&gt;&gt; SupervisorNode&lt;M, S&gt; {\n    /// Create a new supervisor\n    pub fn new(id: SupervisorId, strategy: S) -&gt; Self;\n\n    /// Add a child to supervise\n    pub async fn add_child(\n        &amp;mut self,\n        spec: ChildSpec,\n        child: Box&lt;dyn Child&gt;,\n    ) -&gt; Result&lt;(), SupervisorError&gt;;\n\n    /// Start all children\n    pub async fn start_all_children(&amp;mut self) -&gt; Result&lt;(), SupervisorError&gt;;\n\n    /// Stop all children\n    pub async fn stop_all_children(&amp;mut self) -&gt; Result&lt;(), SupervisorError&gt;;\n\n    /// Handle child failure\n    pub async fn handle_child_failure(\n        &amp;mut self,\n        child_id: &amp;ChildId,\n    ) -&gt; Result&lt;(), SupervisorError&gt;;\n}\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#example_3","title":"Example","text":"<pre><code>use airssys_rt::supervisor::{\n    SupervisorNode, SupervisorId, OneForOne,\n    ChildSpec, ChildId, RestartPolicy, ShutdownPolicy,\n};\n\nasync fn create_supervisor() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create supervisor with OneForOne strategy\n    let mut supervisor = SupervisorNode::new(\n        SupervisorId::new(),\n        OneForOne::new(),\n    );\n\n    // Add children\n    supervisor.add_child(\n        ChildSpec {\n            id: ChildId::new(),\n            restart_policy: RestartPolicy::Permanent,\n            shutdown_policy: ShutdownPolicy::default(),\n            significant: true,\n        },\n        Box::new(my_worker),\n    ).await?;\n\n    // Start all children\n    supervisor.start_all_children().await?;\n\n    Ok(())\n}\n</code></pre> <p>See <code>examples/supervisor_basic.rs</code> for complete implementation.</p>"},{"location":"components/rt/api/supervisor-api/#healthconfig","title":"HealthConfig","text":"<p>Configuration for automatic health monitoring.</p> <pre><code>pub struct HealthConfig {\n    pub check_interval: Duration,\n    pub unhealthy_threshold: u32,\n    pub restart_on_unhealthy: bool,\n}\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#example_4","title":"Example","text":"<pre><code>use airssys_rt::supervisor::HealthConfig;\nuse std::time::Duration;\n\nlet config = HealthConfig {\n    check_interval: Duration::from_secs(5),\n    unhealthy_threshold: 3,\n    restart_on_unhealthy: true,\n};\n</code></pre> <p>See <code>examples/supervisor_automatic_health.rs</code> for health monitoring.</p>"},{"location":"components/rt/api/supervisor-api/#supervisionstrategy-trait","title":"SupervisionStrategy Trait","text":"<p>Trait for implementing custom supervision strategies.</p> <pre><code>#[async_trait]\npub trait SupervisionStrategy&lt;M: Message&gt;: Send + Sync {\n    async fn handle_failure(\n        &amp;self,\n        context: &amp;mut StrategyContext&lt;M&gt;,\n        failed_child: &amp;ChildId,\n    ) -&gt; SupervisionDecision;\n}\n</code></pre> <p>Current implementations: <code>OneForOne</code>, <code>OneForAll</code>, <code>RestForOne</code></p>"},{"location":"components/rt/api/supervisor-api/#supervisiondecision","title":"SupervisionDecision","text":"<p>Result of supervision strategy decision.</p> <pre><code>pub enum SupervisionDecision {\n    Restart(Vec&lt;ChildId&gt;),  // List of children to restart\n    Escalate,               // Escalate to parent supervisor\n    Stop,                   // Stop supervision\n}\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#complete-supervision-example","title":"Complete Supervision Example","text":"<pre><code>use airssys_rt::supervisor::{\n    Child, ChildHealth, ChildSpec, ChildId,\n    RestartPolicy, ShutdownPolicy,\n    SupervisorNode, SupervisorId, OneForOne,\n};\nuse async_trait::async_trait;\nuse std::error::Error;\nuse std::time::Duration;\n\n// Define a worker\nstruct DatabaseWorker {\n    connected: bool,\n}\n\n#[derive(Debug)]\nstruct DbError(String);\n\nimpl std::fmt::Display for DbError {\n    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl std::error::Error for DbError {}\n\n#[async_trait]\nimpl Child for DatabaseWorker {\n    type Error = DbError;  // Must specify Error type\n\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"Connecting to database...\");\n        self.connected = true;\n        Ok(())\n    }\n\n    async fn stop(&amp;mut self, timeout: Duration) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"Disconnecting from database (timeout: {:?})...\", timeout);\n        self.connected = false;\n        Ok(())\n    }\n\n    async fn health_check(&amp;self) -&gt; ChildHealth {\n        if self.connected {\n            ChildHealth::Healthy\n        } else {\n            ChildHealth::Failed(\"Not connected\".to_string())\n        }\n    }\n}\n\n// Create supervised system\nasync fn setup() -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n    let mut supervisor = SupervisorNode::new(\n        SupervisorId::new(),\n        OneForOne::new(),\n    );\n\n    let spec = ChildSpec {\n        id: \"db-worker\".into(),\n        factory: || DatabaseWorker { connected: false },\n        restart_policy: RestartPolicy::Permanent,\n        shutdown_policy: ShutdownPolicy::Graceful(Duration::from_secs(5)),\n        start_timeout: Duration::from_secs(10),\n        shutdown_timeout: Duration::from_secs(10),\n    };\n\n    supervisor.add_child(spec).await?;\n    supervisor.start_all_children().await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/api/supervisor-api/#supervisor-hierarchy","title":"Supervisor Hierarchy","text":"<p>Supervisors can supervise other supervisors:</p> <pre><code>// Parent supervisor\nlet mut parent = SupervisorNode::new(\n    SupervisorId::new(),\n    OneForOne::new(),\n);\n\n// Child supervisor\nlet child_supervisor = SupervisorNode::new(\n    SupervisorId::new(),\n    RestForOne::new(),\n);\n\n// Add child supervisor as a child (via Child trait implementation)\nparent.add_child(\n    ChildSpec { /* ... */ },\n    Box::new(child_supervisor),\n).await?;\n</code></pre> <p>See the examples directory for complete supervision patterns: - <code>examples/supervisor_basic.rs</code> - Basic supervision - <code>examples/supervisor_strategies.rs</code> - Strategy comparison - <code>examples/supervisor_automatic_health.rs</code> - Health monitoring</p>"},{"location":"components/rt/architecture/actor-model/","title":"Actor Model Design","text":"<p>The actor model in <code>airssys-rt</code> provides a type-safe, performant implementation of the actor pattern based on Erlang/OTP principles.</p> <p>Note: All code examples are taken from the actual implementation. See examples directory for complete working code.</p>"},{"location":"components/rt/architecture/actor-model/#actor-trait-architecture","title":"Actor Trait Architecture","text":""},{"location":"components/rt/architecture/actor-model/#core-actor-trait","title":"Core Actor Trait","text":"<p>The foundational trait that all actors implement (from <code>src/actor/traits.rs</code>):</p> <pre><code>#[async_trait]\npub trait Actor: Send + Sync + 'static {\n    /// The type of messages this actor can handle.\n    type Message: Message;\n\n    /// The error type returned by actor operations.\n    type Error: Error + Send + Sync + 'static;\n\n    /// Handle an incoming message.\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt;;\n\n    /// Called when the actor is started (optional).\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        Ok(())\n    }\n\n    /// Called when the actor is stopping (optional).\n    async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        Ok(())\n    }\n\n    /// Handle errors and return supervision decision (optional).\n    async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        error: Self::Error,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; ErrorAction {\n        ErrorAction::Restart\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#design-principles","title":"Design Principles","text":"<ol> <li>Generic Constraints (\u00a76.2): Uses <code>&lt;B: MessageBroker&lt;Self::Message&gt;&gt;</code> instead of <code>dyn</code> trait objects</li> <li>Associated Types: <code>Message</code> and <code>Error</code> types for compile-time type safety</li> <li>Lifecycle Hooks: Optional <code>pre_start</code> and <code>post_stop</code> for initialization and cleanup</li> <li>Supervision Integration: <code>on_error</code> returns <code>ErrorAction</code> for fault tolerance</li> </ol>"},{"location":"components/rt/architecture/actor-model/#actor-state-encapsulation","title":"Actor State Encapsulation","text":"<p>Actors maintain private state that can only be modified through message handling. Example from <code>examples/actor_basic.rs</code>:</p> <pre><code>struct CounterActor {\n    value: i32,        // Private state\n    max_value: i32,    // Configuration\n}\n\n#[async_trait]\nimpl Actor for CounterActor {\n    type Message = CounterMessage;\n    type Error = CounterError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        // Only way to modify state\n        self.value += message.delta;\n\n        if self.value &gt; self.max_value {\n            return Err(CounterError {\n                message: format!(\"Value {} exceeds maximum {}\", \n                    self.value, self.max_value),\n            });\n        }\n\n        context.record_message();\n        Ok(())\n    }\n}\n</code></pre> <p>Key principles: - State fields are private (not <code>pub</code>) - State only modified in <code>handle_message</code> - No direct external access to state - Thread safety through message passing</p>"},{"location":"components/rt/architecture/actor-model/#message-design","title":"Message Design","text":""},{"location":"components/rt/architecture/actor-model/#message-trait","title":"Message Trait","text":"<p>All messages must implement the <code>Message</code> trait (from <code>src/message/mod.rs</code>):</p> <pre><code>pub trait Message: Clone + Send + Sync + 'static \n    + for&lt;'de&gt; serde::Deserialize&lt;'de&gt; + serde::Serialize \n{\n    const MESSAGE_TYPE: &amp;'static str;\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#message-implementation-example","title":"Message Implementation Example","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct CounterMessage {\n    delta: i32,\n}\n\nimpl Message for CounterMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"counter\";\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#message-envelope","title":"Message Envelope","text":"<p>Messages are wrapped for routing (from <code>src/message/envelope.rs</code>):</p> <pre><code>pub struct MessageEnvelope&lt;M&gt; {\n    pub id: MessageId,\n    pub message: M,\n    pub timestamp: DateTime&lt;Utc&gt;,  // \u00a73.2 chrono DateTime&lt;Utc&gt;\n    pub reply_to: Option&lt;ActorAddress&gt;,\n}\n\nimpl&lt;M: Message&gt; MessageEnvelope&lt;M&gt; {\n    pub fn new(message: M) -&gt; Self {\n        Self {\n            id: MessageId::new(),\n            message,\n            timestamp: Utc::now(),\n            reply_to: None,\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#actor-lifecycle","title":"Actor Lifecycle","text":""},{"location":"components/rt/architecture/actor-model/#lifecycle-states","title":"Lifecycle States","text":"<p>Actors transition through defined states (from <code>src/actor/lifecycle.rs</code>):</p> <pre><code>pub enum ActorState {\n    Starting,   // Actor is initializing\n    Running,    // Actor is active and processing messages\n    Stopping,   // Actor is shutting down\n    Stopped,    // Actor has stopped successfully\n    Failed,     // Actor has failed (requires supervision)\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#lifecycle-management","title":"Lifecycle Management","text":"<p>The <code>ActorLifecycle</code> struct provides state management:</p> <pre><code>#[derive(Debug, Clone)]\npub struct ActorLifecycle {\n    state: ActorState,\n    last_state_change: DateTime&lt;Utc&gt;,\n    restart_count: u32,\n}\n\nimpl ActorLifecycle {\n    pub fn new() -&gt; Self;\n    pub fn state(&amp;self) -&gt; ActorState;\n    pub fn transition_to(&amp;mut self, new_state: ActorState);\n    pub fn restart_count(&amp;self) -&gt; u32;\n    pub fn last_state_change(&amp;self) -&gt; DateTime&lt;Utc&gt;;\n    pub fn is_terminal(&amp;self) -&gt; bool;\n    pub fn is_running(&amp;self) -&gt; bool;\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<p>Actors can override lifecycle hooks:</p> <pre><code>#[async_trait]\nimpl Actor for MyActor {\n    type Message = MyMessage;\n    type Error = MyError;\n\n    // Called before actor starts processing messages\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"Actor {} starting\", context.address().name().unwrap_or(\"anonymous\"));\n        // Initialize resources, connect to databases, etc.\n        Ok(())\n    }\n\n    // Called when actor stops\n    async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"Actor {} stopping\", context.address().name().unwrap_or(\"anonymous\"));\n        // Cleanup resources, close connections, etc.\n        Ok(())\n    }\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        // Process messages\n        Ok(())\n    }\n}\n</code></pre> <p>See <code>examples/actor_lifecycle.rs</code> for a complete lifecycle example.</p>"},{"location":"components/rt/architecture/actor-model/#actor-addressing","title":"Actor Addressing","text":""},{"location":"components/rt/architecture/actor-model/#actoraddress","title":"ActorAddress","text":"<p>Actors are identified by addresses (from <code>src/util/address.rs</code>):</p> <pre><code>pub struct ActorAddress {\n    id: ActorId,\n    name: Option&lt;String&gt;,\n}\n\nimpl ActorAddress {\n    pub fn anonymous() -&gt; Self;\n    pub fn named(name: impl Into&lt;String&gt;) -&gt; Self;\n    pub fn id(&amp;self) -&gt; &amp;ActorId;\n    pub fn name(&amp;self) -&gt; Option&lt;&amp;str&gt;;\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#actorid","title":"ActorId","text":"<p>Unique identifiers using UUIDs:</p> <pre><code>pub struct ActorId(uuid::Uuid);\n\nimpl ActorId {\n    pub fn new() -&gt; Self {\n        Self(uuid::Uuid::new_v4())\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#message-broker-system","title":"Message Broker System","text":""},{"location":"components/rt/architecture/actor-model/#messagebroker-trait","title":"MessageBroker Trait","text":"<p>The pub/sub system for actor communication (from <code>src/broker/traits.rs</code>):</p> <pre><code>#[async_trait]\npub trait MessageBroker&lt;M: Message&gt;: Clone + Send + Sync + 'static {\n    type Error: Error + Send + Sync + 'static;\n\n    async fn publish(&amp;self, envelope: MessageEnvelope&lt;M&gt;) \n        -&gt; Result&lt;(), Self::Error&gt;;\n\n    async fn subscribe(&amp;self, subscriber_id: ActorId) \n        -&gt; Result&lt;mpsc::Receiver&lt;MessageEnvelope&lt;M&gt;&gt;, Self::Error&gt;;\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#inmemorymessagebroker","title":"InMemoryMessageBroker","text":"<p>Current implementation using channels (from <code>src/broker/in_memory.rs</code>):</p> <pre><code>#[derive(Clone)]\npub struct InMemoryMessageBroker&lt;M: Message&gt; {\n    subscribers: Arc&lt;Mutex&lt;HashMap&lt;ActorId, mpsc::Sender&lt;MessageEnvelope&lt;M&gt;&gt;&gt;&gt;&gt;,\n}\n\nimpl&lt;M: Message&gt; InMemoryMessageBroker&lt;M&gt; {\n    pub fn new() -&gt; Self {\n        Self {\n            subscribers: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#communication-via-context","title":"Communication via Context","text":"<p>Actors send messages using their context:</p> <pre><code>// In actor's handle_message method\nasync fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    message: Self::Message,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    // Send message to another actor\n    context.send(message, recipient_address).await?;\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#mailbox-system","title":"Mailbox System","text":""},{"location":"components/rt/architecture/actor-model/#mailbox-types","title":"Mailbox Types","text":"<p>The runtime provides two mailbox implementations (from <code>src/mailbox/</code>):</p> <p>UnboundedMailbox - Unlimited capacity: <pre><code>pub struct UnboundedMailbox&lt;M: Message&gt; {\n    receiver: mpsc::UnboundedReceiver&lt;MessageEnvelope&lt;M&gt;&gt;,\n    metrics: Arc&lt;AtomicMetrics&gt;,\n}\n</code></pre></p> <p>BoundedMailbox - Limited capacity with backpressure: <pre><code>pub struct BoundedMailbox&lt;M: Message&gt; {\n    receiver: mpsc::Receiver&lt;MessageEnvelope&lt;M&gt;&gt;,\n    capacity: usize,\n    backpressure: BackpressureStrategy,\n    metrics: Arc&lt;AtomicMetrics&gt;,\n}\n</code></pre></p>"},{"location":"components/rt/architecture/actor-model/#backpressure-strategies","title":"Backpressure Strategies","text":"<pre><code>pub enum BackpressureStrategy {\n    Block,      // Block sender when mailbox full\n    Drop,       // Drop new messages when full\n    DropOldest, // Drop oldest message to make room\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#mailbox-traits","title":"Mailbox Traits","text":"<p>Generic mailbox interface:</p> <pre><code>#[async_trait]\npub trait MailboxReceiver&lt;M: Message&gt;: Send {\n    async fn recv(&amp;mut self) -&gt; Option&lt;MessageEnvelope&lt;M&gt;&gt;;\n    fn try_recv(&amp;mut self) -&gt; Result&lt;MessageEnvelope&lt;M&gt;, TryRecvError&gt;;\n}\n\n#[async_trait]\npub trait MailboxSender&lt;M: Message&gt;: Clone + Send + Sync {\n    async fn send(&amp;self, envelope: MessageEnvelope&lt;M&gt;) \n        -&gt; Result&lt;(), MailboxError&gt;;\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#error-handling-and-supervision","title":"Error Handling and Supervision","text":""},{"location":"components/rt/architecture/actor-model/#erroraction","title":"ErrorAction","text":"<p>Actors return <code>ErrorAction</code> from <code>on_error</code> to control fault handling:</p> <pre><code>pub enum ErrorAction {\n    Resume,    // Continue processing (ignore error)\n    Restart,   // Restart the actor\n    Stop,      // Stop the actor permanently\n    Escalate,  // Pass error to supervisor\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#error-flow","title":"Error Flow","text":"<ol> <li>Actor's <code>handle_message</code> returns <code>Err(Self::Error)</code></li> <li>Supervisor catches error</li> <li>Supervisor calls actor's <code>on_error</code> method  </li> <li>Actor returns <code>ErrorAction</code></li> <li>Supervisor applies restart strategy based on action</li> </ol> <p>Example:</p> <pre><code>async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    error: Self::Error,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; ErrorAction {\n    match error {\n        CounterError::OverflowError =&gt; {\n            eprintln!(\"Counter overflow, restarting\");\n            ErrorAction::Restart\n        }\n        CounterError::UnrecoverableError =&gt; {\n            eprintln!(\"Unrecoverable error, stopping\");\n            ErrorAction::Stop\n        }\n        _ =&gt; ErrorAction::Escalate,\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#actor-monitoring","title":"Actor Monitoring","text":""},{"location":"components/rt/architecture/actor-model/#health-checks","title":"Health Checks","text":"<p>Actors can be monitored via the <code>Child</code> trait's health check:</p> <pre><code>async fn health_check(&amp;self) -&gt; ChildHealth {\n    if self.is_healthy() {\n        ChildHealth::Healthy\n    } else {\n        ChildHealth::Unhealthy(\"Connection lost\".to_string())\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/actor-model/#monitoring-system","title":"Monitoring System","text":"<p>The monitoring system (from <code>src/monitoring/</code>) provides:</p> <ul> <li>Health status tracking</li> <li>Performance metrics  </li> <li>Message queue depth</li> <li>Processing latency</li> <li>Error rates</li> </ul> <p>See <code>examples/monitoring_basic.rs</code> and <code>examples/monitoring_supervisor.rs</code> for monitoring examples.</p>"},{"location":"components/rt/architecture/actor-model/#working-examples","title":"Working Examples","text":"<p>Explore these examples to understand the actor model:</p> Example Demonstrates Command <code>actor_basic.rs</code> Core actor implementation <code>cargo run --example actor_basic</code> <code>actor_lifecycle.rs</code> Lifecycle hooks <code>cargo run --example actor_lifecycle</code> <code>supervisor_basic.rs</code> Supervision patterns <code>cargo run --example supervisor_basic</code> <code>supervisor_strategies.rs</code> Restart strategies <code>cargo run --example supervisor_strategies</code> <code>monitoring_basic.rs</code> Actor monitoring <code>cargo run --example monitoring_basic</code> <p>All examples are in the <code>examples/</code> directory and demonstrate real implementations of these patterns.</p>"},{"location":"components/rt/architecture/components/","title":"Component Architecture","text":"<p>Detailed subsystem documentation for each layer of the <code>airssys-rt</code> runtime, including implementation details, interfaces, and integration patterns.</p> <p>Note: For high-level architecture, see System Overview. This document provides implementation-level details.</p>"},{"location":"components/rt/architecture/components/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Message Layer</li> <li>Broker Layer</li> <li>Actor Layer</li> <li>Mailbox Layer</li> <li>Supervisor Layer</li> <li>Monitoring Layer</li> <li>System Layer</li> </ol>"},{"location":"components/rt/architecture/components/#message-layer","title":"Message Layer","text":""},{"location":"components/rt/architecture/components/#overview","title":"Overview","text":"<p>The foundation layer providing type-safe message contracts and metadata.</p> <p>Location: <code>src/message/</code></p> <p>Responsibilities: - Define message trait contract - Provide message envelope wrapper - Generate unique message identifiers - Timestamp message creation</p>"},{"location":"components/rt/architecture/components/#components","title":"Components","text":""},{"location":"components/rt/architecture/components/#message-trait","title":"Message Trait","text":"<pre><code>// src/message/mod.rs\npub trait Message: Clone + Send + Sync + 'static \n    + for&lt;'de&gt; serde::Deserialize&lt;'de&gt; + serde::Serialize \n{\n    const MESSAGE_TYPE: &amp;'static str;\n}\n</code></pre> <p>Design Rationale: - <code>Clone</code>: Messages broadcast to multiple subscribers need cloning - <code>Send + Sync + 'static</code>: Cross-thread messaging requires thread safety - <code>Serialize + Deserialize</code>: Future network/persistence support - <code>MESSAGE_TYPE</code>: Runtime message type identification</p> <p>Implementation Example:</p> <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CounterMessage {\n    pub delta: i32,\n}\n\nimpl Message for CounterMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"counter\";\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#messageid","title":"MessageId","text":"<pre><code>// src/message/mod.rs\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct MessageId(uuid::Uuid);\n\nimpl MessageId {\n    pub fn new() -&gt; Self {\n        Self(uuid::Uuid::new_v4())\n    }\n}\n</code></pre> <p>Characteristics: - UUID v4 for global uniqueness - 128-bit identifier - Copy-able (16 bytes on stack) - Hash-able for collections</p>"},{"location":"components/rt/architecture/components/#messageenvelope","title":"MessageEnvelope","text":"<pre><code>// src/message/envelope.rs\npub struct MessageEnvelope&lt;M&gt; {\n    pub id: MessageId,\n    pub message: M,\n    pub timestamp: DateTime&lt;Utc&gt;,  // \u00a73.2 chrono DateTime&lt;Utc&gt;\n    pub reply_to: Option&lt;ActorAddress&gt;,\n}\n\nimpl&lt;M: Message&gt; MessageEnvelope&lt;M&gt; {\n    pub fn new(message: M) -&gt; Self {\n        Self {\n            id: MessageId::new(),\n            message,\n            timestamp: Utc::now(),\n            reply_to: None,\n        }\n    }\n\n    pub fn with_reply_to(message: M, reply_to: ActorAddress) -&gt; Self {\n        Self {\n            id: MessageId::new(),\n            message,\n            timestamp: Utc::now(),\n            reply_to: Some(reply_to),\n        }\n    }\n}\n</code></pre> <p>Features: - Automatic ID generation - Timestamp at creation (UTC) - Optional reply address for request/reply pattern - Generic over message type</p>"},{"location":"components/rt/architecture/components/#performance","title":"Performance","text":"Operation Latency Notes MessageId creation ~5 ns UUID v4 generation Envelope wrapping ~10 ns ID + timestamp + allocation Message clone Varies Depends on message size <p>Memory: - <code>MessageId</code>: 16 bytes (UUID) - <code>MessageEnvelope&lt;M&gt;</code>: 16 + sizeof(M) + 16 + 24 = 56 + sizeof(M) bytes</p>"},{"location":"components/rt/architecture/components/#broker-layer","title":"Broker Layer","text":""},{"location":"components/rt/architecture/components/#overview_1","title":"Overview","text":"<p>Pub/sub message routing system connecting actors through publish/subscribe semantics.</p> <p>Location: <code>src/broker/</code></p> <p>Responsibilities: - Route messages from publishers to subscribers - Manage subscriber registration - Handle message broadcast - Provide broker abstraction trait</p>"},{"location":"components/rt/architecture/components/#components_1","title":"Components","text":""},{"location":"components/rt/architecture/components/#messagebroker-trait","title":"MessageBroker Trait","text":"<pre><code>// src/broker/traits.rs\n#[async_trait]\npub trait MessageBroker&lt;M: Message&gt;: Clone + Send + Sync + 'static {\n    type Error: Error + Send + Sync + 'static;\n\n    async fn publish(&amp;self, envelope: MessageEnvelope&lt;M&gt;) \n        -&gt; Result&lt;(), Self::Error&gt;;\n\n    async fn subscribe(&amp;self, subscriber_id: ActorId) \n        -&gt; Result&lt;mpsc::Receiver&lt;MessageEnvelope&lt;M&gt;&gt;, Self::Error&gt;;\n}\n</code></pre> <p>Design Rationale: - <code>Clone</code>: Brokers shared across actors via cheap Arc cloning - Generic <code>&lt;M: Message&gt;</code>: Type-safe message routing per message type - <code>async</code>: Non-blocking pub/sub operations - Associated <code>Error</code>: Broker-specific error handling</p>"},{"location":"components/rt/architecture/components/#inmemorymessagebroker","title":"InMemoryMessageBroker","text":"<pre><code>// src/broker/in_memory.rs\n#[derive(Clone)]\npub struct InMemoryMessageBroker&lt;M: Message&gt; {\n    subscribers: Arc&lt;Mutex&lt;HashMap&lt;ActorId, mpsc::Sender&lt;MessageEnvelope&lt;M&gt;&gt;&gt;&gt;&gt;,\n}\n\nimpl&lt;M: Message&gt; InMemoryMessageBroker&lt;M&gt; {\n    pub fn new() -&gt; Self {\n        Self {\n            subscribers: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n}\n\n#[async_trait]\nimpl&lt;M: Message&gt; MessageBroker&lt;M&gt; for InMemoryMessageBroker&lt;M&gt; {\n    type Error = BrokerError;\n\n    async fn publish(&amp;self, envelope: MessageEnvelope&lt;M&gt;) \n        -&gt; Result&lt;(), Self::Error&gt; \n    {\n        let subscribers = self.subscribers.lock().unwrap();\n\n        for (_, sender) in subscribers.iter() {\n            // Clone envelope for each subscriber\n            let _ = sender.send(envelope.clone()).await;\n        }\n\n        Ok(())\n    }\n\n    async fn subscribe(&amp;self, subscriber_id: ActorId) \n        -&gt; Result&lt;mpsc::Receiver&lt;MessageEnvelope&lt;M&gt;&gt;, Self::Error&gt; \n    {\n        let (sender, receiver) = mpsc::channel(100);  // Buffered channel\n\n        self.subscribers.lock().unwrap()\n            .insert(subscriber_id, sender);\n\n        Ok(receiver)\n    }\n}\n</code></pre> <p>Implementation Details: - <code>Arc&lt;Mutex&lt;HashMap&gt;&gt;</code>: Thread-safe subscriber map, cheap cloning - Tokio <code>mpsc::channel</code>: Async message channels - Buffer size: 100 messages per subscriber - Broadcast clones envelope to all subscribers</p>"},{"location":"components/rt/architecture/components/#brokererror","title":"BrokerError","text":"<pre><code>// src/broker/in_memory.rs\n#[derive(Debug)]\npub enum BrokerError {\n    SubscriberNotFound(ActorId),\n    ChannelClosed,\n    SendError(String),\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#performance_1","title":"Performance","text":"<p>From <code>benches/message_benchmarks.rs</code>:</p> Operation Latency Throughput Notes publish + receive 737 ns 1.36M msgs/sec Full roundtrip Sustained throughput 211 ns/msg 4.7M msgs/sec 100 messages Broadcast (10 actors) 395 ns ~40 ns/actor Efficient multi-cast <p>Overhead Analysis: - Direct actor processing: 31.55 ns/msg - Via broker: 211.88 ns/msg - Broker overhead: 6.7x - acceptable for pub/sub semantics</p> <p>Bottlenecks: - <code>Mutex&lt;HashMap&gt;</code> contention with many concurrent publishers - Message cloning for broadcast (scales with subscriber count)</p> <p>Memory: - Base broker: ~48 bytes (Arc + Mutex) - Per subscriber: ~32 bytes (ActorId) + channel overhead</p>"},{"location":"components/rt/architecture/components/#future-enhancements","title":"Future Enhancements","text":"<p>Planned (not yet implemented): - Sharded broker (reduce contention) - Network broker (distributed actors) - Persistent broker (message durability) - Topic-based routing (message filtering)</p>"},{"location":"components/rt/architecture/components/#actor-layer","title":"Actor Layer","text":""},{"location":"components/rt/architecture/components/#overview_2","title":"Overview","text":"<p>Business logic execution layer providing actor trait, context, and lifecycle management.</p> <p>Location: <code>src/actor/</code></p> <p>Responsibilities: - Define actor behavior contract - Provide actor execution context - Manage actor lifecycle state - Handle message processing</p>"},{"location":"components/rt/architecture/components/#components_2","title":"Components","text":""},{"location":"components/rt/architecture/components/#actor-trait","title":"Actor Trait","text":"<pre><code>// src/actor/traits.rs\n#[async_trait]\npub trait Actor: Send + Sync + 'static {\n    type Message: Message;\n    type Error: Error + Send + Sync + 'static;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt;;\n\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        Ok(())\n    }\n\n    async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        Ok(())\n    }\n\n    async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        error: Self::Error,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; ErrorAction {\n        ErrorAction::Restart\n    }\n}\n</code></pre> <p>Design Rationale: - Generic constraint <code>&lt;B: MessageBroker&gt;</code>: Dependency injection, testability - Associated types: Type safety without parameter explosion - Lifecycle hooks: Initialization and cleanup integration points - Error handling: Supervision decision via <code>ErrorAction</code></p>"},{"location":"components/rt/architecture/components/#actorcontext","title":"ActorContext","text":"<pre><code>// src/actor/context.rs\npub struct ActorContext&lt;M: Message, B: MessageBroker&lt;M&gt;&gt; {\n    address: ActorAddress,\n    id: ActorId,\n    created_at: DateTime&lt;Utc&gt;,\n    last_message_at: Option&lt;DateTime&lt;Utc&gt;&gt;,\n    message_count: u64,\n    broker: B,\n    _marker: PhantomData&lt;M&gt;,\n}\n\nimpl&lt;M: Message, B: MessageBroker&lt;M&gt;&gt; ActorContext&lt;M, B&gt; {\n    pub fn new(address: ActorAddress, broker: B) -&gt; Self {\n        Self {\n            id: address.id().clone(),\n            address,\n            created_at: Utc::now(),\n            last_message_at: None,\n            message_count: 0,\n            broker,\n            _marker: PhantomData,\n        }\n    }\n\n    pub fn address(&amp;self) -&gt; &amp;ActorAddress { &amp;self.address }\n    pub fn id(&amp;self) -&gt; &amp;ActorId { &amp;self.id }\n    pub fn message_count(&amp;self) -&gt; u64 { self.message_count }\n    pub fn created_at(&amp;self) -&gt; DateTime&lt;Utc&gt; { self.created_at }\n\n    pub fn record_message(&amp;mut self) {\n        self.message_count += 1;\n        self.last_message_at = Some(Utc::now());\n    }\n\n    pub async fn send(\n        &amp;self,\n        message: M,\n        _recipient: ActorAddress,\n    ) -&gt; Result&lt;(), B::Error&gt; {\n        let envelope = MessageEnvelope::new(message);\n        self.broker.publish(envelope).await\n    }\n}\n</code></pre> <p>Features: - Actor metadata (address, ID, timestamps) - Message statistics tracking - Broker access for messaging - Type-safe message sending</p>"},{"location":"components/rt/architecture/components/#actorlifecycle","title":"ActorLifecycle","text":"<pre><code>// src/actor/lifecycle.rs\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ActorState {\n    Starting,\n    Running,\n    Stopping,\n    Stopped,\n    Failed,\n}\n\n#[derive(Debug, Clone)]\npub struct ActorLifecycle {\n    state: ActorState,\n    last_state_change: DateTime&lt;Utc&gt;,\n    restart_count: u32,\n}\n\nimpl ActorLifecycle {\n    pub fn new() -&gt; Self {\n        Self {\n            state: ActorState::Starting,\n            last_state_change: Utc::now(),\n            restart_count: 0,\n        }\n    }\n\n    pub fn state(&amp;self) -&gt; ActorState { self.state }\n\n    pub fn transition_to(&amp;mut self, new_state: ActorState) {\n        self.state = new_state;\n        self.last_state_change = Utc::now();\n    }\n\n    pub fn restart_count(&amp;self) -&gt; u32 { self.restart_count }\n\n    pub fn record_restart(&amp;mut self) {\n        self.restart_count += 1;\n    }\n\n    pub fn is_terminal(&amp;self) -&gt; bool {\n        matches!(self.state, ActorState::Stopped | ActorState::Failed)\n    }\n\n    pub fn is_running(&amp;self) -&gt; bool {\n        self.state == ActorState::Running\n    }\n}\n</code></pre> <p>State Machine: - Starting \u2192 Running (successful init) - Starting \u2192 Failed (init error) - Running \u2192 Stopping (graceful shutdown) - Running \u2192 Failed (runtime error) - Stopping \u2192 Stopped (cleanup complete) - Stopped \u2192 Starting (supervisor restart)</p>"},{"location":"components/rt/architecture/components/#erroraction","title":"ErrorAction","text":"<pre><code>// src/actor/traits.rs\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ErrorAction {\n    Resume,    // Continue processing (ignore error)\n    Restart,   // Restart the actor\n    Stop,      // Stop the actor permanently\n    Escalate,  // Pass error to supervisor\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#performance_2","title":"Performance","text":"<p>From <code>benches/actor_benchmarks.rs</code>:</p> Operation Latency Notes Actor spawn (single) 624.74 ns Context + lifecycle creation Actor spawn (batch 10) 681.40 ns/actor Only 9% overhead Message processing 31.55 ns/msg Direct handle_message call <p>Memory: - <code>ActorContext&lt;M, B&gt;</code>: ~200 bytes (address, timestamps, broker clone, stats) - <code>ActorLifecycle</code>: ~32 bytes (state, timestamp, counter) - Actor implementation: Varies (user-defined state)</p>"},{"location":"components/rt/architecture/components/#mailbox-layer","title":"Mailbox Layer","text":""},{"location":"components/rt/architecture/components/#overview_3","title":"Overview","text":"<p>Message queue management providing buffering and backpressure control.</p> <p>Location: <code>src/mailbox/</code></p> <p>Responsibilities: - Buffer incoming messages - Implement backpressure strategies - Track mailbox metrics - Provide async receive interface</p>"},{"location":"components/rt/architecture/components/#components_3","title":"Components","text":""},{"location":"components/rt/architecture/components/#mailbox-traits","title":"Mailbox Traits","text":"<pre><code>// src/mailbox/mod.rs\n#[async_trait]\npub trait MailboxReceiver&lt;M: Message&gt;: Send {\n    async fn recv(&amp;mut self) -&gt; Option&lt;MessageEnvelope&lt;M&gt;&gt;;\n    fn try_recv(&amp;mut self) -&gt; Result&lt;MessageEnvelope&lt;M&gt;, TryRecvError&gt;;\n}\n\n#[async_trait]\npub trait MailboxSender&lt;M: Message&gt;: Clone + Send + Sync {\n    async fn send(&amp;self, envelope: MessageEnvelope&lt;M&gt;) \n        -&gt; Result&lt;(), MailboxError&gt;;\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#unboundedmailbox","title":"UnboundedMailbox","text":"<pre><code>// src/mailbox/unbounded.rs\npub struct UnboundedMailbox&lt;M: Message&gt; {\n    receiver: mpsc::UnboundedReceiver&lt;MessageEnvelope&lt;M&gt;&gt;,\n    metrics: Arc&lt;AtomicMetrics&gt;,\n}\n\nimpl&lt;M: Message&gt; UnboundedMailbox&lt;M&gt; {\n    pub fn new() -&gt; (UnboundedMailboxSender&lt;M&gt;, Self) {\n        let (sender, receiver) = mpsc::unbounded_channel();\n        let metrics = Arc::new(AtomicMetrics::new());\n\n        let mailbox = Self { receiver, metrics: metrics.clone() };\n        let sender = UnboundedMailboxSender { sender, metrics };\n\n        (sender, mailbox)\n    }\n}\n\n#[async_trait]\nimpl&lt;M: Message&gt; MailboxReceiver&lt;M&gt; for UnboundedMailbox&lt;M&gt; {\n    async fn recv(&amp;mut self) -&gt; Option&lt;MessageEnvelope&lt;M&gt;&gt; {\n        self.receiver.recv().await\n    }\n\n    fn try_recv(&amp;mut self) -&gt; Result&lt;MessageEnvelope&lt;M&gt;, TryRecvError&gt; {\n        self.receiver.try_recv()\n    }\n}\n</code></pre> <p>Characteristics: - Unlimited capacity (bounded only by memory) - No backpressure (sender never blocks) - Tokio <code>mpsc::unbounded_channel</code> backend - Atomic metrics tracking</p> <p>Use Cases: - Low-volume control messages - Actors with predictable load - Development and prototyping</p>"},{"location":"components/rt/architecture/components/#boundedmailbox","title":"BoundedMailbox","text":"<pre><code>// src/mailbox/bounded.rs\npub struct BoundedMailbox&lt;M: Message&gt; {\n    receiver: mpsc::Receiver&lt;MessageEnvelope&lt;M&gt;&gt;,\n    capacity: usize,\n    backpressure: BackpressureStrategy,\n    metrics: Arc&lt;AtomicMetrics&gt;,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum BackpressureStrategy {\n    Block,      // Block sender when mailbox full\n    Drop,       // Drop new messages when full\n    DropOldest, // Drop oldest message to make room\n}\n\nimpl&lt;M: Message&gt; BoundedMailbox&lt;M&gt; {\n    pub fn new(\n        capacity: usize,\n        backpressure: BackpressureStrategy,\n    ) -&gt; (BoundedMailboxSender&lt;M&gt;, Self) {\n        let (sender, receiver) = mpsc::channel(capacity);\n        let metrics = Arc::new(AtomicMetrics::new());\n\n        let mailbox = Self {\n            receiver,\n            capacity,\n            backpressure,\n            metrics: metrics.clone(),\n        };\n\n        let sender = BoundedMailboxSender {\n            sender,\n            backpressure,\n            metrics,\n        };\n\n        (sender, mailbox)\n    }\n}\n</code></pre> <p>Characteristics: - Fixed capacity (prevents unbounded growth) - Configurable backpressure strategy - Tokio <code>mpsc::channel(capacity)</code> backend - Atomic metrics tracking</p> <p>Use Cases: - High-volume data streams - Memory-constrained environments - Flow control requirements</p>"},{"location":"components/rt/architecture/components/#mailboxerror","title":"MailboxError","text":"<pre><code>// src/mailbox/bounded.rs\n#[derive(Debug)]\npub enum MailboxError {\n    Full,       // Bounded mailbox at capacity\n    Closed,     // Receiver dropped\n    Timeout,    // Receive timeout exceeded\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#performance_3","title":"Performance","text":"<p>From <code>benches/message_benchmarks.rs</code>:</p> Operation Latency Notes Mailbox enqueue + dequeue (100 ops) 181.60 ns/op Tokio channel efficiency Bounded mailbox (capacity 100) 244.18 ns/mailbox Creation overhead <p>Memory: - <code>UnboundedMailbox&lt;M&gt;</code>: ~100 bytes base + queue size - <code>BoundedMailbox&lt;M&gt;</code>: ~150 bytes base + (capacity \u00d7 sizeof(envelope))</p>"},{"location":"components/rt/architecture/components/#backpressure-strategies","title":"Backpressure Strategies","text":"<p>Block Strategy: <pre><code>// Sender blocks until space available\nmailbox_sender.send(envelope).await?;  // Waits if full\n</code></pre></p> <p>Drop Strategy: <pre><code>// New messages dropped when full\nif mailbox.is_full() {\n    return Err(MailboxError::Full);\n}\n</code></pre></p> <p>DropOldest Strategy: <pre><code>// Remove oldest message, add new message\nif mailbox.is_full() {\n    mailbox.pop_front();\n}\nmailbox.push_back(envelope);\n</code></pre></p>"},{"location":"components/rt/architecture/components/#supervisor-layer","title":"Supervisor Layer","text":""},{"location":"components/rt/architecture/components/#overview_4","title":"Overview","text":"<p>Fault tolerance layer implementing Erlang/OTP supervision patterns with builder-based configuration.</p> <p>Location: <code>src/supervisor/</code></p> <p>Responsibilities: - Supervise child actors/components - Implement restart strategies - Handle child lifecycle - Provide builder API for type-safe configuration</p>"},{"location":"components/rt/architecture/components/#components_4","title":"Components","text":""},{"location":"components/rt/architecture/components/#child-trait","title":"Child Trait","text":"<pre><code>// src/supervisor/child.rs\n#[async_trait]\npub trait Child: Send + Sync {\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt;;\n    async fn stop(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt;;\n    async fn health_check(&amp;self) -&gt; ChildHealth;\n}\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ChildHealth {\n    Healthy,\n    Unhealthy(String),\n    Unknown,\n}\n</code></pre> <p>Blanket Implementation for Actors: <pre><code>#[async_trait]\nimpl&lt;A: Actor&gt; Child for A {\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        // Calls Actor::pre_start\n    }\n\n    async fn stop(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        // Calls Actor::post_stop\n    }\n\n    async fn health_check(&amp;self) -&gt; ChildHealth {\n        // Default implementation based on lifecycle state\n    }\n}\n</code></pre></p>"},{"location":"components/rt/architecture/components/#childspec","title":"ChildSpec","text":"<pre><code>// src/supervisor/child.rs\npub struct ChildSpec {\n    pub id: ChildId,\n    pub restart_policy: RestartPolicy,\n    pub shutdown_policy: ShutdownPolicy,\n    pub significant: bool,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum RestartPolicy {\n    Permanent,   // Always restart on failure\n    Transient,   // Restart only on abnormal termination\n    Temporary,   // Never restart\n}\n\n#[derive(Debug, Clone)]\npub struct ShutdownPolicy {\n    pub timeout: Duration,\n    pub strategy: ShutdownStrategy,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ShutdownStrategy {\n    Graceful,  // Call stop(), wait for timeout\n    Brutal,    // Immediate termination\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#restartstrategy-trait","title":"RestartStrategy Trait","text":"<pre><code>// src/supervisor/strategy.rs\n#[async_trait]\npub trait RestartStrategy: Send + Sync {\n    async fn handle_failure(\n        &amp;self,\n        failed_child_id: &amp;ChildId,\n        children: &amp;mut Vec&lt;(ChildSpec, Box&lt;dyn Child&gt;)&gt;,\n    ) -&gt; Result&lt;(), SupervisorError&gt;;\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#oneforone-strategy","title":"OneForOne Strategy","text":"<pre><code>// src/supervisor/strategy.rs\npub struct OneForOne;\n\nimpl OneForOne {\n    pub fn new() -&gt; Self { Self }\n}\n\n#[async_trait]\nimpl RestartStrategy for OneForOne {\n    async fn handle_failure(\n        &amp;self,\n        failed_child_id: &amp;ChildId,\n        children: &amp;mut Vec&lt;(ChildSpec, Box&lt;dyn Child&gt;)&gt;,\n    ) -&gt; Result&lt;(), SupervisorError&gt; {\n        // Find failed child\n        let (spec, child) = children.iter_mut()\n            .find(|(s, _)| &amp;s.id == failed_child_id)\n            .ok_or(SupervisorError::ChildNotFound(failed_child_id.clone()))?;\n\n        // Restart only this child\n        child.stop().await.map_err(|e| SupervisorError::ChildStopFailed(spec.id.clone(), e))?;\n        child.start().await.map_err(|e| SupervisorError::ChildStartFailed(spec.id.clone(), e))?;\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#oneforall-strategy","title":"OneForAll Strategy","text":"<pre><code>// src/supervisor/strategy.rs\npub struct OneForAll;\n\n#[async_trait]\nimpl RestartStrategy for OneForAll {\n    async fn handle_failure(\n        &amp;self,\n        _failed_child_id: &amp;ChildId,\n        children: &amp;mut Vec&lt;(ChildSpec, Box&lt;dyn Child&gt;)&gt;,\n    ) -&gt; Result&lt;(), SupervisorError&gt; {\n        // Stop all children\n        for (spec, child) in children.iter_mut() {\n            child.stop().await.map_err(|e| SupervisorError::ChildStopFailed(spec.id.clone(), e))?;\n        }\n\n        // Start all children\n        for (spec, child) in children.iter_mut() {\n            child.start().await.map_err(|e| SupervisorError::ChildStartFailed(spec.id.clone(), e))?;\n        }\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#restforone-strategy","title":"RestForOne Strategy","text":"<pre><code>// src/supervisor/strategy.rs\npub struct RestForOne;\n\n#[async_trait]\nimpl RestartStrategy for RestForOne {\n    async fn handle_failure(\n        &amp;self,\n        failed_child_id: &amp;ChildId,\n        children: &amp;mut Vec&lt;(ChildSpec, Box&lt;dyn Child&gt;)&gt;,\n    ) -&gt; Result&lt;(), SupervisorError&gt; {\n        // Find failed child index\n        let failed_index = children.iter()\n            .position(|(s, _)| &amp;s.id == failed_child_id)\n            .ok_or(SupervisorError::ChildNotFound(failed_child_id.clone()))?;\n\n        // Stop failed child and all subsequent children\n        for (spec, child) in children[failed_index..].iter_mut() {\n            child.stop().await.map_err(|e| SupervisorError::ChildStopFailed(spec.id.clone(), e))?;\n        }\n\n        // Restart failed child and all subsequent children\n        for (spec, child) in children[failed_index..].iter_mut() {\n            child.start().await.map_err(|e| SupervisorError::ChildStartFailed(spec.id.clone(), e))?;\n        }\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#supervisornode","title":"SupervisorNode","text":"<pre><code>// src/supervisor/supervisor.rs\npub struct SupervisorNode {\n    id: SupervisorId,\n    strategy: Box&lt;dyn RestartStrategy&gt;,\n    children: Vec&lt;(ChildSpec, Box&lt;dyn Child&gt;)&gt;,\n    lifecycle: ActorLifecycle,\n}\n\nimpl SupervisorNode {\n    pub fn builder() -&gt; SupervisorBuilder {\n        SupervisorBuilder::new()\n    }\n\n    pub fn new&lt;S: RestartStrategy + 'static&gt;(\n        id: SupervisorId,\n        strategy: S,\n    ) -&gt; Self {\n        Self {\n            id,\n            strategy: Box::new(strategy),\n            children: Vec::new(),\n            lifecycle: ActorLifecycle::new(),\n        }\n    }\n\n    pub async fn add_child(\n        &amp;mut self,\n        spec: ChildSpec,\n        child: Box&lt;dyn Child&gt;,\n    ) -&gt; Result&lt;(), SupervisorError&gt; {\n        self.children.push((spec, child));\n        Ok(())\n    }\n\n    pub async fn start_all(&amp;mut self) -&gt; Result&lt;(), SupervisorError&gt; {\n        self.lifecycle.transition_to(ActorState::Starting);\n\n        for (spec, child) in &amp;mut self.children {\n            child.start().await\n                .map_err(|e| SupervisorError::ChildStartFailed(spec.id.clone(), e))?;\n        }\n\n        self.lifecycle.transition_to(ActorState::Running);\n        Ok(())\n    }\n\n    pub async fn stop_all(&amp;mut self) -&gt; Result&lt;(), SupervisorError&gt; {\n        self.lifecycle.transition_to(ActorState::Stopping);\n\n        for (spec, child) in &amp;mut self.children {\n            child.stop().await\n                .map_err(|e| SupervisorError::ChildStopFailed(spec.id.clone(), e))?;\n        }\n\n        self.lifecycle.transition_to(ActorState::Stopped);\n        Ok(())\n    }\n\n    pub async fn handle_child_failure(\n        &amp;mut self,\n        child_id: &amp;ChildId,\n    ) -&gt; Result&lt;(), SupervisorError&gt; {\n        self.strategy.handle_failure(child_id, &amp;mut self.children).await\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#supervisorbuilder-rt-task-013","title":"SupervisorBuilder (RT-TASK-013)","text":"<pre><code>// src/supervisor/builder.rs\npub struct SupervisorBuilder {\n    id: Option&lt;SupervisorId&gt;,\n    strategy: Option&lt;Box&lt;dyn RestartStrategy&gt;&gt;,\n    children: Vec&lt;(ChildSpec, Box&lt;dyn Child&gt;)&gt;,\n}\n\nimpl SupervisorBuilder {\n    pub fn new() -&gt; Self {\n        Self {\n            id: None,\n            strategy: None,\n            children: Vec::new(),\n        }\n    }\n\n    pub fn with_id(mut self, id: SupervisorId) -&gt; Self {\n        self.id = Some(id);\n        self\n    }\n\n    pub fn with_strategy&lt;S: RestartStrategy + 'static&gt;(mut self, strategy: S) -&gt; Self {\n        self.strategy = Some(Box::new(strategy));\n        self\n    }\n\n    pub fn add_child(\n        mut self,\n        spec: ChildSpec,\n        child: Box&lt;dyn Child&gt;,\n    ) -&gt; Self {\n        self.children.push((spec, child));\n        self\n    }\n\n    pub fn build(self) -&gt; Result&lt;SupervisorNode, SupervisorError&gt; {\n        let id = self.id.unwrap_or_else(SupervisorId::new);\n        let strategy = self.strategy\n            .ok_or(SupervisorError::StrategyError(\"No strategy specified\".to_string()))?;\n\n        let mut supervisor = SupervisorNode {\n            id,\n            strategy,\n            children: Vec::new(),\n            lifecycle: ActorLifecycle::new(),\n        };\n\n        supervisor.children = self.children;\n\n        Ok(supervisor)\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#performance_4","title":"Performance","text":"<p>From <code>benches/supervisor_benchmarks.rs</code>:</p> Operation Latency Notes Child spawn (builder API) 5-20 \u00b5s Type-safe configuration OneForOne restart 10-50 \u00b5s Single child lifecycle OneForAll restart (3 children) 30-150 \u00b5s ~3x OneForOne RestForOne restart (2 children) 20-100 \u00b5s Between OneForOne and OneForAll <p>Memory: - <code>SupervisorNode</code>: ~200 bytes base + children vec - Per child: ~80 bytes (ChildSpec + Box pointer)"},{"location":"components/rt/architecture/components/#monitoring-layer","title":"Monitoring Layer","text":""},{"location":"components/rt/architecture/components/#overview_5","title":"Overview","text":"<p>Health checks and metrics tracking for actors and supervisors.</p> <p>Location: <code>src/monitoring/</code></p> <p>Responsibilities: - Monitor child health status - Track actor performance metrics - Provide automatic health checks - Alert on unhealthy children</p>"},{"location":"components/rt/architecture/components/#components_5","title":"Components","text":""},{"location":"components/rt/architecture/components/#healthmonitor","title":"HealthMonitor","text":"<pre><code>// src/monitoring/health.rs\npub struct HealthMonitor {\n    config: HealthConfig,\n    checks: Vec&lt;HealthCheck&gt;,\n}\n\npub struct HealthConfig {\n    pub check_interval: Duration,\n    pub unhealthy_threshold: u32,\n    pub auto_restart: bool,\n}\n\nimpl HealthMonitor {\n    pub fn new(config: HealthConfig) -&gt; Self {\n        Self {\n            config,\n            checks: Vec::new(),\n        }\n    }\n\n    pub async fn monitor_supervisor(\n        &amp;mut self,\n        supervisor: &amp;mut SupervisorNode,\n    ) -&gt; Result&lt;(), MonitoringError&gt; {\n        loop {\n            tokio::time::sleep(self.config.check_interval).await;\n\n            for (spec, child) in supervisor.children_mut() {\n                let health = child.health_check().await;\n\n                if health == ChildHealth::Unhealthy {\n                    if self.config.auto_restart {\n                        supervisor.handle_child_failure(&amp;spec.id).await?;\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#actormetrics","title":"ActorMetrics","text":"<pre><code>// src/monitoring/metrics.rs\npub struct ActorMetrics {\n    pub message_count: AtomicU64,\n    pub error_count: AtomicU64,\n    pub last_message_at: AtomicU64,  // Unix timestamp\n    pub processing_time_ns: AtomicU64,\n}\n\nimpl ActorMetrics {\n    pub fn new() -&gt; Self {\n        Self {\n            message_count: AtomicU64::new(0),\n            error_count: AtomicU64::new(0),\n            last_message_at: AtomicU64::new(0),\n            processing_time_ns: AtomicU64::new(0),\n        }\n    }\n\n    pub fn record_message(&amp;self, processing_time: Duration) {\n        self.message_count.fetch_add(1, Ordering::Relaxed);\n        self.last_message_at.store(\n            Utc::now().timestamp() as u64,\n            Ordering::Relaxed,\n        );\n        self.processing_time_ns.fetch_add(\n            processing_time.as_nanos() as u64,\n            Ordering::Relaxed,\n        );\n    }\n\n    pub fn record_error(&amp;self) {\n        self.error_count.fetch_add(1, Ordering::Relaxed);\n    }\n\n    pub fn message_count(&amp;self) -&gt; u64 {\n        self.message_count.load(Ordering::Relaxed)\n    }\n\n    pub fn error_count(&amp;self) -&gt; u64 {\n        self.error_count.load(Ordering::Relaxed)\n    }\n\n    pub fn average_processing_time(&amp;self) -&gt; Duration {\n        let total = self.processing_time_ns.load(Ordering::Relaxed);\n        let count = self.message_count.load(Ordering::Relaxed);\n\n        if count == 0 {\n            Duration::from_nanos(0)\n        } else {\n            Duration::from_nanos(total / count)\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#performance_5","title":"Performance","text":"<ul> <li>Health check overhead: Depends on <code>Child::health_check()</code> implementation</li> <li>Metrics update: Lock-free atomic operations (~5-10 ns)</li> <li>Monitoring loop: Configurable interval (default: 5 seconds)</li> </ul> <p>Memory: - <code>HealthMonitor</code>: ~100 bytes + checks vec - <code>ActorMetrics</code>: 32 bytes (4 \u00d7 AtomicU64)</p>"},{"location":"components/rt/architecture/components/#system-layer-planned","title":"System Layer (Planned)","text":""},{"location":"components/rt/architecture/components/#overview_6","title":"Overview","text":"<p>Future runtime coordination layer for actor registry and distributed nodes.</p> <p>Location: <code>src/system/</code> (planned for Q1 2026)</p> <p>Planned Responsibilities: - Global actor registry - Actor address resolution - System lifecycle management - Distributed node coordination (future)</p>"},{"location":"components/rt/architecture/components/#planned-components","title":"Planned Components","text":""},{"location":"components/rt/architecture/components/#actorsystem-not-yet-implemented","title":"ActorSystem (Not Yet Implemented)","text":"<pre><code>// Planned design\npub struct ActorSystem {\n    registry: ActorRegistry,\n    root_supervisor: SupervisorNode,\n    config: SystemConfig,\n}\n\nimpl ActorSystem {\n    pub async fn new(config: SystemConfig) -&gt; Result&lt;Self, SystemError&gt;;\n    pub async fn spawn_actor&lt;A: Actor&gt;(&amp;mut self, actor: A) -&gt; ActorAddress;\n    pub async fn lookup(&amp;self, address: &amp;ActorAddress) -&gt; Option&lt;ActorRef&gt;;\n    pub async fn shutdown(&amp;mut self) -&gt; Result&lt;(), SystemError&gt;;\n}\n</code></pre>"},{"location":"components/rt/architecture/components/#actorregistry-not-yet-implemented","title":"ActorRegistry (Not Yet Implemented)","text":"<pre><code>// Planned design\npub struct ActorRegistry {\n    actors: HashMap&lt;ActorAddress, ActorRef&gt;,\n}\n\nimpl ActorRegistry {\n    pub fn register(&amp;mut self, address: ActorAddress, actor_ref: ActorRef);\n    pub fn unregister(&amp;mut self, address: &amp;ActorAddress);\n    pub fn lookup(&amp;self, address: &amp;ActorAddress) -&gt; Option&lt;&amp;ActorRef&gt;;\n}\n</code></pre> <p>Status: Architecture designed, implementation planned for Q1 2026.</p>"},{"location":"components/rt/architecture/components/#component-integration","title":"Component Integration","text":""},{"location":"components/rt/architecture/components/#data-flow-diagram","title":"Data Flow Diagram","text":"<p>Complete message flow from send to receive:</p> <pre><code>Actor A                  Broker                   Actor B\n   \u2502                        \u2502                        \u2502\n   \u2502 1. send(msg)           \u2502                        \u2502\n   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502                        \u2502\n   \u2502                        \u2502                        \u2502\n   \u2502                    2. publish()                 \u2502\n   \u2502                    (wrap envelope)              \u2502\n   \u2502                        \u2502                        \u2502\n   \u2502                    3. route to                  \u2502\n   \u2502                    subscribers                  \u2502\n   \u2502                        \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt;\u2502\n   \u2502                        \u2502                  4. recv()\n   \u2502                        \u2502                  (mailbox)\n   \u2502                        \u2502                        \u2502\n   \u2502                        \u2502              5. handle_message()\n   \u2502                        \u2502                        \u2502\n</code></pre>"},{"location":"components/rt/architecture/components/#supervision-integration","title":"Supervision Integration","text":"<p>How supervision integrates with other layers:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502             SupervisorNode                          \u2502\n\u2502  - Manages child lifecycle                          \u2502\n\u2502  - Applies restart strategy                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502                        \u2502\n           \u2502 supervises             \u2502 monitors\n           \u2502                        \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Child (Actor)     \u2502   \u2502  HealthMonitor     \u2502\n\u2502  - implements Child \u2502   \u2502  - health_check()  \u2502\n\u2502  - ActorLifecycle   \u2502   \u2502  - auto-restart    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u2502 uses\n           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   ActorContext      \u2502\n\u2502  - MessageBroker    \u2502\n\u2502  - ActorAddress     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502\n           \u2502 publishes via\n           \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  InMemoryMessageBroker  \u2502\n\u2502  - routes messages      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"components/rt/architecture/components/#next-steps","title":"Next Steps","text":"<p>For architecture overviews and cross-cutting concerns, see:</p> <ul> <li>System Overview - High-level architecture</li> <li>Core Concepts - Fundamental concepts</li> <li>Actor Model - Actor design patterns</li> <li>Message Passing - Messaging details</li> <li>Supervision - Fault tolerance patterns</li> <li>Process Lifecycle - State management</li> </ul> <p>For implementation guidance:</p> <ul> <li>Actor Development Guide - Building actors</li> <li>Supervisor Patterns Guide - Supervision setup</li> <li>Message Passing Guide - Messaging patterns</li> </ul>"},{"location":"components/rt/architecture/core-concepts/","title":"Core Concepts","text":"<p><code>airssys-rt</code> is built around several fundamental concepts adapted from the Erlang/BEAM runtime model. Understanding these concepts is essential for effectively using the actor runtime.</p> <p>Note: All code examples in this document are taken from the actual implementation. For complete working examples, see the examples directory.</p>"},{"location":"components/rt/architecture/core-concepts/#actors-and-message-processing","title":"Actors and Message Processing","text":""},{"location":"components/rt/architecture/core-concepts/#actor-trait","title":"Actor Trait","text":"<p>The core <code>Actor</code> trait is the foundation of the runtime system. Every actor must implement this trait with associated types for messages and errors:</p> <pre><code>#[async_trait]\npub trait Actor: Send + Sync + 'static {\n    /// The type of messages this actor can handle.\n    type Message: Message;\n\n    /// The error type returned by actor operations.\n    type Error: Error + Send + Sync + 'static;\n\n    /// Handle an incoming message.\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt;;\n\n    // Optional lifecycle hooks\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        Ok(())\n    }\n\n    async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        Ok(())\n    }\n\n    async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        error: Self::Error,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; ErrorAction {\n        ErrorAction::Restart\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/core-concepts/#actor-context","title":"Actor Context","text":"<p>The <code>ActorContext</code> provides metadata and messaging capabilities to actors:</p> <pre><code>pub struct ActorContext&lt;M: Message, B: MessageBroker&lt;M&gt;&gt; {\n    address: ActorAddress,\n    id: ActorId,\n    created_at: DateTime&lt;Utc&gt;,\n    last_message_at: Option&lt;DateTime&lt;Utc&gt;&gt;,\n    message_count: u64,\n    broker: B, // Dependency injection\n    _marker: PhantomData&lt;M&gt;,\n}\n</code></pre> <p>Key methods: - <code>address()</code> - Get the actor's address - <code>id()</code> - Get the actor's unique ID - <code>message_count()</code> - Get total messages processed - <code>record_message()</code> - Track message processing - <code>send(message, recipient)</code> - Send messages to other actors</p>"},{"location":"components/rt/architecture/core-concepts/#process-lifecycle","title":"Process Lifecycle","text":"<p>Actors go through several lifecycle stages managed by the <code>ActorLifecycle</code> struct:</p> <pre><code>pub enum ActorState {\n    Starting,   // Actor is initializing\n    Running,    // Actor is active and processing messages\n    Stopping,   // Actor is shutting down\n    Stopped,    // Actor has stopped successfully\n    Failed,     // Actor has failed (requires supervision)\n}\n</code></pre> <p>The <code>ActorLifecycle</code> struct provides state management (from <code>src/actor/lifecycle.rs</code>):</p> <pre><code>#[derive(Debug, Clone)]\npub struct ActorLifecycle {\n    state: ActorState,\n    last_state_change: DateTime&lt;Utc&gt;,\n    restart_count: u32,\n}\n\nimpl ActorLifecycle {\n    pub fn new() -&gt; Self;\n    pub fn state(&amp;self) -&gt; ActorState;\n    pub fn transition_to(&amp;mut self, new_state: ActorState);\n    pub fn restart_count(&amp;self) -&gt; u32;\n    pub fn is_terminal(&amp;self) -&gt; bool;\n    pub fn is_running(&amp;self) -&gt; bool;\n}\n</code></pre>"},{"location":"components/rt/architecture/core-concepts/#complete-actor-example","title":"Complete Actor Example","text":"<p>Here's a real actor implementation from <code>examples/actor_basic.rs</code>:</p> <pre><code>// Define a message type\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct CounterMessage {\n    delta: i32,\n}\n\nimpl Message for CounterMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"counter\";\n}\n\n// Define the actor\nstruct CounterActor {\n    value: i32,\n    max_value: i32,\n}\n\n// Define error type\n#[derive(Debug)]\nstruct CounterError {\n    message: String,\n}\n\nimpl fmt::Display for CounterError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        write!(f, \"CounterError: {}\", self.message)\n    }\n}\n\nimpl std::error::Error for CounterError {}\n\n// Implement Actor trait\n#[async_trait]\nimpl Actor for CounterActor {\n    type Message = CounterMessage;\n    type Error = CounterError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        self.value += message.delta;\n\n        if self.value &gt; self.max_value {\n            return Err(CounterError {\n                message: format!(\"Value {} exceeds maximum {}\", \n                    self.value, self.max_value),\n            });\n        }\n\n        context.record_message();\n        Ok(())\n    }\n\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"[Actor {}] Starting with value: {}\", \n            context.address().name().unwrap_or(\"anonymous\"), \n            self.value);\n        Ok(())\n    }\n\n    async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"[Actor {}] Stopping with value: {}\", \n            context.address().name().unwrap_or(\"anonymous\"), \n            self.value);\n        Ok(())\n    }\n\n    async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        error: Self::Error,\n        _context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; ErrorAction {\n        eprintln!(\"Error: {}\", error);\n        ErrorAction::Restart  // Supervisor will restart this actor\n    }\n}\n</code></pre> <p>Run this example: <pre><code>cargo run --example actor_basic\n</code></pre></p>"},{"location":"components/rt/architecture/core-concepts/#message-system","title":"Message System","text":""},{"location":"components/rt/architecture/core-concepts/#message-trait","title":"Message Trait","text":"<p>All messages must implement the <code>Message</code> trait:</p> <pre><code>pub trait Message: Clone + Send + Sync + 'static \n    + for&lt;'de&gt; serde::Deserialize&lt;'de&gt; + serde::Serialize \n{\n    const MESSAGE_TYPE: &amp;'static str;\n}\n</code></pre>"},{"location":"components/rt/architecture/core-concepts/#message-envelope","title":"Message Envelope","text":"<p>Messages are wrapped in envelopes for routing:</p> <pre><code>pub struct MessageEnvelope&lt;M&gt; {\n    pub id: MessageId,\n    pub message: M,\n    pub timestamp: DateTime&lt;Utc&gt;,\n    pub reply_to: Option&lt;ActorAddress&gt;,\n}\n</code></pre>"},{"location":"components/rt/architecture/core-concepts/#message-broker","title":"Message Broker","text":"<p>The <code>MessageBroker</code> trait defines the pub/sub system:</p> <pre><code>#[async_trait]\npub trait MessageBroker&lt;M: Message&gt;: Clone + Send + Sync + 'static {\n    type Error: Error + Send + Sync + 'static;\n\n    async fn publish(&amp;self, envelope: MessageEnvelope&lt;M&gt;) \n        -&gt; Result&lt;(), Self::Error&gt;;\n\n    async fn subscribe(&amp;self, subscriber_id: ActorId) \n        -&gt; Result&lt;mpsc::Receiver&lt;MessageEnvelope&lt;M&gt;&gt;, Self::Error&gt;;\n}\n</code></pre> <p>Current implementation: <code>InMemoryMessageBroker</code> (see <code>src/broker/in_memory.rs</code>)</p>"},{"location":"components/rt/architecture/core-concepts/#supervision-framework","title":"Supervision Framework","text":""},{"location":"components/rt/architecture/core-concepts/#child-trait","title":"Child Trait","text":"<p>Any entity can be supervised by implementing the <code>Child</code> trait:</p> <pre><code>#[async_trait]\npub trait Child: Send + Sync {\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt;;\n    async fn stop(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt;;\n    async fn health_check(&amp;self) -&gt; ChildHealth;\n}\n</code></pre> <p>Actors automatically implement <code>Child</code> via blanket implementation.</p>"},{"location":"components/rt/architecture/core-concepts/#supervision-strategies","title":"Supervision Strategies","text":"<p>Three BEAM-inspired restart strategies:</p> <pre><code>pub enum RestartStrategy {\n    OneForOne,   // Restart only the failed child\n    OneForAll,   // Restart all children when one fails\n    RestForOne,  // Restart failed child and those started after it\n}\n</code></pre>"},{"location":"components/rt/architecture/core-concepts/#restart-policies","title":"Restart Policies","text":"<p>Control when children should be restarted:</p> <pre><code>pub enum RestartPolicy {\n    Permanent,   // Always restart on failure\n    Transient,   // Restart only on abnormal termination\n    Temporary,   // Never restart\n}\n</code></pre>"},{"location":"components/rt/architecture/core-concepts/#child-specification","title":"Child Specification","text":"<p>Configure supervised children:</p> <pre><code>pub struct ChildSpec {\n    pub id: ChildId,\n    pub restart_policy: RestartPolicy,\n    pub shutdown_policy: ShutdownPolicy,\n    pub significant: bool,  // Does failure affect supervisor?\n}\n</code></pre>"},{"location":"components/rt/architecture/core-concepts/#complete-supervisor-example","title":"Complete Supervisor Example","text":"<p>From <code>examples/supervisor_basic.rs</code>:</p> <pre><code>use airssys_rt::supervisor::{Child, ChildHealth, ChildSpec, RestartPolicy};\n\n// Define a worker that implements Child\nstruct SimpleWorker {\n    id: String,\n    fail_on_start: bool,\n}\n\n#[async_trait]\nimpl Child for SimpleWorker {\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        if self.fail_on_start {\n            return Err(format!(\"Worker {} failed to start\", self.id).into());\n        }\n        println!(\"Worker {} started\", self.id);\n        Ok(())\n    }\n\n    async fn stop(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        println!(\"Worker {} stopped\", self.id);\n        Ok(())\n    }\n\n    async fn health_check(&amp;self) -&gt; ChildHealth {\n        ChildHealth::Healthy\n    }\n}\n\n// Create supervisor with OneForOne strategy\nlet mut supervisor = SupervisorNode::new(\n    SupervisorId::new(),\n    OneForOne::new(),\n);\n\n// Add children\nsupervisor.add_child(\n    ChildSpec {\n        id: ChildId::new(),\n        restart_policy: RestartPolicy::Permanent,\n        shutdown_policy: ShutdownPolicy::default(),\n        significant: true,\n    },\n    Box::new(SimpleWorker {\n        id: \"worker-1\".to_string(),\n        fail_on_start: false,\n    }),\n).await?;\n</code></pre> <p>Run this example: <pre><code>cargo run --example supervisor_basic\n</code></pre></p>"},{"location":"components/rt/architecture/core-concepts/#actor-addressing","title":"Actor Addressing","text":""},{"location":"components/rt/architecture/core-concepts/#actoraddress","title":"ActorAddress","text":"<p>Actors are identified by addresses:</p> <pre><code>pub struct ActorAddress {\n    id: ActorId,\n    name: Option&lt;String&gt;,\n}\n\nimpl ActorAddress {\n    pub fn anonymous() -&gt; Self;\n    pub fn named(name: impl Into&lt;String&gt;) -&gt; Self;\n    pub fn id(&amp;self) -&gt; &amp;ActorId;\n    pub fn name(&amp;self) -&gt; Option&lt;&amp;str&gt;;\n}\n</code></pre>"},{"location":"components/rt/architecture/core-concepts/#actorid","title":"ActorId","text":"<p>Unique identifiers for actors:</p> <pre><code>pub struct ActorId(uuid::Uuid);\n\nimpl ActorId {\n    pub fn new() -&gt; Self {\n        Self(uuid::Uuid::new_v4())\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/core-concepts/#error-handling","title":"Error Handling","text":""},{"location":"components/rt/architecture/core-concepts/#erroraction","title":"ErrorAction","text":"<p>Actors return <code>ErrorAction</code> from <code>on_error</code> to control supervision:</p> <pre><code>pub enum ErrorAction {\n    Resume,       // Continue processing (ignore error)\n    Restart,      // Restart the actor\n    Stop,         // Stop the actor permanently\n    Escalate,     // Pass error to supervisor\n}\n</code></pre>"},{"location":"components/rt/architecture/core-concepts/#actor-error-flow","title":"Actor Error Flow","text":"<ol> <li>Actor's <code>handle_message</code> returns <code>Err(Self::Error)</code></li> <li>Supervisor calls actor's <code>on_error</code> method</li> <li>Actor returns <code>ErrorAction</code> to supervisor</li> <li>Supervisor applies restart strategy based on action</li> </ol>"},{"location":"components/rt/architecture/core-concepts/#architecture-layers","title":"Architecture Layers","text":"<p>The runtime is organized in layers:</p> <ol> <li>Message Layer (<code>src/message/</code>) - Message types and envelopes</li> <li>Broker Layer (<code>src/broker/</code>) - Pub/sub message routing</li> <li>Actor Layer (<code>src/actor/</code>) - Actor trait and context</li> <li>Mailbox Layer (<code>src/mailbox/</code>) - Message queue management</li> <li>Supervisor Layer (<code>src/supervisor/</code>) - Fault tolerance</li> <li>Monitoring Layer (<code>src/monitoring/</code>) - Health checks and metrics</li> <li>System Layer (<code>src/system/</code>) - Runtime coordination (planned)</li> </ol> <p>Each layer builds on the previous, following Microsoft Rust Guidelines (M-SIMPLE-ABSTRACTIONS).</p>"},{"location":"components/rt/architecture/core-concepts/#working-examples","title":"Working Examples","text":"<p>Explore these examples to understand the runtime:</p> Example Description Command <code>actor_basic.rs</code> Basic actor implementation <code>cargo run --example actor_basic</code> <code>actor_lifecycle.rs</code> Lifecycle hooks <code>cargo run --example actor_lifecycle</code> <code>supervisor_basic.rs</code> Basic supervision <code>cargo run --example supervisor_basic</code> <code>supervisor_strategies.rs</code> Restart strategies <code>cargo run --example supervisor_strategies</code> <code>supervisor_automatic_health.rs</code> Health monitoring <code>cargo run --example supervisor_automatic_health</code> <code>monitoring_basic.rs</code> Actor monitoring <code>cargo run --example monitoring_basic</code> <code>monitoring_supervisor.rs</code> Supervisor monitoring <code>cargo run --example monitoring_supervisor</code> <p>All examples are located in the <code>examples/</code> directory and demonstrate real, working implementations of the concepts described in this document.</p>"},{"location":"components/rt/architecture/message-passing/","title":"Message Passing System","text":"<p>The message passing system in <code>airssys-rt</code> provides high-performance pub-sub communication between actors following Erlang/OTP principles.</p> <p>Note: All code examples are from actual implementation. See examples directory for complete working code.</p>"},{"location":"components/rt/architecture/message-passing/#architecture-overview","title":"Architecture Overview","text":""},{"location":"components/rt/architecture/message-passing/#design-principles","title":"Design Principles","text":"<p>The message passing system is built on three core abstractions:</p> <ol> <li>Message Trait - Type-safe message contracts</li> <li>MessageBroker - Pub/sub routing system  </li> <li>Mailbox - Message queue management</li> </ol> <p>Performance Characteristics (from BENCHMARKING.md): - Point-to-point latency: 737 ns per roundtrip - Sustained throughput: 4.7M messages/second - Broadcast efficiency: 395 ns to 10 actors (~40 ns per subscriber) - Message processing: 31.55 ns/message (direct), 211.88 ns/message (via broker)</p>"},{"location":"components/rt/architecture/message-passing/#message-trait","title":"Message Trait","text":""},{"location":"components/rt/architecture/message-passing/#definition","title":"Definition","text":"<p>All messages must implement the <code>Message</code> trait (from <code>src/message/mod.rs</code>):</p> <pre><code>pub trait Message: Clone + Send + Sync + 'static \n    + for&lt;'de&gt; serde::Deserialize&lt;'de&gt; + serde::Serialize \n{\n    const MESSAGE_TYPE: &amp;'static str;\n}\n</code></pre> <p>Design Rationale: - <code>Clone</code>: Messages can be sent to multiple subscribers - <code>Send + Sync + 'static</code>: Thread-safe cross-actor messaging - <code>Serialize + Deserialize</code>: Future network/persistence support - <code>MESSAGE_TYPE</code>: Runtime type identification for routing</p>"},{"location":"components/rt/architecture/message-passing/#implementation-example","title":"Implementation Example","text":"<pre><code>use serde::{Deserialize, Serialize};\nuse airssys_rt::message::Message;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CounterMessage {\n    pub delta: i32,\n}\n\nimpl Message for CounterMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"counter\";\n}\n</code></pre>"},{"location":"components/rt/architecture/message-passing/#message-best-practices","title":"Message Best Practices","text":"<p>DO: - \u2705 Keep messages small and focused - \u2705 Use strongly-typed enums for variants - \u2705 Make fields <code>pub</code> for builder patterns - \u2705 Derive <code>Debug</code> for logging</p> <p>DON'T: - \u274c Include large data structures (use references/IDs) - \u274c Add non-serializable types - \u274c Mutate messages (they're cloned) - \u274c Use <code>Box&lt;dyn Trait&gt;</code> in messages</p>"},{"location":"components/rt/architecture/message-passing/#message-envelope","title":"Message Envelope","text":""},{"location":"components/rt/architecture/message-passing/#structure","title":"Structure","text":"<p>Messages are wrapped in envelopes for routing (from <code>src/message/envelope.rs</code>):</p> <pre><code>pub struct MessageEnvelope&lt;M&gt; {\n    pub id: MessageId,\n    pub message: M,\n    pub timestamp: DateTime&lt;Utc&gt;,  // \u00a73.2 chrono DateTime&lt;Utc&gt;\n    pub reply_to: Option&lt;ActorAddress&gt;,\n}\n</code></pre> <p>Fields: - <code>id</code>: Unique message identifier (UUID-based) - <code>message</code>: Actual message payload - <code>timestamp</code>: When envelope was created (UTC) - <code>reply_to</code>: Optional sender address for request/reply pattern</p>"},{"location":"components/rt/architecture/message-passing/#creation","title":"Creation","text":"<pre><code>use airssys_rt::message::MessageEnvelope;\nuse chrono::Utc;\n\nlet envelope = MessageEnvelope::new(CounterMessage { delta: 1 });\n// Sets id, timestamp automatically\n\n// With reply address\nlet envelope = MessageEnvelope {\n    id: MessageId::new(),\n    message: CounterMessage { delta: 1 },\n    timestamp: Utc::now(),\n    reply_to: Some(sender_address),\n};\n</code></pre>"},{"location":"components/rt/architecture/message-passing/#messagebroker-trait","title":"MessageBroker Trait","text":""},{"location":"components/rt/architecture/message-passing/#definition_1","title":"Definition","text":"<p>The pub/sub system for actor communication (from <code>src/broker/traits.rs</code>):</p> <pre><code>#[async_trait]\npub trait MessageBroker&lt;M: Message&gt;: Clone + Send + Sync + 'static {\n    type Error: Error + Send + Sync + 'static;\n\n    async fn publish(&amp;self, envelope: MessageEnvelope&lt;M&gt;) \n        -&gt; Result&lt;(), Self::Error&gt;;\n\n    async fn subscribe(&amp;self, subscriber_id: ActorId) \n        -&gt; Result&lt;mpsc::Receiver&lt;MessageEnvelope&lt;M&gt;&gt;, Self::Error&gt;;\n}\n</code></pre> <p>Design Rationale: - <code>Clone</code>: Brokers can be shared across actors (Arc internally) - Generic <code>&lt;M: Message&gt;</code>: Type-safe message routing - <code>async</code>: Non-blocking operations - Associated <code>Error</code>: Broker-specific error handling</p>"},{"location":"components/rt/architecture/message-passing/#publish-subscribe-pattern","title":"Publish-Subscribe Pattern","text":"<pre><code>// Publisher side\nlet broker = InMemoryMessageBroker::new();\nlet envelope = MessageEnvelope::new(my_message);\nbroker.publish(envelope).await?;\n\n// Subscriber side\nlet mut receiver = broker.subscribe(actor_id).await?;\nwhile let Some(envelope) = receiver.recv().await {\n    // Process envelope.message\n}\n</code></pre>"},{"location":"components/rt/architecture/message-passing/#inmemorymessagebroker","title":"InMemoryMessageBroker","text":""},{"location":"components/rt/architecture/message-passing/#implementation","title":"Implementation","text":"<p>Current production broker using Tokio channels (from <code>src/broker/in_memory.rs</code>):</p> <pre><code>#[derive(Clone)]\npub struct InMemoryMessageBroker&lt;M: Message&gt; {\n    subscribers: Arc&lt;Mutex&lt;HashMap&lt;ActorId, mpsc::Sender&lt;MessageEnvelope&lt;M&gt;&gt;&gt;&gt;&gt;,\n}\n\nimpl&lt;M: Message&gt; InMemoryMessageBroker&lt;M&gt; {\n    pub fn new() -&gt; Self {\n        Self {\n            subscribers: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n}\n</code></pre> <p>Characteristics: - Thread-safe: Arc + Mutex for multi-threaded access - Cheap Clone: Arc-based, no deep copy - Dynamic subscribers: Add/remove at runtime - Unbounded channels: No backpressure (see Mailbox for bounded queues)</p>"},{"location":"components/rt/architecture/message-passing/#performance-profile","title":"Performance Profile","text":"<p>Based on <code>benches/message_benchmarks.rs</code>:</p> Operation Latency Throughput Point-to-point 737 ns 1.36M messages/sec Sustained throughput (100 msgs) 211 ns/msg 4.7M messages/sec Broadcast to 10 actors 395 ns total ~40 ns/subscriber <p>Broker Overhead: - Direct actor processing: 31.55 ns/message - Via broker routing: 211.88 ns/message - 6.7x overhead - acceptable for pub-sub semantics</p>"},{"location":"components/rt/architecture/message-passing/#actor-context-messaging","title":"Actor Context Messaging","text":""},{"location":"components/rt/architecture/message-passing/#sending-messages","title":"Sending Messages","text":"<p>Actors send messages via their context (from <code>ActorContext</code>):</p> <pre><code>#[async_trait]\nimpl Actor for MyActor {\n    type Message = MyMessage;\n    type Error = MyError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        // Send to another actor\n        let recipient = ActorAddress::named(\"counter\");\n        context.send(\n            CounterMessage { delta: 1 },\n            recipient\n        ).await?;\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/message-passing/#request-reply-pattern","title":"Request-Reply Pattern","text":"<p>For synchronous-style communication (async underneath):</p> <pre><code>// Request side\nlet response = context.request(\n    QueryMessage { id: 42 },\n    target_address,\n    Duration::from_secs(5)  // timeout\n).await?;\n\n// Reply side (in target actor)\nasync fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    envelope: MessageEnvelope&lt;Self::Message&gt;,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    if let Some(reply_to) = envelope.reply_to {\n        let response = ResponseMessage { result: \"ok\" };\n        context.send(response, reply_to).await?;\n    }\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/architecture/message-passing/#mailbox-system","title":"Mailbox System","text":""},{"location":"components/rt/architecture/message-passing/#mailbox-types","title":"Mailbox Types","text":"<p>The runtime provides two mailbox implementations (from <code>src/mailbox/</code>):</p> <p>UnboundedMailbox - Unlimited capacity: <pre><code>pub struct UnboundedMailbox&lt;M: Message&gt; {\n    receiver: mpsc::UnboundedReceiver&lt;MessageEnvelope&lt;M&gt;&gt;,\n    metrics: Arc&lt;AtomicMetrics&gt;,\n}\n</code></pre></p> <p>BoundedMailbox - Limited capacity with backpressure: <pre><code>pub struct BoundedMailbox&lt;M: Message&gt; {\n    receiver: mpsc::Receiver&lt;MessageEnvelope&lt;M&gt;&gt;,\n    capacity: usize,\n    backpressure: BackpressureStrategy,\n    metrics: Arc&lt;AtomicMetrics&gt;,\n}\n</code></pre></p>"},{"location":"components/rt/architecture/message-passing/#backpressure-strategies","title":"Backpressure Strategies","text":"<pre><code>pub enum BackpressureStrategy {\n    Block,      // Block sender when mailbox full\n    Drop,       // Drop new messages when full\n    DropOldest, // Drop oldest message to make room\n}\n</code></pre> <p>Usage Guidelines: - Block: Critical messages that must be delivered - Drop: Optional updates (metrics, status) where latest is enough - DropOldest: Event streams where recent data matters most</p>"},{"location":"components/rt/architecture/message-passing/#performance-characteristics","title":"Performance Characteristics","text":"<p>From <code>benches/message_benchmarks.rs</code>:</p> Mailbox Operation Latency Enqueue + Dequeue (100 ops) 181.60 ns/operation Bounded mailbox (capacity 100) 244.18 ns/mailbox overhead <p>Mailbox operations are ~6x faster than broker routing (181 ns vs 211 ns), confirming Tokio channel efficiency.</p>"},{"location":"components/rt/architecture/message-passing/#mailbox-traits","title":"Mailbox Traits","text":"<p>Generic mailbox interface for testing and future backends:</p> <pre><code>#[async_trait]\npub trait MailboxReceiver&lt;M: Message&gt;: Send {\n    async fn recv(&amp;mut self) -&gt; Option&lt;MessageEnvelope&lt;M&gt;&gt;;\n    fn try_recv(&amp;mut self) -&gt; Result&lt;MessageEnvelope&lt;M&gt;, TryRecvError&gt;;\n}\n\n#[async_trait]\npub trait MailboxSender&lt;M: Message&gt;: Clone + Send + Sync {\n    async fn send(&amp;self, envelope: MessageEnvelope&lt;M&gt;) \n        -&gt; Result&lt;(), MailboxError&gt;;\n}\n</code></pre>"},{"location":"components/rt/architecture/message-passing/#message-flow-architecture","title":"Message Flow Architecture","text":""},{"location":"components/rt/architecture/message-passing/#complete-message-path","title":"Complete Message Path","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Sender      \u2502\n\u2502 Actor       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 1. context.send(message, recipient)\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ActorContext    \u2502\n\u2502 - Wraps message \u2502\n\u2502 - Creates       \u2502\n\u2502   envelope      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 2. broker.publish(envelope)\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 MessageBroker    \u2502\n\u2502 - Routes to      \u2502\n\u2502   subscribers    \u2502\n\u2502 - Clones for     \u2502\n\u2502   broadcast      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 3. mpsc::Sender \u2192 receivers\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Mailbox (queue)  \u2502\n\u2502 - Buffers        \u2502\n\u2502 - Backpressure   \u2502\n\u2502 - Metrics        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502 4. Receiver.recv()\n       \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Recipient Actor  \u2502\n\u2502 - handle_message \u2502\n\u2502 - Process logic  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"components/rt/architecture/message-passing/#latency-breakdown","title":"Latency Breakdown","text":"<p>Based on benchmark measurements:</p> <ol> <li>Message wrapping: ~10 ns (allocation + timestamp)</li> <li>Broker routing: ~180 ns (mutex + channel send)</li> <li>Mailbox buffering: ~20 ns (queue operation)</li> <li>Actor processing: 31-200 ns (depends on logic)</li> </ol> <p>Total roundtrip: 737 ns (sub-microsecond)</p>"},{"location":"components/rt/architecture/message-passing/#communication-patterns","title":"Communication Patterns","text":""},{"location":"components/rt/architecture/message-passing/#fire-and-forget","title":"Fire-and-Forget","text":"<pre><code>// No response expected\ncontext.send(\n    NotificationMessage { event: \"started\" },\n    monitor_address\n).await?;\n</code></pre>"},{"location":"components/rt/architecture/message-passing/#request-reply","title":"Request-Reply","text":"<pre><code>// Wait for response with timeout\nlet response = context.request(\n    QueryMessage { id: 42 },\n    database_actor,\n    Duration::from_secs(5)\n).await?;\n</code></pre>"},{"location":"components/rt/architecture/message-passing/#broadcast","title":"Broadcast","text":"<pre><code>// MessageBroker automatically broadcasts to all subscribers\nbroker.publish(\n    MessageEnvelope::new(BroadcastMessage { alert: \"shutdown\" })\n).await?;\n</code></pre>"},{"location":"components/rt/architecture/message-passing/#actor-pools","title":"Actor Pools","text":"<p>From <code>examples/worker_pool.rs</code>:</p> <pre><code>// Round-robin distribution to worker pool\nlet worker_id = self.next_worker;\nself.next_worker = (self.next_worker + 1) % self.workers.len();\n\ncontext.send(\n    WorkMessage { task_id },\n    self.workers[worker_id].clone()\n).await?;\n</code></pre>"},{"location":"components/rt/architecture/message-passing/#error-handling","title":"Error Handling","text":""},{"location":"components/rt/architecture/message-passing/#broker-errors","title":"Broker Errors","text":"<pre><code>#[derive(Debug)]\npub enum BrokerError {\n    SubscriberNotFound(ActorId),\n    ChannelClosed,\n    SendError(String),\n}\n</code></pre> <p>Recovery Strategies: - <code>SubscriberNotFound</code>: Retry with discovery or fail gracefully - <code>ChannelClosed</code>: Cleanup subscriber, log issue - <code>SendError</code>: Escalate to supervisor</p>"},{"location":"components/rt/architecture/message-passing/#mailbox-errors","title":"Mailbox Errors","text":"<pre><code>#[derive(Debug)]\npub enum MailboxError {\n    Full,           // Bounded mailbox at capacity\n    Closed,         // Receiver dropped\n    Timeout,        // Receive timeout exceeded\n}\n</code></pre> <p>Handling Guidelines: - Full + Block: Automatic backpressure (sender waits) - Full + Drop: Log dropped message, continue - Closed: Stop sending, cleanup references - Timeout: Retry or escalate based on criticality</p>"},{"location":"components/rt/architecture/message-passing/#performance-optimization","title":"Performance Optimization","text":""},{"location":"components/rt/architecture/message-passing/#message-design","title":"Message Design","text":"<p>Optimize for: - Small message size (&lt;100 bytes ideal) - Cheap cloning (primitives, small vecs) - Serialization efficiency (serde derives)</p> <p>Avoid: - Large vecs/strings (use Arc or IDs) - Boxed trait objects (static dispatch preferred) - Deep nesting (flattens better)</p>"},{"location":"components/rt/architecture/message-passing/#broker-selection","title":"Broker Selection","text":"<p>InMemoryMessageBroker: - \u2705 Low latency (737 ns roundtrip) - \u2705 High throughput (4.7M msgs/sec) - \u2705 Simple, correct, fast - \u274c Single-process only - \u274c No persistence</p> <p>Future brokers (planned): - Distributed broker (network routing) - Persistent broker (durability) - Sharded broker (horizontal scaling)</p>"},{"location":"components/rt/architecture/message-passing/#mailbox-tuning","title":"Mailbox Tuning","text":"<p>Unbounded: - Use for: Control messages, low-volume actors - Avoids: Backpressure complexity - Risk: Unbounded memory growth</p> <p>Bounded: - Use for: High-volume data streams - Capacity: 100-1000 typical (balance latency vs memory) - Strategy: Match to use case (Block/Drop/DropOldest)</p>"},{"location":"components/rt/architecture/message-passing/#testing-patterns","title":"Testing Patterns","text":""},{"location":"components/rt/architecture/message-passing/#unit-testing-messages","title":"Unit Testing Messages","text":"<pre><code>#[test]\nfn test_message_serialization() {\n    let msg = CounterMessage { delta: 42 };\n    let json = serde_json::to_string(&amp;msg).unwrap();\n    let deserialized: CounterMessage = serde_json::from_str(&amp;json).unwrap();\n    assert_eq!(msg.delta, deserialized.delta);\n}\n</code></pre>"},{"location":"components/rt/architecture/message-passing/#integration-testing-broker","title":"Integration Testing Broker","text":"<pre><code>#[tokio::test]\nasync fn test_pub_sub_roundtrip() {\n    let broker = InMemoryMessageBroker::new();\n    let actor_id = ActorId::new();\n\n    let mut receiver = broker.subscribe(actor_id).await.unwrap();\n\n    let message = TestMessage { value: 42 };\n    broker.publish(MessageEnvelope::new(message.clone())).await.unwrap();\n\n    let envelope = receiver.recv().await.unwrap();\n    assert_eq!(envelope.message.value, 42);\n}\n</code></pre>"},{"location":"components/rt/architecture/message-passing/#working-examples","title":"Working Examples","text":"<p>Explore message passing in these examples:</p> Example Demonstrates Command <code>actor_basic.rs</code> Simple message handling <code>cargo run --example actor_basic</code> <code>worker_pool.rs</code> Round-robin message routing <code>cargo run --example worker_pool</code> <code>event_pipeline.rs</code> Message-driven pipeline <code>cargo run --example event_pipeline</code> <p>All examples are in the <code>examples/</code> directory with complete, runnable implementations.</p>"},{"location":"components/rt/architecture/process-lifecycle/","title":"Process Lifecycle","text":"<p>The process lifecycle system in <code>airssys-rt</code> manages actor state transitions, restart tracking, and supervision integration following Erlang/OTP principles.</p> <p>Note: All code examples are from actual implementation. See examples directory for complete working code.</p>"},{"location":"components/rt/architecture/process-lifecycle/#architecture-overview","title":"Architecture Overview","text":""},{"location":"components/rt/architecture/process-lifecycle/#design-principles","title":"Design Principles","text":"<p>The lifecycle system provides:</p> <ol> <li>State Machine - Well-defined actor states and transitions</li> <li>Lifecycle Hooks - Initialization and cleanup callbacks</li> <li>Restart Tracking - Failure counting and state change history</li> <li>Supervision Integration - Error actions and restart policies</li> </ol> <p>Performance Characteristics (from BENCHMARKING.md): - Actor spawn: 624.74 ns (single), 681.40 ns/actor (batch of 10) - Lifecycle transition: Sub-nanosecond (enum assignment) - Restart overhead: 10-50 \u00b5s (includes stop \u2192 start hooks)</p>"},{"location":"components/rt/architecture/process-lifecycle/#actor-state-machine","title":"Actor State Machine","text":""},{"location":"components/rt/architecture/process-lifecycle/#state-definitions","title":"State Definitions","text":"<p>Actors transition through defined states (from <code>src/actor/lifecycle.rs</code>):</p> <pre><code>#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ActorState {\n    Starting,   // Actor is initializing\n    Running,    // Actor is active and processing messages\n    Stopping,   // Actor is shutting down\n    Stopped,    // Actor has stopped successfully\n    Failed,     // Actor has failed (requires supervision)\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#state-transitions","title":"State Transitions","text":"<p>Valid transitions in the state machine:</p> <pre><code>           start()\n  Starting \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; Running\n     \u2502                 \u2502\n     \u2502 error           \u2502 stop()\n     \u25bc                 \u25bc\n  Failed            Stopping\n                       \u2502\n                       \u2502 cleanup\n                       \u25bc\n                    Stopped\n                       \u2502\n                       \u2502 restart\n                       \u25bc\n                    Starting\n</code></pre> <p>Key Properties: - Starting \u2192 Running: Successful initialization - Starting \u2192 Failed: Initialization error - Running \u2192 Stopping: Graceful shutdown request - Running \u2192 Failed: Runtime error - Stopping \u2192 Stopped: Successful cleanup - Stopped \u2192 Starting: Supervisor restart</p>"},{"location":"components/rt/architecture/process-lifecycle/#state-query-methods","title":"State Query Methods","text":"<pre><code>impl ActorLifecycle {\n    /// Check if actor is in terminal state (Stopped or Failed)\n    pub fn is_terminal(&amp;self) -&gt; bool {\n        matches!(self.state, ActorState::Stopped | ActorState::Failed)\n    }\n\n    /// Check if actor is actively running\n    pub fn is_running(&amp;self) -&gt; bool {\n        self.state == ActorState::Running\n    }\n\n    /// Check if actor can accept messages\n    pub fn can_process_messages(&amp;self) -&gt; bool {\n        self.state == ActorState::Running\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#actorlifecycle-structure","title":"ActorLifecycle Structure","text":""},{"location":"components/rt/architecture/process-lifecycle/#definition","title":"Definition","text":"<p>State management structure (from <code>src/actor/lifecycle.rs</code>):</p> <pre><code>#[derive(Debug, Clone)]\npub struct ActorLifecycle {\n    state: ActorState,\n    last_state_change: DateTime&lt;Utc&gt;,  // \u00a73.2 chrono DateTime&lt;Utc&gt;\n    restart_count: u32,\n}\n</code></pre> <p>Fields: - <code>state</code>: Current actor state - <code>last_state_change</code>: When state last changed (UTC timestamp) - <code>restart_count</code>: Number of times actor has been restarted</p>"},{"location":"components/rt/architecture/process-lifecycle/#creation-and-management","title":"Creation and Management","text":"<pre><code>impl ActorLifecycle {\n    /// Create new lifecycle in Starting state\n    pub fn new() -&gt; Self {\n        Self {\n            state: ActorState::Starting,\n            last_state_change: Utc::now(),\n            restart_count: 0,\n        }\n    }\n\n    /// Get current state\n    pub fn state(&amp;self) -&gt; ActorState {\n        self.state\n    }\n\n    /// Transition to new state\n    pub fn transition_to(&amp;mut self, new_state: ActorState) {\n        self.state = new_state;\n        self.last_state_change = Utc::now();\n    }\n\n    /// Get restart count\n    pub fn restart_count(&amp;self) -&gt; u32 {\n        self.restart_count\n    }\n\n    /// Increment restart counter\n    pub fn record_restart(&amp;mut self) {\n        self.restart_count += 1;\n    }\n\n    /// Get time of last state change\n    pub fn last_state_change(&amp;self) -&gt; DateTime&lt;Utc&gt; {\n        self.last_state_change\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#lifecycle-hooks","title":"Lifecycle Hooks","text":""},{"location":"components/rt/architecture/process-lifecycle/#actor-trait-hooks","title":"Actor Trait Hooks","text":"<p>Actors can override lifecycle callbacks (from <code>src/actor/traits.rs</code>):</p> <pre><code>#[async_trait]\npub trait Actor: Send + Sync + 'static {\n    type Message: Message;\n    type Error: Error + Send + Sync + 'static;\n\n    /// Called before actor starts processing messages\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        Ok(())  // Default: no-op\n    }\n\n    /// Called when actor is stopping\n    async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        Ok(())  // Default: no-op\n    }\n\n    /// Handle errors and return supervision decision\n    async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        error: Self::Error,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; ErrorAction {\n        ErrorAction::Restart  // Default: restart on error\n    }\n\n    /// Handle incoming message (required)\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt;;\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#hook-usage-patterns","title":"Hook Usage Patterns","text":"<p>pre_start - Initialization: <pre><code>async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    println!(\"Actor {} starting\", context.address().name().unwrap_or(\"anonymous\"));\n\n    // Initialize resources\n    self.database = Some(Database::connect().await?);\n    self.cache = Cache::new();\n\n    // Subscribe to events\n    context.subscribe(\"system-events\").await?;\n\n    Ok(())\n}\n</code></pre></p> <p>post_stop - Cleanup: <pre><code>async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    println!(\"Actor {} stopping\", context.address().name().unwrap_or(\"anonymous\"));\n\n    // Release resources\n    if let Some(db) = self.database.take() {\n        db.disconnect().await?;\n    }\n\n    // Unsubscribe from events\n    context.unsubscribe(\"system-events\").await?;\n\n    Ok(())\n}\n</code></pre></p> <p>on_error - Error handling: <pre><code>async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    error: Self::Error,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; ErrorAction {\n    eprintln!(\"Actor {} error: {}\", context.id(), error);\n\n    match error {\n        MyError::Recoverable(_) =&gt; ErrorAction::Resume,\n        MyError::RestartRequired(_) =&gt; ErrorAction::Restart,\n        MyError::Fatal(_) =&gt; ErrorAction::Stop,\n        MyError::SystemIssue(_) =&gt; ErrorAction::Escalate,\n    }\n}\n</code></pre></p> <p>See <code>examples/actor_lifecycle.rs</code> for complete lifecycle hook examples.</p>"},{"location":"components/rt/architecture/process-lifecycle/#lifecycle-execution-flow","title":"Lifecycle Execution Flow","text":""},{"location":"components/rt/architecture/process-lifecycle/#normal-startup","title":"Normal Startup","text":"<pre><code>1. SupervisorNode::start_child(spec, child)\n   \u2193\n2. ActorLifecycle::new() \u2192 state = Starting\n   \u2193\n3. Actor::pre_start(context) \u2192 initialize resources\n   \u2193\n4. lifecycle.transition_to(Running) \u2192 state = Running\n   \u2193\n5. Actor starts processing messages\n</code></pre> <p>Timing: - Steps 1-4: ~624 ns for actor spawn (measured) - <code>pre_start()</code>: Depends on initialization logic (aim for &lt;10ms)</p>"},{"location":"components/rt/architecture/process-lifecycle/#normal-shutdown","title":"Normal Shutdown","text":"<pre><code>1. SupervisorNode::stop_child(child_id)\n   \u2193\n2. lifecycle.transition_to(Stopping) \u2192 state = Stopping\n   \u2193\n3. Actor::post_stop(context) \u2192 cleanup resources\n   \u2193\n4. lifecycle.transition_to(Stopped) \u2192 state = Stopped\n</code></pre> <p>Timing: - Steps 2-4: ~10-50 \u00b5s typical (depends on cleanup logic)</p>"},{"location":"components/rt/architecture/process-lifecycle/#failure-and-restart","title":"Failure and Restart","text":"<pre><code>1. Actor::handle_message() \u2192 returns Err(error)\n   \u2193\n2. lifecycle.transition_to(Failed) \u2192 state = Failed\n   \u2193\n3. Supervisor detects failure\n   \u2193\n4. Actor::on_error(error, context) \u2192 returns ErrorAction\n   \u2193\n5. Supervisor applies restart strategy\n   \u2193\n   a. OneForOne: restart only this actor\n   b. OneForAll: restart all children\n   c. RestForOne: restart this + subsequent children\n   \u2193\n6. lifecycle.record_restart() \u2192 restart_count++\n   \u2193\n7. Actor::post_stop() \u2192 cleanup failed state\n   \u2193\n8. lifecycle.transition_to(Starting) \u2192 state = Starting\n   \u2193\n9. Actor::pre_start() \u2192 reinitialize\n   \u2193\n10. lifecycle.transition_to(Running) \u2192 state = Running\n</code></pre> <p>Timing: - Complete restart cycle: 10-50 \u00b5s (OneForOne) - Complete restart cycle: 30-150 \u00b5s (OneForAll, 3 children)</p>"},{"location":"components/rt/architecture/process-lifecycle/#error-actions","title":"Error Actions","text":""},{"location":"components/rt/architecture/process-lifecycle/#erroraction-enum","title":"ErrorAction Enum","text":"<p>Actors return <code>ErrorAction</code> from <code>on_error</code> to control supervision (from <code>src/actor/traits.rs</code>):</p> <pre><code>#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ErrorAction {\n    Resume,    // Continue processing (ignore error)\n    Restart,   // Restart the actor\n    Stop,      // Stop the actor permanently\n    Escalate,  // Pass error to supervisor\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#action-semantics","title":"Action Semantics","text":"<p>Resume - Transient error, continue: <pre><code>async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    error: Self::Error,\n    _context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; ErrorAction {\n    match error {\n        MyError::Timeout =&gt; {\n            eprintln!(\"Timeout, will retry next message\");\n            ErrorAction::Resume  // Continue processing\n        }\n        _ =&gt; ErrorAction::Restart,\n    }\n}\n</code></pre></p> <p>Restart - Recoverable error, reset state: <pre><code>ErrorAction::Restart  // Supervisor will stop \u2192 start actor\n</code></pre></p> <p>Stop - Unrecoverable error, terminate: <pre><code>MyError::ConfigurationInvalid(_) =&gt; {\n    eprintln!(\"Invalid configuration, cannot continue\");\n    ErrorAction::Stop  // Supervisor won't restart\n}\n</code></pre></p> <p>Escalate - Supervisor decision needed: <pre><code>MyError::SystemFailure(_) =&gt; {\n    eprintln!(\"System-level failure, escalating to supervisor\");\n    ErrorAction::Escalate  // Let supervisor handle\n}\n</code></pre></p>"},{"location":"components/rt/architecture/process-lifecycle/#restart-tracking","title":"Restart Tracking","text":""},{"location":"components/rt/architecture/process-lifecycle/#restart-counter","title":"Restart Counter","text":"<p>Track restart frequency for monitoring:</p> <pre><code>let lifecycle = actor_context.lifecycle();\nprintln!(\"Actor has been restarted {} times\", lifecycle.restart_count());\n\nif lifecycle.restart_count() &gt; 10 {\n    eprintln!(\"Warning: Actor restarting frequently, check for issues\");\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#restart-rate-limiting","title":"Restart Rate Limiting","text":"<p>Prevent restart storms with rate limiting (not yet implemented, planned):</p> <pre><code>// Future enhancement\npub struct RestartRateLimiter {\n    max_restarts: u32,\n    time_window: Duration,\n    restart_history: VecDeque&lt;DateTime&lt;Utc&gt;&gt;,\n}\n\nimpl RestartRateLimiter {\n    pub fn should_allow_restart(&amp;mut self) -&gt; bool {\n        let now = Utc::now();\n        let cutoff = now - self.time_window;\n\n        // Remove old restarts\n        self.restart_history.retain(|&amp;time| time &gt; cutoff);\n\n        // Check limit\n        if self.restart_history.len() &gt;= self.max_restarts as usize {\n            false  // Too many restarts, give up\n        } else {\n            self.restart_history.push_back(now);\n            true\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#integration-with-supervision","title":"Integration with Supervision","text":""},{"location":"components/rt/architecture/process-lifecycle/#child-trait-implementation","title":"Child Trait Implementation","text":"<p>Actors implement <code>Child</code> trait for supervision (from <code>src/supervisor/child.rs</code>):</p> <pre><code>#[async_trait]\nimpl&lt;A: Actor&gt; Child for A {\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        // Calls Actor::pre_start internally\n        self.pre_start(&amp;mut context).await\n            .map_err(|e| Box::new(e) as Box&lt;dyn Error + Send + Sync&gt;)\n    }\n\n    async fn stop(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        // Calls Actor::post_stop internally\n        self.post_stop(&amp;mut context).await\n            .map_err(|e| Box::new(e) as Box&lt;dyn Error + Send + Sync&gt;)\n    }\n\n    async fn health_check(&amp;self) -&gt; ChildHealth {\n        // Default implementation, can be overridden\n        if self.lifecycle.is_running() {\n            ChildHealth::Healthy\n        } else {\n            ChildHealth::Unhealthy(format!(\"State: {:?}\", self.lifecycle.state()))\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#restart-policy-integration","title":"Restart Policy Integration","text":"<p>Restart policies control when <code>Child::start()</code> is called:</p> <pre><code>// In Supervisor\nasync fn handle_child_failure(&amp;mut self, child_id: &amp;ChildId) -&gt; Result&lt;(), SupervisorError&gt; {\n    let (spec, child) = self.find_child_mut(child_id)?;\n\n    match spec.restart_policy {\n        RestartPolicy::Permanent =&gt; {\n            // Always restart\n            child.stop().await?;\n            child.lifecycle.record_restart();\n            child.lifecycle.transition_to(ActorState::Starting);\n            child.start().await?;\n            child.lifecycle.transition_to(ActorState::Running);\n        }\n        RestartPolicy::Transient =&gt; {\n            // Restart only if abnormal termination\n            if child.lifecycle.state() == ActorState::Failed {\n                child.stop().await?;\n                child.lifecycle.record_restart();\n                child.lifecycle.transition_to(ActorState::Starting);\n                child.start().await?;\n                child.lifecycle.transition_to(ActorState::Running);\n            }\n        }\n        RestartPolicy::Temporary =&gt; {\n            // Never restart, just cleanup\n            child.stop().await?;\n            child.lifecycle.transition_to(ActorState::Stopped);\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#best-practices","title":"Best Practices","text":""},{"location":"components/rt/architecture/process-lifecycle/#lifecycle-hook-design","title":"Lifecycle Hook Design","text":"<p>DO: - \u2705 Keep <code>pre_start()</code> fast (&lt;10ms ideal) for quick spawning - \u2705 Make <code>post_stop()</code> idempotent (safe to call multiple times) - \u2705 Handle all resource cleanup in <code>post_stop()</code> - \u2705 Use <code>on_error()</code> for fine-grained error handling - \u2705 Log state transitions for debugging</p> <p>DON'T: - \u274c Block indefinitely in lifecycle hooks - \u274c Ignore errors in <code>pre_start()</code> (return proper errors) - \u274c Leave resources open if <code>post_stop()</code> fails - \u274c Use <code>panic!()</code> in lifecycle hooks (return errors) - \u274c Assume <code>pre_start()</code> always completes (may fail)</p>"},{"location":"components/rt/architecture/process-lifecycle/#error-action-selection","title":"Error Action Selection","text":"<p>Resume: - Use for: Transient network errors, timeouts, retryable operations - Example: HTTP request timeout, temporary database unavailable - Effect: Actor continues with current state</p> <p>Restart: - Use for: Corrupted state, logical errors, recoverable failures - Example: Invalid state detected, cache corruption, connection lost - Effect: Actor stops, cleans up, and restarts fresh</p> <p>Stop: - Use for: Configuration errors, unrecoverable failures, fatal issues - Example: Invalid config file, missing required resource, critical bug - Effect: Actor stops permanently, supervisor won't restart (unless Permanent policy)</p> <p>Escalate: - Use for: System-level issues, supervisor decision needed - Example: Disk full, out of memory, authentication service down - Effect: Supervisor handles based on its strategy</p>"},{"location":"components/rt/architecture/process-lifecycle/#state-validation","title":"State Validation","text":"<pre><code>impl MyActor {\n    /// Validate actor is in correct state for operation\n    fn ensure_running(&amp;self) -&gt; Result&lt;(), MyError&gt; {\n        if !self.lifecycle.is_running() {\n            return Err(MyError::NotRunning {\n                current_state: self.lifecycle.state(),\n            });\n        }\n        Ok(())\n    }\n\n    /// Check if actor is healthy\n    fn is_healthy(&amp;self) -&gt; bool {\n        self.lifecycle.is_running() &amp;&amp; \n        self.lifecycle.restart_count() &lt; 10 &amp;&amp;\n        self.connection.is_some()\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"components/rt/architecture/process-lifecycle/#lifecycle-metrics","title":"Lifecycle Metrics","text":"<p>Track lifecycle events for monitoring:</p> <pre><code>use airssys_rt::monitoring::ActorMetrics;\n\nimpl MyActor {\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        // Record startup\n        metrics::increment_counter!(\"actor_starts_total\", \n            \"actor\" =&gt; context.address().name().unwrap_or(\"unknown\"));\n\n        let start_time = Instant::now();\n\n        // Initialize\n        self.initialize().await?;\n\n        // Record startup duration\n        metrics::histogram!(\"actor_start_duration_seconds\", \n            start_time.elapsed().as_secs_f64(),\n            \"actor\" =&gt; context.address().name().unwrap_or(\"unknown\"));\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#restart-alerts","title":"Restart Alerts","text":"<p>Monitor restart frequency:</p> <pre><code>async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    error: Self::Error,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; ErrorAction {\n    let restart_count = context.lifecycle().restart_count();\n\n    if restart_count &gt; 5 {\n        eprintln!(\"WARNING: Actor {} has restarted {} times\", \n            context.id(), restart_count);\n\n        // Alert monitoring system\n        metrics::increment_counter!(\"actor_restart_threshold_exceeded\",\n            \"actor\" =&gt; context.address().name().unwrap_or(\"unknown\"),\n            \"restart_count\" =&gt; restart_count.to_string());\n    }\n\n    ErrorAction::Restart\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#testing-patterns","title":"Testing Patterns","text":""},{"location":"components/rt/architecture/process-lifecycle/#lifecycle-testing","title":"Lifecycle Testing","text":"<pre><code>#[tokio::test]\nasync fn test_actor_lifecycle() {\n    let mut actor = MyActor::new();\n    let broker = InMemoryMessageBroker::new();\n    let mut context = ActorContext::new(\n        ActorAddress::named(\"test\"),\n        broker,\n    );\n\n    // Test initialization\n    actor.pre_start(&amp;mut context).await.expect(\"pre_start failed\");\n    assert_eq!(actor.lifecycle.state(), ActorState::Running);\n\n    // Test shutdown\n    actor.post_stop(&amp;mut context).await.expect(\"post_stop failed\");\n    assert_eq!(actor.lifecycle.state(), ActorState::Stopped);\n}\n\n#[tokio::test]\nasync fn test_error_handling() {\n    let mut actor = MyActor::new();\n    let broker = InMemoryMessageBroker::new();\n    let mut context = ActorContext::new(\n        ActorAddress::named(\"test\"),\n        broker,\n    );\n\n    // Trigger error\n    let error = MyError::Temporary(\"test error\".to_string());\n    let action = actor.on_error(error, &amp;mut context).await;\n\n    // Verify error action\n    assert_eq!(action, ErrorAction::Restart);\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#state-transition-testing","title":"State Transition Testing","text":"<pre><code>#[test]\nfn test_state_transitions() {\n    let mut lifecycle = ActorLifecycle::new();\n    assert_eq!(lifecycle.state(), ActorState::Starting);\n\n    lifecycle.transition_to(ActorState::Running);\n    assert_eq!(lifecycle.state(), ActorState::Running);\n    assert!(lifecycle.is_running());\n\n    lifecycle.transition_to(ActorState::Failed);\n    assert_eq!(lifecycle.state(), ActorState::Failed);\n    assert!(lifecycle.is_terminal());\n\n    lifecycle.record_restart();\n    assert_eq!(lifecycle.restart_count(), 1);\n}\n</code></pre>"},{"location":"components/rt/architecture/process-lifecycle/#working-examples","title":"Working Examples","text":"<p>Explore process lifecycle in these examples:</p> Example Demonstrates Command <code>actor_lifecycle.rs</code> Complete lifecycle hooks <code>cargo run --example actor_lifecycle</code> <code>actor_basic.rs</code> Basic lifecycle flow <code>cargo run --example actor_basic</code> <code>supervisor_basic.rs</code> Restart lifecycle <code>cargo run --example supervisor_basic</code> <code>supervisor_strategies.rs</code> Error actions and restart <code>cargo run --example supervisor_strategies</code> <p>All examples are in the <code>examples/</code> directory with complete, runnable implementations.</p>"},{"location":"components/rt/architecture/supervision/","title":"Supervisor Trees","text":"<p>The supervision system in <code>airssys-rt</code> provides Erlang/OTP-inspired fault tolerance with builder-based configuration and automatic health monitoring.</p> <p>Note: All code examples are from actual implementation (RT-TASK-013). See examples directory for complete working code.</p>"},{"location":"components/rt/architecture/supervision/#architecture-overview","title":"Architecture Overview","text":""},{"location":"components/rt/architecture/supervision/#design-principles","title":"Design Principles","text":"<p>The supervision system is built on three core concepts:</p> <ol> <li>Child Trait - Supervised entity contract</li> <li>Restart Strategies - Failure propagation control (OneForOne, OneForAll, RestForOne)</li> <li>Builder Pattern - Type-safe supervisor configuration (RT-TASK-013)</li> </ol> <p>Performance Characteristics (from BENCHMARKING.md): - Child spawn: 5-20 \u00b5s per child (builder API) - OneForOne restart: 10-50 \u00b5s (stop \u2192 start cycle) - OneForAll restart: 30-150 \u00b5s for 3 children (~3x OneForOne) - Supervision tree creation: 20-100 \u00b5s for supervisor + 3 children</p>"},{"location":"components/rt/architecture/supervision/#child-trait","title":"Child Trait","text":""},{"location":"components/rt/architecture/supervision/#definition","title":"Definition","text":"<p>Any entity can be supervised by implementing the <code>Child</code> trait (from <code>src/supervisor/child.rs</code>):</p> <pre><code>#[async_trait]\npub trait Child: Send + Sync {\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt;;\n    async fn stop(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt;;\n    async fn health_check(&amp;self) -&gt; ChildHealth;\n}\n</code></pre> <p>Design Rationale: - <code>start/stop</code>: Lifecycle control for supervisor restarts - <code>health_check</code>: Automatic monitoring integration - <code>Send + Sync</code>: Multi-threaded supervision support - Actors automatically implement <code>Child</code> via blanket implementation</p>"},{"location":"components/rt/architecture/supervision/#health-status","title":"Health Status","text":"<pre><code>#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ChildHealth {\n    Healthy,\n    Unhealthy(String),  // Reason for unhealthy state\n    Unknown,            // Health check failed or not implemented\n}\n</code></pre>"},{"location":"components/rt/architecture/supervision/#example-implementation","title":"Example Implementation","text":"<pre><code>use airssys_rt::supervisor::{Child, ChildHealth};\n\nstruct DatabaseWorker {\n    connection: Option&lt;Connection&gt;,\n}\n\n#[async_trait]\nimpl Child for DatabaseWorker {\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        println!(\"DatabaseWorker starting...\");\n        self.connection = Some(Connection::new().await?);\n        Ok(())\n    }\n\n    async fn stop(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error + Send + Sync&gt;&gt; {\n        println!(\"DatabaseWorker stopping...\");\n        if let Some(conn) = self.connection.take() {\n            conn.close().await?;\n        }\n        Ok(())\n    }\n\n    async fn health_check(&amp;self) -&gt; ChildHealth {\n        match &amp;self.connection {\n            Some(conn) if conn.is_alive() =&gt; ChildHealth::Healthy,\n            Some(_) =&gt; ChildHealth::Unhealthy(\"Connection lost\".to_string()),\n            None =&gt; ChildHealth::Unhealthy(\"Not connected\".to_string()),\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/supervision/#restart-strategies","title":"Restart Strategies","text":""},{"location":"components/rt/architecture/supervision/#strategy-types","title":"Strategy Types","text":"<p>Three BEAM-inspired strategies (from <code>src/supervisor/strategy.rs</code>):</p> <pre><code>pub enum RestartStrategy {\n    OneForOne,   // Restart only the failed child\n    OneForAll,   // Restart all children when one fails\n    RestForOne,  // Restart failed child and those started after it\n}\n</code></pre>"},{"location":"components/rt/architecture/supervision/#oneforone-strategy","title":"OneForOne Strategy","text":"<p>Behavior: Only the failed child is restarted.</p> <p>Use case: Independent children where one failure doesn't affect others.</p> <pre><code>Before failure:        After restart:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Supervisor  \u2502       \u2502 Supervisor  \u2502\n\u2514\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2500\u2518\n   \u2502  \u2502  \u2502               \u2502  \u2502  \u2502\n   A  B  C               A  B' C\n      \u2717                     \u21bb\n</code></pre> <p>Example: Worker pool where each worker processes independent tasks.</p> <pre><code>use airssys_rt::supervisor::{SupervisorNode, OneForOne};\n\nlet mut supervisor = SupervisorNode::builder()\n    .with_strategy(OneForOne::new())\n    .build()?;\n</code></pre> <p>See <code>examples/worker_pool.rs</code> for complete implementation.</p>"},{"location":"components/rt/architecture/supervision/#oneforall-strategy","title":"OneForAll Strategy","text":"<p>Behavior: All children are restarted when any child fails.</p> <p>Use case: Dependent children where all must be in consistent state.</p> <pre><code>Before failure:        After restart:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Supervisor  \u2502       \u2502 Supervisor  \u2502\n\u2514\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2500\u2518\n   \u2502  \u2502  \u2502               \u2502  \u2502  \u2502\n   A  B  C               A' B' C'\n      \u2717                  \u21bb  \u21bb  \u21bb\n</code></pre> <p>Example: Cache, database connection pool, configuration loader that must stay synchronized.</p> <pre><code>let mut supervisor = SupervisorNode::builder()\n    .with_strategy(OneForAll::new())\n    .build()?;\n</code></pre>"},{"location":"components/rt/architecture/supervision/#restforone-strategy","title":"RestForOne Strategy","text":"<p>Behavior: Restart failed child and all children started after it.</p> <p>Use case: Pipeline where later stages depend on earlier stages.</p> <pre><code>Before failure:        After restart:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Supervisor  \u2502       \u2502 Supervisor  \u2502\n\u2514\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2500\u2518\n   \u2502  \u2502  \u2502               \u2502  \u2502  \u2502\n   A  B  C               A  B' C'\n      \u2717                     \u21bb  \u21bb\n</code></pre> <p>Example: Event processing pipeline: Collector \u2192 Transformer \u2192 Writer.</p> <pre><code>let mut supervisor = SupervisorNode::builder()\n    .with_strategy(RestForOne::new())\n    .build()?;\n</code></pre> <p>See <code>examples/event_pipeline.rs</code> for complete RestForOne implementation.</p>"},{"location":"components/rt/architecture/supervision/#performance-comparison","title":"Performance Comparison","text":"<p>From <code>benches/supervisor_benchmarks.rs</code>:</p> Strategy Benchmark Latency Notes OneForOne 1 child restart 10-50 \u00b5s Baseline OneForAll 3 children restart 30-150 \u00b5s ~3x OneForOne RestForOne 2 children restart 20-100 \u00b5s Between OneForOne and OneForAll <p>Overhead hierarchy: OneForOne &lt; RestForOne &lt; OneForAll</p>"},{"location":"components/rt/architecture/supervision/#restart-policies","title":"Restart Policies","text":""},{"location":"components/rt/architecture/supervision/#policy-types","title":"Policy Types","text":"<p>Control when children should be restarted (from <code>src/supervisor/child.rs</code>):</p> <pre><code>pub enum RestartPolicy {\n    Permanent,   // Always restart on failure\n    Transient,   // Restart only on abnormal termination\n    Temporary,   // Never restart\n}\n</code></pre>"},{"location":"components/rt/architecture/supervision/#policy-selection-guide","title":"Policy Selection Guide","text":"Policy Restart Conditions Use Case Permanent Always restart Core services that must run continuously Transient Only on error (not normal shutdown) Optional services, retryable operations Temporary Never restart One-shot tasks, event handlers"},{"location":"components/rt/architecture/supervision/#example-configuration","title":"Example Configuration","text":"<pre><code>use airssys_rt::supervisor::{ChildSpec, RestartPolicy, ShutdownPolicy};\n\n// Critical worker - must always run\nlet spec_permanent = ChildSpec {\n    id: ChildId::new(),\n    restart_policy: RestartPolicy::Permanent,\n    shutdown_policy: ShutdownPolicy::default(),\n    significant: true,  // Failure affects supervisor\n};\n\n// Optional background task\nlet spec_transient = ChildSpec {\n    id: ChildId::new(),\n    restart_policy: RestartPolicy::Transient,\n    shutdown_policy: ShutdownPolicy::default(),\n    significant: false,  // Failure doesn't affect supervisor\n};\n\n// One-shot initialization\nlet spec_temporary = ChildSpec {\n    id: ChildId::new(),\n    restart_policy: RestartPolicy::Temporary,\n    shutdown_policy: ShutdownPolicy::default(),\n    significant: false,\n};\n</code></pre>"},{"location":"components/rt/architecture/supervision/#child-specification","title":"Child Specification","text":""},{"location":"components/rt/architecture/supervision/#childspec-structure","title":"ChildSpec Structure","text":"<p>Configure supervised children (from <code>src/supervisor/child.rs</code>):</p> <pre><code>pub struct ChildSpec {\n    pub id: ChildId,\n    pub restart_policy: RestartPolicy,\n    pub shutdown_policy: ShutdownPolicy,\n    pub significant: bool,  // Does failure affect supervisor?\n}\n</code></pre> <p>Fields: - <code>id</code>: Unique child identifier - <code>restart_policy</code>: When to restart (Permanent/Transient/Temporary) - <code>shutdown_policy</code>: How to stop gracefully - <code>significant</code>: If <code>true</code>, child failure propagates to supervisor</p>"},{"location":"components/rt/architecture/supervision/#significance-flag","title":"Significance Flag","text":"<p>The <code>significant</code> flag controls fault propagation:</p> <pre><code>// Significant child - failure propagates up\nChildSpec {\n    significant: true,  // Supervisor health depends on this child\n    // ...\n}\n\n// Non-significant child - failure contained\nChildSpec {\n    significant: false,  // Supervisor stays healthy even if child fails\n    // ...\n}\n</code></pre> <p>Use cases: - <code>significant: true</code> - Core services (database, auth, cache) - <code>significant: false</code> - Optional services (metrics, logs, monitoring)</p>"},{"location":"components/rt/architecture/supervision/#builder-pattern-rt-task-013","title":"Builder Pattern (RT-TASK-013)","text":""},{"location":"components/rt/architecture/supervision/#supervisor-builder","title":"Supervisor Builder","text":"<p>Type-safe supervisor construction with builder API:</p> <pre><code>use airssys_rt::supervisor::{SupervisorNode, SupervisorBuilder, OneForOne};\n\n// Create supervisor with builder\nlet supervisor = SupervisorNode::builder()\n    .with_strategy(OneForOne::new())\n    .add_child(\n        ChildSpec {\n            id: ChildId::new(),\n            restart_policy: RestartPolicy::Permanent,\n            shutdown_policy: ShutdownPolicy::default(),\n            significant: true,\n        },\n        Box::new(MyWorker::new()),\n    )\n    .add_child(\n        ChildSpec {\n            id: ChildId::new(),\n            restart_policy: RestartPolicy::Transient,\n            shutdown_policy: ShutdownPolicy::default(),\n            significant: false,\n        },\n        Box::new(MonitorWorker::new()),\n    )\n    .build()?;\n</code></pre>"},{"location":"components/rt/architecture/supervision/#builder-methods","title":"Builder Methods","text":"<pre><code>impl SupervisorBuilder {\n    pub fn new() -&gt; Self;\n\n    pub fn with_strategy&lt;S: RestartStrategy + 'static&gt;(\n        mut self, \n        strategy: S\n    ) -&gt; Self;\n\n    pub fn add_child(\n        mut self,\n        spec: ChildSpec,\n        child: Box&lt;dyn Child&gt;,\n    ) -&gt; Self;\n\n    pub fn build(self) -&gt; Result&lt;SupervisorNode, SupervisorError&gt;;\n}\n</code></pre> <p>Benefits: - Type-safe configuration (compile-time checks) - Fluent API (method chaining) - Minimal overhead (5-20 \u00b5s spawn latency) - Clear child declaration</p> <p>See <code>examples/supervisor_builder_phase1.rs</code> and <code>examples/supervisor_builder_phase2.rs</code> for complete examples.</p>"},{"location":"components/rt/architecture/supervision/#supervisor-node","title":"Supervisor Node","text":""},{"location":"components/rt/architecture/supervision/#structure","title":"Structure","text":"<p>Core supervisor implementation (from <code>src/supervisor/supervisor.rs</code>):</p> <pre><code>pub struct SupervisorNode {\n    id: SupervisorId,\n    strategy: Box&lt;dyn RestartStrategy&gt;,\n    children: Vec&lt;(ChildSpec, Box&lt;dyn Child&gt;)&gt;,\n    lifecycle: ActorLifecycle,\n}\n</code></pre>"},{"location":"components/rt/architecture/supervision/#key-methods","title":"Key Methods","text":"<pre><code>impl SupervisorNode {\n    // Create with builder (recommended)\n    pub fn builder() -&gt; SupervisorBuilder;\n\n    // Legacy constructor (still supported)\n    pub fn new&lt;S: RestartStrategy + 'static&gt;(\n        id: SupervisorId,\n        strategy: S,\n    ) -&gt; Self;\n\n    // Add child at runtime\n    pub async fn add_child(\n        &amp;mut self,\n        spec: ChildSpec,\n        child: Box&lt;dyn Child&gt;,\n    ) -&gt; Result&lt;(), SupervisorError&gt;;\n\n    // Start all children\n    pub async fn start_all(&amp;mut self) -&gt; Result&lt;(), SupervisorError&gt;;\n\n    // Stop all children\n    pub async fn stop_all(&amp;mut self) -&gt; Result&lt;(), SupervisorError&gt;;\n\n    // Handle child failure\n    pub async fn handle_child_failure(\n        &amp;mut self,\n        child_id: &amp;ChildId,\n    ) -&gt; Result&lt;(), SupervisorError&gt;;\n}\n</code></pre>"},{"location":"components/rt/architecture/supervision/#automatic-health-monitoring","title":"Automatic Health Monitoring","text":""},{"location":"components/rt/architecture/supervision/#health-monitoring-system","title":"Health Monitoring System","text":"<p>Supervisors can automatically monitor child health (from RT-TASK-009):</p> <pre><code>use airssys_rt::monitoring::{HealthMonitor, HealthConfig};\n\n// Create supervisor with health monitoring\nlet mut supervisor = SupervisorNode::builder()\n    .with_strategy(OneForOne::new())\n    .build()?;\n\n// Add health monitor\nlet monitor = HealthMonitor::new(\n    HealthConfig {\n        check_interval: Duration::from_secs(5),\n        unhealthy_threshold: 3,  // Restart after 3 consecutive failures\n        auto_restart: true,\n    }\n);\n\nmonitor.monitor_supervisor(&amp;mut supervisor).await?;\n</code></pre> <p>Features: - Periodic health checks via <code>Child::health_check()</code> - Configurable thresholds - Automatic restart on unhealthy children - Health status aggregation</p> <p>See <code>examples/supervisor_automatic_health.rs</code> for complete implementation.</p>"},{"location":"components/rt/architecture/supervision/#supervision-trees","title":"Supervision Trees","text":""},{"location":"components/rt/architecture/supervision/#hierarchical-supervisors","title":"Hierarchical Supervisors","text":"<p>Supervisors can supervise other supervisors:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Root Supervisor        \u2502\n\u2502  (OneForAll)            \u2502\n\u2514\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\n   \u2502                  \u2502\n   \u2502                  \u2502\n\u250c\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Worker Pool\u2502   \u2502 Cache Manager\u2502\n\u2502 Supervisor \u2502   \u2502 Supervisor   \u2502\n\u2502 (OneForOne)\u2502   \u2502 (OneForAll)  \u2502\n\u2514\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2518   \u2514\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\n   \u2502  \u2502  \u2502         \u2502       \u2502\n   W1 W2 W3     Cache   Persistence\n</code></pre> <p>Example:</p> <pre><code>// Create worker pool supervisor\nlet worker_supervisor = SupervisorNode::builder()\n    .with_strategy(OneForOne::new())\n    .add_child(spec1, Box::new(Worker1::new()))\n    .add_child(spec2, Box::new(Worker2::new()))\n    .build()?;\n\n// Create cache supervisor\nlet cache_supervisor = SupervisorNode::builder()\n    .with_strategy(OneForAll::new())\n    .add_child(cache_spec, Box::new(Cache::new()))\n    .add_child(db_spec, Box::new(Database::new()))\n    .build()?;\n\n// Create root supervisor (supervisors implement Child trait)\nlet root_supervisor = SupervisorNode::builder()\n    .with_strategy(OneForAll::new())\n    .add_child(\n        worker_spec,\n        Box::new(worker_supervisor),\n    )\n    .add_child(\n        cache_spec,\n        Box::new(cache_supervisor),\n    )\n    .build()?;\n</code></pre>"},{"location":"components/rt/architecture/supervision/#error-handling","title":"Error Handling","text":""},{"location":"components/rt/architecture/supervision/#supervisor-errors","title":"Supervisor Errors","text":"<pre><code>#[derive(Debug)]\npub enum SupervisorError {\n    ChildStartFailed(ChildId, Box&lt;dyn Error + Send + Sync&gt;),\n    ChildStopFailed(ChildId, Box&lt;dyn Error + Send + Sync&gt;),\n    ChildNotFound(ChildId),\n    StrategyError(String),\n}\n</code></pre>"},{"location":"components/rt/architecture/supervision/#error-flow","title":"Error Flow","text":"<ol> <li>Child fails during operation</li> <li>Child's <code>start()</code> or <code>stop()</code> returns <code>Err</code></li> <li>Supervisor catches error</li> <li>Supervisor applies restart strategy</li> <li>On restart failure, error propagates to parent supervisor (if significant child)</li> </ol>"},{"location":"components/rt/architecture/supervision/#recovery-strategies","title":"Recovery Strategies","text":"<pre><code>async fn handle_child_failure(\n    &amp;mut self,\n    child_id: &amp;ChildId,\n) -&gt; Result&lt;(), SupervisorError&gt; {\n    match self.restart_policy {\n        RestartPolicy::Permanent =&gt; {\n            // Always restart\n            self.restart_child(child_id).await?;\n        }\n        RestartPolicy::Transient =&gt; {\n            // Check if abnormal termination\n            if self.is_abnormal_termination(child_id) {\n                self.restart_child(child_id).await?;\n            }\n        }\n        RestartPolicy::Temporary =&gt; {\n            // Just cleanup, no restart\n            self.remove_child(child_id).await?;\n        }\n    }\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/architecture/supervision/#best-practices","title":"Best Practices","text":""},{"location":"components/rt/architecture/supervision/#strategy-selection","title":"Strategy Selection","text":"<p>OneForOne: - \u2705 Use for: Independent workers, pools, parallel tasks - \u2705 Example: HTTP request handlers, background jobs - \u274c Avoid for: Stateful, interdependent services</p> <p>OneForAll: - \u2705 Use for: Tightly coupled services, consistent state requirements - \u2705 Example: Cache + database, auth + session store - \u274c Avoid for: Large numbers of independent children (restart overhead)</p> <p>RestForOne: - \u2705 Use for: Pipelines, sequential dependencies - \u2705 Example: Data ingestion \u2192 transform \u2192 storage - \u274c Avoid for: Parallel, independent processing</p>"},{"location":"components/rt/architecture/supervision/#child-design","title":"Child Design","text":"<p>DO: - \u2705 Implement proper <code>start()</code>/<code>stop()</code> lifecycle - \u2705 Make <code>health_check()</code> fast and accurate (&lt;1ms) - \u2705 Use <code>significant</code> flag appropriately - \u2705 Keep child state minimal for fast restarts</p> <p>DON'T: - \u274c Block in <code>start()</code>/<code>stop()</code> (use async properly) - \u274c Ignore errors in lifecycle methods - \u274c Make all children significant (limits fault isolation) - \u274c Store unrecoverable state in children</p>"},{"location":"components/rt/architecture/supervision/#performance-tuning","title":"Performance Tuning","text":"<p>Minimize restart latency: - Keep <code>start()</code> logic simple (&lt;10ms ideal) - Preallocate resources where possible - Use connection pools instead of per-child connections</p> <p>Monitor restart patterns: - Track restart counts (via <code>ActorLifecycle</code>) - Alert on excessive restarts (possible underlying issue) - Use <code>HealthMonitor</code> for automatic detection</p>"},{"location":"components/rt/architecture/supervision/#testing-patterns","title":"Testing Patterns","text":""},{"location":"components/rt/architecture/supervision/#unit-testing-children","title":"Unit Testing Children","text":"<pre><code>#[tokio::test]\nasync fn test_child_lifecycle() {\n    let mut child = MyWorker::new();\n\n    // Test start\n    child.start().await.expect(\"start failed\");\n    assert_eq!(child.health_check().await, ChildHealth::Healthy);\n\n    // Test stop\n    child.stop().await.expect(\"stop failed\");\n}\n</code></pre>"},{"location":"components/rt/architecture/supervision/#integration-testing-supervisors","title":"Integration Testing Supervisors","text":"<pre><code>#[tokio::test]\nasync fn test_one_for_one_restart() {\n    let mut supervisor = SupervisorNode::builder()\n        .with_strategy(OneForOne::new())\n        .add_child(spec, Box::new(FailingWorker::new()))\n        .build()\n        .unwrap();\n\n    supervisor.start_all().await.unwrap();\n\n    // Trigger failure and verify restart\n    let child_id = supervisor.children()[0].0.id.clone();\n    supervisor.handle_child_failure(&amp;child_id).await.unwrap();\n\n    // Verify child was restarted\n    assert!(supervisor.is_child_running(&amp;child_id));\n}\n</code></pre>"},{"location":"components/rt/architecture/supervision/#working-examples","title":"Working Examples","text":"<p>Explore supervision in these examples:</p> Example Demonstrates Command <code>supervisor_basic.rs</code> Basic supervision setup <code>cargo run --example supervisor_basic</code> <code>supervisor_strategies.rs</code> All three strategies <code>cargo run --example supervisor_strategies</code> <code>supervisor_builder_phase1.rs</code> Builder API basics <code>cargo run --example supervisor_builder_phase1</code> <code>supervisor_builder_phase2.rs</code> Advanced builder patterns <code>cargo run --example supervisor_builder_phase2</code> <code>supervisor_automatic_health.rs</code> Health monitoring <code>cargo run --example supervisor_automatic_health</code> <code>worker_pool.rs</code> Production worker pool <code>cargo run --example worker_pool</code> <code>event_pipeline.rs</code> RestForOne pipeline <code>cargo run --example event_pipeline</code> <p>All examples are in the <code>examples/</code> directory with complete, runnable implementations.</p>"},{"location":"components/rt/architecture/system-overview/","title":"System Overview","text":"<p>A comprehensive architectural overview of the <code>airssys-rt</code> actor runtime system, including component relationships, data flow, and design principles.</p> <p>Note: This document provides the high-level architecture. See Components for detailed subsystem documentation.</p>"},{"location":"components/rt/architecture/system-overview/#system-philosophy","title":"System Philosophy","text":""},{"location":"components/rt/architecture/system-overview/#core-principles","title":"Core Principles","text":"<p><code>airssys-rt</code> is designed around the Erlang/OTP actor model with Rust-native performance and type safety:</p> <ol> <li>Fault Tolerance - \"Let it crash\" philosophy with supervision trees</li> <li>Concurrency - Lightweight actors with message-passing isolation</li> <li>Type Safety - Compile-time guarantees via generics and associated types</li> <li>Performance - Zero-cost abstractions, static dispatch, minimal allocations</li> <li>Composability - Builder patterns and trait-based design</li> </ol>"},{"location":"components/rt/architecture/system-overview/#design-guidelines","title":"Design Guidelines","text":"<p>All components follow Microsoft Rust Guidelines documented in <code>.copilot/memory_bank/workspace/microsoft_rust_guidelines.md</code>:</p> <ul> <li>M-DI-HIERARCHY: Concrete types &gt; generics &gt; <code>dyn</code> traits</li> <li>M-AVOID-WRAPPERS: No smart pointers in public APIs</li> <li>M-SIMPLE-ABSTRACTIONS: Maximum 1 level of cognitive nesting</li> <li>M-SERVICES-CLONE: Services implement cheap <code>Clone</code> via <code>Arc&lt;Inner&gt;</code></li> <li>M-ESSENTIAL-FN-INHERENT: Core functionality in inherent methods</li> <li>M-MOCKABLE-SYSCALLS: All I/O and system calls must be mockable</li> </ul>"},{"location":"components/rt/architecture/system-overview/#high-level-architecture","title":"High-Level Architecture","text":""},{"location":"components/rt/architecture/system-overview/#component-layers","title":"Component Layers","text":"<p>The runtime is organized in seven layers, each building on the previous:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    System Layer (Planned)                  \u2502\n\u2502  Runtime coordination, actor registry, distributed nodes   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Monitoring Layer                         \u2502\n\u2502   Health checks, metrics, performance tracking, alerting   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  Supervisor Layer                          \u2502\n\u2502  Fault tolerance, restart strategies, supervision trees    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Mailbox Layer                            \u2502\n\u2502    Message queue management, backpressure, buffering       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Actor Layer                             \u2502\n\u2502      Actor trait, context, lifecycle, error handling       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Broker Layer                             \u2502\n\u2502       Pub/sub message routing, subscriber management       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                     \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Message Layer                            \u2502\n\u2502         Message types, envelopes, identifiers              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"components/rt/architecture/system-overview/#layer-responsibilities","title":"Layer Responsibilities","text":"Layer Responsibility Key Components Message Type-safe message contracts <code>Message</code>, <code>MessageEnvelope</code>, <code>MessageId</code> Broker Pub/sub routing <code>MessageBroker</code>, <code>InMemoryMessageBroker</code> Actor Business logic execution <code>Actor</code>, <code>ActorContext</code>, <code>ActorLifecycle</code> Mailbox Message buffering <code>BoundedMailbox</code>, <code>UnboundedMailbox</code> Supervisor Fault tolerance <code>SupervisorNode</code>, <code>RestartStrategy</code>, <code>Child</code> Monitoring Health and metrics <code>HealthMonitor</code>, <code>ActorMetrics</code>, <code>SupervisorMetrics</code> System Runtime coordination <code>ActorSystem</code> (planned), registry, clustering"},{"location":"components/rt/architecture/system-overview/#core-component-diagram","title":"Core Component Diagram","text":""},{"location":"components/rt/architecture/system-overview/#component-relationships","title":"Component Relationships","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                         ActorSystem                             \u2502\n\u2502                     (Planned - Q1 2026)                         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502                                  \u2502\n               \u2502                                  \u2502\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502  SupervisorNode    \u2502            \u2502   HealthMonitor    \u2502\n     \u2502  - RestartStrategy \u2502            \u2502   - HealthConfig   \u2502\n     \u2502  - Children        \u2502            \u2502   - Metrics        \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n               \u2502                                  \u2502\n               \u2502 supervises                       \u2502 monitors\n               \u2502                                  \u2502\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502                    Actor                              \u2502\n     \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510      \u2502\n     \u2502    \u2502        ActorContext                      \u2502      \u2502\n     \u2502    \u2502  - ActorAddress                          \u2502      \u2502\n     \u2502    \u2502  - ActorLifecycle                        \u2502      \u2502\n     \u2502    \u2502  - MessageBroker                         \u2502      \u2502\n     \u2502    \u2502  - send() / request()                    \u2502      \u2502\n     \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         \u2502 publishes/subscribes\n                         \u2502\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502            InMemoryMessageBroker                       \u2502\n     \u2502  - Subscribers: HashMap&lt;ActorId, Sender&lt;Envelope&gt;&gt;    \u2502\n     \u2502  - publish(envelope)                                   \u2502\n     \u2502  - subscribe(actor_id) \u2192 Receiver                      \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n                         \u2502 routes messages\n                         \u2502\n     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     \u2502                  Mailbox                               \u2502\n     \u2502  - BoundedMailbox   (capacity + backpressure)         \u2502\n     \u2502  - UnboundedMailbox (unlimited capacity)              \u2502\n     \u2502  - Metrics tracking                                    \u2502\n     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"components/rt/architecture/system-overview/#message-flow-architecture","title":"Message Flow Architecture","text":""},{"location":"components/rt/architecture/system-overview/#complete-message-path","title":"Complete Message Path","text":"<p>The following diagram shows the complete path of a message from sender to receiver:</p> <pre><code>  Sender Actor                                       Receiver Actor\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 handle_msg() \u2502                                    \u2502 handle_msg() \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                                                   \u2502\n       \u2502 1. context.send(msg, recipient)                  \u2502 6. Process message\n       \u25bc                                                   \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                  \u2502\n\u2502   ActorContext       \u2502                                  \u2502\n\u2502 - Wrap in envelope   \u2502                                  \u2502\n\u2502 - Add metadata       \u2502                                  \u2502\n\u2502 - Set timestamp      \u2502                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                  \u2502\n       \u2502                                                   \u2502\n       \u2502 2. broker.publish(envelope)                      \u2502\n       \u25bc                                                   \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n\u2502      InMemoryMessageBroker            \u2502                 \u2502\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                 \u2502\n\u2502 \u2502 Subscribers: HashMap               \u2502 \u2502                 \u2502\n\u2502 \u2502 - ActorId \u2192 mpsc::Sender&lt;Envelope&gt; \u2502 \u2502                 \u2502\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502                 \u2502\n\u2502                                       \u2502                 \u2502\n\u2502 - Find subscriber by ActorId          \u2502                 \u2502\n\u2502 - Clone envelope for each subscriber  \u2502                 \u2502\n\u2502 - Send to channel                     \u2502                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\n       \u2502                                                   \u2502\n       \u2502 3. channel.send(envelope)                        \u2502\n       \u25bc                                                   \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n\u2502         Mailbox Queue                 \u2502                 \u2502\n\u2502                                       \u2502                 \u2502\n\u2502  BoundedMailbox:                      \u2502                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                 \u2502\n\u2502  \u2502 [Env1][Env2][Env3]...\u2502  \u2502  \u2502  \u2502 \u2502 \u2502                 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502                 \u2502\n\u2502  - Capacity limit                     \u2502                 \u2502\n\u2502  - Backpressure (Block/Drop/...)      \u2502                 \u2502\n\u2502  - Metrics tracking                   \u2502                 \u2502\n\u2502                                       \u2502                 \u2502\n\u2502  UnboundedMailbox:                    \u2502                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                 \u2502\n\u2502  \u2502 [Env1][Env2][Env3]..............\u2502 \u2502                 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502                 \u2502\n\u2502  - No capacity limit                  \u2502                 \u2502\n\u2502  - No backpressure                    \u2502                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2502\n       \u2502                                                   \u2502\n       \u2502 4. receiver.recv()                               \u2502\n       \u25bc                                                   \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u2502\n\u2502      Actor Message Loop               \u2502                 \u2502\n\u2502                                       \u2502                 \u2502\n\u2502  loop {                               \u2502                 \u2502\n\u2502    envelope = receiver.recv().await   \u2502                 \u2502\n\u2502    actor.handle_message(msg, ctx)     \u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2502  }                                    \u2502    5. Deliver message\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"components/rt/architecture/system-overview/#latency-breakdown","title":"Latency Breakdown","text":"<p>Based on measurements from <code>BENCHMARKING.md</code>:</p> Step Operation Latency Percentage 1 Message wrapping (envelope creation) ~10 ns 1.4% 2 Broker routing (mutex + channel send) ~180 ns 24.4% 3 Channel transfer (Tokio mpsc) ~20 ns 2.7% 4 Mailbox buffering ~181 ns 24.6% 5 Actor processing overhead ~31 ns 4.2% 6 Business logic (varies) ~315 ns 42.7% Total Point-to-point roundtrip 737 ns 100% <p>Key Insights: - Broker routing and mailbox operations dominate latency (~49%) - Actual business logic is still the majority of time (~43%) - Infrastructure overhead is sub-microsecond (422 ns)</p>"},{"location":"components/rt/architecture/system-overview/#supervision-tree-architecture","title":"Supervision Tree Architecture","text":""},{"location":"components/rt/architecture/system-overview/#hierarchical-fault-tolerance","title":"Hierarchical Fault Tolerance","text":"<p>Supervisors can supervise other supervisors, creating a fault-tolerant tree:</p> <pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502  Root Supervisor    \u2502\n                    \u2502  (OneForAll)        \u2502\n                    \u2502  RestartPolicy:     \u2502\n                    \u2502    Permanent        \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2518\n                           \u2502          \u2502\n            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n            \u2502                                        \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Worker Pool          \u2502                 \u2502 Cache Manager        \u2502\n\u2502 Supervisor           \u2502                 \u2502 Supervisor           \u2502\n\u2502 (OneForOne)          \u2502                 \u2502 (OneForAll)          \u2502\n\u2502 RestartPolicy:       \u2502                 \u2502 RestartPolicy:       \u2502\n\u2502   Permanent          \u2502                 \u2502   Transient          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n        \u2502  \u2502  \u2502                                 \u2502       \u2502\n   \u250c\u2500\u2500\u2500\u2500\u2518  \u2502  \u2514\u2500\u2500\u2500\u2500\u2510                      \u250c\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502       \u2502       \u2502                      \u2502                   \u2502\n\u250c\u2500\u2500\u25bc\u2500\u2500\u2510 \u250c\u2500\u2500\u25bc\u2500\u2500\u2510 \u250c\u2500\u2500\u25bc\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 W-1 \u2502 \u2502 W-2 \u2502 \u2502 W-3 \u2502            \u2502   Cache   \u2502      \u2502 Persistence \u2502\n\u2502Actor\u2502 \u2502Actor\u2502 \u2502Actor\u2502            \u2502   Actor   \u2502      \u2502   Actor     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"components/rt/architecture/system-overview/#failure-propagation","title":"Failure Propagation","text":"<p>Scenario: Worker-2 fails</p> <p>With OneForOne strategy in Worker Pool: 1. W-2 fails \u2192 <code>handle_message</code> returns <code>Err</code> 2. Worker Pool Supervisor detects failure 3. W-2's <code>on_error()</code> returns <code>ErrorAction::Restart</code> 4. Supervisor applies OneForOne: restart only W-2 5. W-2 lifecycle: Running \u2192 Failed \u2192 Stopping \u2192 Starting \u2192 Running 6. W-1 and W-3 continue processing unaffected 7. Root Supervisor unaware (non-significant child)</p> <p>Scenario: Cache Actor fails</p> <p>With OneForAll strategy in Cache Manager: 1. Cache fails \u2192 <code>handle_message</code> returns <code>Err</code> 2. Cache Manager Supervisor detects failure 3. Cache's <code>on_error()</code> returns <code>ErrorAction::Restart</code> 4. Supervisor applies OneForAll: restart Cache AND Persistence 5. Both actors lifecycle: Running \u2192 Failed \u2192 Stopping \u2192 Starting \u2192 Running 6. Consistent state guaranteed across both actors 7. If Cache Manager marked <code>significant: true</code>, Root Supervisor would be notified</p>"},{"location":"components/rt/architecture/system-overview/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"components/rt/architecture/system-overview/#baseline-metrics","title":"Baseline Metrics","text":"<p>Measured on macOS development machine (October 16, 2025) with release build:</p>"},{"location":"components/rt/architecture/system-overview/#actor-system-performance","title":"Actor System Performance","text":"Metric Latency Throughput Notes Actor spawn (single) 624.74 ns 1.6M actors/sec Sub-microsecond creation Actor spawn (batch of 10) 681.40 ns/actor 1.47M actors/sec Only 9% overhead Message processing 31.55 ns/msg 31.7M msgs/sec Direct processing Message via broker 211.88 ns/msg 4.7M msgs/sec Pub-sub overhead: 6.7x"},{"location":"components/rt/architecture/system-overview/#message-passing-performance","title":"Message Passing Performance","text":"Metric Latency Throughput Notes Point-to-point 737 ns roundtrip 1.36M msgs/sec Sub-microsecond latency Broadcast (10 actors) 395 ns total ~40 ns/subscriber Efficient multi-cast Mailbox operations 181.60 ns/op 5.5M ops/sec Enqueue + dequeue"},{"location":"components/rt/architecture/system-overview/#supervision-performance","title":"Supervision Performance","text":"Metric Latency Notes Child spawn (builder API) 5-20 \u00b5s Type-safe configuration OneForOne restart 10-50 \u00b5s Single child stop \u2192 start OneForAll restart (3 children) 30-150 \u00b5s ~3x OneForOne RestForOne restart (2 children) 20-100 \u00b5s Between OneForOne and OneForAll"},{"location":"components/rt/architecture/system-overview/#scalability-characteristics","title":"Scalability Characteristics","text":"<p>Memory per actor: - Actor struct: ~500 bytes - 2 KB (depends on state) - ActorContext: ~200 bytes - Mailbox (unbounded): ~100 bytes base - Mailbox (bounded 100): ~244 bytes - Total: ~1-3 KB per actor typical</p> <p>Throughput scaling: - Message processing scales linearly with message count - Broadcast scales linearly with subscriber count (~40 ns/subscriber) - Batch actor spawn has 9% overhead vs single spawn (excellent)</p> <p>Concurrency: - Actors are <code>Send + Sync</code> - true parallelism - Message broker uses <code>Arc&lt;Mutex&lt;HashMap&gt;&gt;</code> - contention point for many subscribers - Tokio runtime handles async/await scheduling efficiently</p>"},{"location":"components/rt/architecture/system-overview/#type-safety-architecture","title":"Type Safety Architecture","text":""},{"location":"components/rt/architecture/system-overview/#generic-constraints","title":"Generic Constraints","text":"<p>The runtime uses generics instead of trait objects for zero-cost abstraction:</p> <pre><code>// \u2705 CORRECT - Generic constraints (static dispatch)\npub trait Actor: Send + Sync + 'static {\n    type Message: Message;\n    type Error: Error + Send + Sync + 'static;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt;;\n}\n\n// \u274c FORBIDDEN - Trait objects (dynamic dispatch, heap allocation)\nasync fn handle_message(\n    &amp;mut self,\n    message: Box&lt;dyn Message&gt;,\n    context: &amp;mut ActorContext&lt;Box&lt;dyn Message&gt;, Box&lt;dyn MessageBroker&gt;&gt;,\n) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt;;\n</code></pre> <p>Benefits: - Compile-time type checking - No runtime type dispatch overhead - No heap allocations for message passing - Better compiler optimizations</p>"},{"location":"components/rt/architecture/system-overview/#associated-types","title":"Associated Types","text":"<p>Associated types provide type safety without type parameter explosion:</p> <pre><code>impl Actor for CounterActor {\n    type Message = CounterMessage;  // Specific message type\n    type Error = CounterError;      // Specific error type\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,  // CounterMessage, not generic\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {  // CounterError, not generic\n        // Fully type-safe, no casts needed\n        self.value += message.delta;\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"components/rt/architecture/system-overview/#future-integrations-planned","title":"Future Integrations (Planned)","text":"<p>airssys-wasm - WebAssembly component hosting: - Actors can host WASM components as children - Sandboxed component execution - Capability-based security - Component lifecycle management</p> <p>Distributed nodes - Multi-node actor systems: - Network message broker - Transparent remote actor addressing - Distributed supervision - Cluster membership</p>"},{"location":"components/rt/architecture/system-overview/#directory-structure","title":"Directory Structure","text":"<p>The runtime codebase follows the layered architecture:</p> <pre><code>airssys-rt/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs              # Public API surface\n\u2502   \u251c\u2500\u2500 message/            # Message Layer\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs          # Message trait, MessageId\n\u2502   \u2502   \u2514\u2500\u2500 envelope.rs     # MessageEnvelope\n\u2502   \u251c\u2500\u2500 broker/             # Broker Layer\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs          # Re-exports\n\u2502   \u2502   \u251c\u2500\u2500 traits.rs       # MessageBroker trait\n\u2502   \u2502   \u2514\u2500\u2500 in_memory.rs    # InMemoryMessageBroker\n\u2502   \u251c\u2500\u2500 actor/              # Actor Layer\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs          # Re-exports\n\u2502   \u2502   \u251c\u2500\u2500 traits.rs       # Actor trait\n\u2502   \u2502   \u251c\u2500\u2500 context.rs      # ActorContext\n\u2502   \u2502   \u2514\u2500\u2500 lifecycle.rs    # ActorLifecycle, ActorState\n\u2502   \u251c\u2500\u2500 mailbox/            # Mailbox Layer\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs          # Re-exports\n\u2502   \u2502   \u251c\u2500\u2500 bounded.rs      # BoundedMailbox\n\u2502   \u2502   \u2514\u2500\u2500 unbounded.rs    # UnboundedMailbox\n\u2502   \u251c\u2500\u2500 supervisor/         # Supervisor Layer\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs          # Re-exports\n\u2502   \u2502   \u251c\u2500\u2500 supervisor.rs   # SupervisorNode\n\u2502   \u2502   \u251c\u2500\u2500 builder.rs      # SupervisorBuilder (RT-TASK-013)\n\u2502   \u2502   \u251c\u2500\u2500 strategy.rs     # OneForOne, OneForAll, RestForOne\n\u2502   \u2502   \u2514\u2500\u2500 child.rs        # Child trait, ChildSpec\n\u2502   \u251c\u2500\u2500 monitoring/         # Monitoring Layer\n\u2502   \u2502   \u251c\u2500\u2500 mod.rs          # Re-exports\n\u2502   \u2502   \u251c\u2500\u2500 health.rs       # HealthMonitor, ChildHealth\n\u2502   \u2502   \u2514\u2500\u2500 metrics.rs      # ActorMetrics, SupervisorMetrics\n\u2502   \u251c\u2500\u2500 system/             # System Layer (Planned)\n\u2502   \u2502   \u2514\u2500\u2500 mod.rs          # Future: ActorSystem, registry\n\u2502   \u2514\u2500\u2500 util/               # Utilities\n\u2502       \u251c\u2500\u2500 mod.rs          # Re-exports\n\u2502       \u251c\u2500\u2500 address.rs      # ActorAddress, ActorId\n\u2502       \u2514\u2500\u2500 id.rs           # ChildId, SupervisorId\n\u251c\u2500\u2500 examples/               # Working examples (15 total)\n\u251c\u2500\u2500 tests/                  # Integration tests\n\u251c\u2500\u2500 benches/                # Criterion benchmarks\n\u2514\u2500\u2500 docs/                   # mdBook documentation\n</code></pre>"},{"location":"components/rt/architecture/system-overview/#design-patterns","title":"Design Patterns","text":""},{"location":"components/rt/architecture/system-overview/#builder-pattern-rt-task-013","title":"Builder Pattern (RT-TASK-013)","text":"<p>Type-safe configuration using builders:</p> <pre><code>let supervisor = SupervisorNode::builder()\n    .with_strategy(OneForOne::new())\n    .add_child(spec1, Box::new(worker1))\n    .add_child(spec2, Box::new(worker2))\n    .build()?;\n</code></pre> <p>Benefits: - Compile-time validation - Fluent API - Clear intent - Minimal overhead (5-20 \u00b5s)</p>"},{"location":"components/rt/architecture/system-overview/#services-clone-pattern","title":"Services Clone Pattern","text":"<p>Services implement cheap <code>Clone</code> via <code>Arc&lt;Inner&gt;</code>:</p> <pre><code>#[derive(Clone)]\npub struct InMemoryMessageBroker&lt;M: Message&gt; {\n    // Arc makes clone cheap (just increment refcount)\n    subscribers: Arc&lt;Mutex&lt;HashMap&lt;ActorId, mpsc::Sender&lt;MessageEnvelope&lt;M&gt;&gt;&gt;&gt;&gt;,\n}\n</code></pre> <p>Benefits: - Services can be shared across actors - No deep copying overhead - Thread-safe via Arc - Simple ownership model</p>"},{"location":"components/rt/architecture/system-overview/#dependency-injection","title":"Dependency Injection","text":"<p>Generic constraints for testability:</p> <pre><code>async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    message: Self::Message,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,  // B is injected\n) -&gt; Result&lt;(), Self::Error&gt;\n</code></pre> <p>Benefits: - Mock brokers in tests - Swap implementations (InMemory, Network, etc.) - No runtime coupling - Compile-time verification</p>"},{"location":"components/rt/architecture/system-overview/#next-steps","title":"Next Steps","text":"<p>For detailed subsystem architecture, see:</p> <ul> <li>Components - Deep dive into each layer</li> <li>Core Concepts - Fundamental concepts and examples</li> <li>Actor Model - Actor trait and lifecycle</li> <li>Message Passing - Messaging system details</li> <li>Supervision - Fault tolerance and restart strategies</li> <li>Process Lifecycle - State management</li> </ul> <p>For API reference: - API Reference - Complete API documentation</p> <p>For performance details: - Performance Reference - Detailed metrics and benchmarks</p>"},{"location":"components/rt/explanation/actor-model/","title":"Understanding the Actor Model","text":"<p>This document explains the actor model philosophy, its benefits, design decisions in AirsSys RT, and how it compares to alternative concurrency approaches.</p>"},{"location":"components/rt/explanation/actor-model/#table-of-contents","title":"Table of Contents","text":"<ul> <li>What is the Actor Model?</li> <li>Historical Context</li> <li>Core Principles</li> <li>Why the Actor Model?</li> <li>Design Philosophy in AirsSys RT</li> <li>Comparison with Alternatives</li> <li>Tradeoffs and Considerations</li> <li>When to Use Actors</li> </ul>"},{"location":"components/rt/explanation/actor-model/#what-is-the-actor-model","title":"What is the Actor Model?","text":"<p>The Actor Model is a mathematical model of concurrent computation that treats \"actors\" as the universal primitives of concurrent computation. An actor is an independent computational entity that:</p> <ol> <li>Receives messages from other actors or the external world</li> <li>Processes messages sequentially, one at a time</li> <li>Maintains private state that no other actor can access directly</li> <li>Sends messages to other actors asynchronously</li> <li>Creates new actors to delegate work or represent entities</li> </ol> <p>Key Insight: The actor model eliminates shared mutable state by making message passing the only means of communication between concurrent entities.</p>"},{"location":"components/rt/explanation/actor-model/#the-actor-metaphor","title":"The Actor Metaphor","text":"<p>Think of actors like people in an organization:</p> <ul> <li>Each person (actor) has their own desk, files, and responsibilities (private state)</li> <li>People communicate through memos and emails (messages), not by reaching into each other's desks</li> <li>Each person processes one memo at a time (sequential message handling)</li> <li>People delegate work by sending memos to colleagues or hiring assistants (creating actors)</li> <li>The organization scales by adding more people, not by making people work faster</li> </ul> <p>This metaphor captures the essence of actor-based concurrency: isolation, asynchronous communication, and scalability through distribution.</p>"},{"location":"components/rt/explanation/actor-model/#historical-context","title":"Historical Context","text":""},{"location":"components/rt/explanation/actor-model/#origins-1973","title":"Origins (1973)","text":"<p>The actor model was first described by Carl Hewitt, Peter Bishop, and Richard Steiger in their 1973 paper \"A Universal Modular ACTOR Formalism for Artificial Intelligence.\" It emerged from research into artificial intelligence and parallel computation.</p> <p>Original Motivation: Create a mathematical foundation for concurrent computation that could model AI systems with many independent reasoning agents.</p>"},{"location":"components/rt/explanation/actor-model/#evolution-through-languages","title":"Evolution Through Languages","text":"<p>Erlang (1986): - Developed at Ericsson for telecom switching systems - Demonstrated actors could build fault-tolerant, highly available systems - Introduced supervision trees for fault tolerance - Proven in production: 99.9999999% (nine nines) availability</p> <p>Akka (2009): - Brought actor model to JVM ecosystem (Scala/Java) - Added location transparency (actors can be local or remote) - Demonstrated scalability: millions of actors per machine - Widespread adoption in reactive, event-driven architectures</p> <p>Modern Implementations: - Actix (Rust): High-performance actor framework for Rust - Orleans (.NET): Virtual actors for distributed systems - CAF (C++): Actor framework for high-performance computing - AirsSys RT: Lightweight Erlang-inspired actors for Rust</p>"},{"location":"components/rt/explanation/actor-model/#why-actors-endure","title":"Why Actors Endure","text":"<p>The actor model has remained relevant for over 50 years because it provides:</p> <ol> <li>Mathematical foundation: Formal reasoning about concurrent systems</li> <li>Natural abstraction: Matches how developers think about distributed systems</li> <li>Proven reliability: Battle-tested in telecom, finance, gaming, and IoT</li> <li>Language-agnostic: Can be implemented in any programming language</li> </ol>"},{"location":"components/rt/explanation/actor-model/#core-principles","title":"Core Principles","text":""},{"location":"components/rt/explanation/actor-model/#1-encapsulation-and-isolation","title":"1. Encapsulation and Isolation","text":"<p>Principle: Actors are completely isolated from each other. No actor can directly access another actor's state.</p> <p>Rationale: Prevents data races, eliminates the need for locks, and enables independent reasoning about each actor's behavior.</p> <p>Example: <pre><code>// Actor A cannot access Actor B's state\nstruct ActorA {\n    private_state: String,  // Only ActorA can access this\n}\n\nstruct ActorB {\n    private_state: i32,  // Only ActorB can access this\n}\n\n// Communication only through messages\nactor_b_ref.send(MyMessage { data: 42 }).await?;\n</code></pre></p> <p>Benefit: Each actor can be understood in isolation without considering global synchronization.</p>"},{"location":"components/rt/explanation/actor-model/#2-asynchronous-message-passing","title":"2. Asynchronous Message Passing","text":"<p>Principle: Actors communicate exclusively through asynchronous messages. Sending a message never blocks the sender.</p> <p>Rationale: Decouples sender and receiver, enables non-blocking concurrency, and supports location transparency.</p> <p>Example: <pre><code>// Fire-and-forget: sender continues immediately\nactor_ref.send(WorkRequest { task_id: 1 }).await?;\nprintln!(\"Message sent, moving on...\");  // Executes before message is processed\n\n// Request-reply: sender can optionally wait for response\nlet result = actor_ref.send(QueryRequest { id: 42 }).await?;\n</code></pre></p> <p>Benefit: No waiting for responses unless explicitly needed, maximizing concurrency.</p>"},{"location":"components/rt/explanation/actor-model/#3-sequential-message-processing","title":"3. Sequential Message Processing","text":"<p>Principle: Each actor processes messages one at a time from its mailbox in FIFO order.</p> <p>Rationale: Eliminates race conditions within an actor, simplifies state management, and ensures predictable behavior.</p> <p>Example: <pre><code>// Actor processes messages sequentially\nasync fn handle(&amp;mut self, msg: UpdateState, ctx: &amp;mut ActorContext&lt;Self&gt;) {\n    self.counter += msg.increment;  // No locks needed!\n    // Next message won't be processed until this handler completes\n}\n</code></pre></p> <p>Benefit: Internal actor logic is single-threaded, avoiding concurrency complexity.</p>"},{"location":"components/rt/explanation/actor-model/#4-actor-creation-and-supervision","title":"4. Actor Creation and Supervision","text":"<p>Principle: Actors can create other actors dynamically and supervise their lifecycle.</p> <p>Rationale: Enables hierarchical fault tolerance, resource management, and dynamic system adaptation.</p> <p>Example: <pre><code>// Parent actor creates and supervises children\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .with_child(\n        ChildSpec::new(\"worker\")\n            .with_actor::&lt;WorkerActor&gt;()\n            .with_max_restarts(5)\n    )\n    .build()\n    .await?;\n</code></pre></p> <p>Benefit: Fault tolerance through isolated failure domains and automatic recovery.</p>"},{"location":"components/rt/explanation/actor-model/#why-the-actor-model","title":"Why the Actor Model?","text":""},{"location":"components/rt/explanation/actor-model/#problem-traditional-concurrency-is-complex","title":"Problem: Traditional Concurrency is Complex","text":"<p>Shared-Memory Concurrency (Locks, Mutexes):</p> <pre><code>// Traditional approach: explicit locking\nuse std::sync::{Arc, Mutex};\n\nlet counter = Arc::new(Mutex::new(0));\nlet counter_clone = counter.clone();\n\ntokio::spawn(async move {\n    let mut count = counter_clone.lock().unwrap();  // Acquire lock\n    *count += 1;  // Critical section\n    // Lock released when count drops\n});\n\n// Problems:\n// 1. Deadlocks: Thread A waits for Thread B, Thread B waits for Thread A\n// 2. Race conditions: Forgot to lock? Data corruption!\n// 3. Performance: Lock contention limits scalability\n// 4. Complexity: Reasoning about all possible interleavings\n</code></pre> <p>Complexity Explosion: - With N threads and M locks, potential states = O(2^(N\u00d7M)) - Deadlock detection requires global system knowledge - Performance unpredictable due to lock contention</p>"},{"location":"components/rt/explanation/actor-model/#solution-actor-model","title":"Solution: Actor Model","text":"<p>Actor-Based Concurrency:</p> <pre><code>// Actor approach: isolated state, message passing\nstruct Counter {\n    count: i32,  // Private, no locks needed\n}\n\nimpl Actor for Counter {}\n\n#[async_trait]\nimpl Handler&lt;Increment&gt; for Counter {\n    async fn handle(&amp;mut self, _msg: Increment, _ctx: &amp;mut ActorContext&lt;Self&gt;) {\n        self.count += 1;  // Safe! Sequential processing guarantees no race\n    }\n}\n\n// Benefits:\n// 1. No deadlocks: No locks to acquire\n// 2. No race conditions: Sequential message processing\n// 3. Scalable: Independent actors run in parallel\n// 4. Simple: Local reasoning about each actor\n</code></pre> <p>Complexity Reduction: - Each actor's behavior is independent - No global reasoning required - Failures isolated to actor boundaries - Scalability through distribution</p>"},{"location":"components/rt/explanation/actor-model/#the-actor-model-advantage","title":"The Actor Model Advantage","text":"Challenge Shared-Memory Actor Model Race Conditions Requires manual locking Eliminated by design Deadlocks Possible with multiple locks Not possible Scalability Limited by lock contention Linear with actor count Fault Tolerance Process crash = total failure Isolated actor failures Distribution Requires complete rewrite Location transparent Reasoning Global system state Local actor state"},{"location":"components/rt/explanation/actor-model/#design-philosophy-in-airssys-rt","title":"Design Philosophy in AirsSys RT","text":"<p>AirsSys RT is inspired by Erlang's actor model with Rust's zero-cost abstractions and type safety.</p>"},{"location":"components/rt/explanation/actor-model/#design-goals","title":"Design Goals","text":"<p>1. Lightweight Actors</p> <p>Goal: Spawn millions of actors without excessive memory overhead.</p> <p>Approach: - Each actor ~1KB memory footprint - Measured performance: 624ns to spawn actor - Benchmark target: 1.6M actors/second spawn rate</p> <p>Rationale: Large-scale systems (IoT, gaming, microservices) require numerous concurrent entities.</p> <p>2. Type-Safe Message Passing</p> <p>Goal: Compile-time verification that actors can handle messages sent to them.</p> <p>Approach: <pre><code>// Compiler ensures MyActor implements Handler&lt;MyMessage&gt;\nimpl Handler&lt;MyMessage&gt; for MyActor {\n    async fn handle(&amp;mut self, msg: MyMessage, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; String {\n        // Return type must match Message::Result\n        \"response\".to_string()\n    }\n}\n</code></pre></p> <p>Rationale: Catches type errors at compile time, not runtime. Rust's type system provides stronger guarantees than dynamic languages.</p> <p>3. Erlang-Inspired Supervision</p> <p>Goal: Automatic fault recovery through supervision trees.</p> <p>Approach: - OneForOne: Restart only failed child - OneForAll: Restart all children (coordinated state) - RestForOne: Restart failed child and later siblings (dependency chains)</p> <p>Rationale: Erlang proved supervision enables \"let it crash\" philosophy for fault tolerance.</p> <p>4. Zero-Cost Abstractions</p> <p>Goal: Actor model convenience without runtime performance penalty.</p> <p>Approach: - Generic traits compiled to concrete types - No virtual dispatch unless explicitly needed - Inlined message handling for hot paths</p> <p>Rationale: Rust's philosophy - abstractions shouldn't cost performance.</p>"},{"location":"components/rt/explanation/actor-model/#design-decisions","title":"Design Decisions","text":"<p>Decision: Bounded and Unbounded Mailboxes</p> <p>Context: Erlang uses unbounded mailboxes by default, Akka offers both.</p> <p>Choice: Provide both bounded (with backpressure) and unbounded mailboxes.</p> <p>Rationale: - Unbounded: Simplicity, matches Erlang semantics, suitable for low-traffic actors - Bounded: Prevents memory exhaustion, applies backpressure, suitable for high-traffic</p> <p>Tradeoff: Complexity (choosing mailbox type) vs. Flexibility (handling different traffic patterns).</p> <p>Decision: Async/Await for Message Handlers</p> <p>Context: Erlang uses process suspension, Akka uses futures.</p> <p>Choice: Use Rust's <code>async/await</code> for all message handlers.</p> <p>Rationale: - Integrates with Tokio ecosystem - Familiar to Rust developers - Efficient cooperative scheduling</p> <p>Tradeoff: Requires <code>async_trait</code> for async trait methods vs. ergonomic native async.</p> <p>Decision: Message Broker for Pub-Sub</p> <p>Context: Erlang uses process groups, Akka uses EventBus/EventStream.</p> <p>Choice: Provide <code>MessageBroker</code> trait with pub-sub support.</p> <p>Rationale: - Decouples message routing from actor implementation - Supports both point-to-point and pub-sub patterns - Enables future extensions (remote actors, clustering)</p> <p>Tradeoff: Additional indirection (~180ns overhead) vs. Flexibility.</p>"},{"location":"components/rt/explanation/actor-model/#comparison-with-alternatives","title":"Comparison with Alternatives","text":""},{"location":"components/rt/explanation/actor-model/#actor-model-vs-shared-memory-threading","title":"Actor Model vs. Shared-Memory Threading","text":"<p>Shared-Memory Threading (Mutex, RwLock):</p> <p>Pros: - Direct memory access (no message copying) - Fine-grained locking for performance - Familiar to most developers</p> <p>Cons: - Deadlock risk with multiple locks - Race conditions if locks forgotten - Difficult to reason about correctness - Does not scale to distributed systems</p> <p>When to Prefer: Single-machine, shared-memory workloads where fine-grained locking is critical (e.g., high-frequency trading).</p> <p>Actor Model:</p> <p>Pros: - No deadlocks by design - No race conditions within actors - Naturally distributable - Easier to reason about</p> <p>Cons: - Message passing overhead (~737ns) - Cannot share memory (must copy messages) - May require more memory (message copies)</p> <p>When to Prefer: Concurrent, potentially distributed systems where isolation and fault tolerance matter.</p>"},{"location":"components/rt/explanation/actor-model/#actor-model-vs-channels-csp","title":"Actor Model vs. Channels (CSP)","text":"<p>Communicating Sequential Processes (CSP) - Go, Rust Channels:</p> <p>Approach: <pre><code>// CSP: Processes communicate through channels\nlet (tx, rx) = tokio::sync::mpsc::channel(100);\n\ntokio::spawn(async move {\n    tx.send(42).await.unwrap();\n});\n\nlet value = rx.recv().await.unwrap();\n</code></pre></p> <p>Pros: - Simple mental model (pipes between processes) - Lightweight (just channels, no actor abstraction) - Composable (select between channels)</p> <p>Cons: - No built-in supervision or fault tolerance - Manual lifecycle management - No natural abstraction for stateful entities</p> <p>When to Prefer: Pipeline-style processing, stream transformations, simple producer-consumer patterns.</p> <p>Actor Model:</p> <p>Pros: - Encapsulates state and behavior together - Built-in supervision and fault tolerance - Natural abstraction for entities (users, sessions, devices)</p> <p>Cons: - More abstraction overhead - Requires actor framework</p> <p>When to Prefer: Entity-oriented systems, fault-tolerant services, stateful concurrent entities.</p>"},{"location":"components/rt/explanation/actor-model/#actor-model-vs-async-tasks","title":"Actor Model vs. Async Tasks","text":"<p>Async Tasks (Tokio spawn):</p> <p>Approach: <pre><code>// Spawning async tasks directly\ntokio::spawn(async {\n    // Task logic\n});\n</code></pre></p> <p>Pros: - Minimal overhead - Direct control over task lifecycle - No framework required</p> <p>Cons: - No structured concurrency - No fault tolerance - No state encapsulation patterns - Manual error handling and recovery</p> <p>When to Prefer: Simple background tasks, fire-and-forget operations, short-lived computations.</p> <p>Actor Model:</p> <p>Pros: - Structured concurrency through supervision - Automatic fault recovery - State encapsulation patterns - Message-driven coordination</p> <p>Cons: - Framework dependency - More complex setup</p> <p>When to Prefer: Long-lived stateful services, fault-tolerant systems, coordinated concurrent entities.</p>"},{"location":"components/rt/explanation/actor-model/#tradeoffs-and-considerations","title":"Tradeoffs and Considerations","text":""},{"location":"components/rt/explanation/actor-model/#performance-tradeoffs","title":"Performance Tradeoffs","text":"<p>Message Passing Overhead:</p> <p>Cost: ~737ns per message roundtrip (October 2025 baseline)</p> <p>Implication: For extremely high-frequency operations (&gt;1M ops/sec per entity), shared memory may be faster.</p> <p>Mitigation: - Batch messages when possible (681ns/actor for batch operations) - Use direct actor references instead of broker (saves ~180ns routing) - Profile hot paths and optimize critical message handlers</p> <p>Memory Overhead:</p> <p>Cost: Each actor requires ~1KB memory (struct + mailbox + context)</p> <p>Implication: 1 million actors = ~1GB memory minimum</p> <p>Mitigation: - Pool actors for similar workloads - Use lazy actor creation (create on-demand) - Implement actor hibernation for idle actors</p>"},{"location":"components/rt/explanation/actor-model/#complexity-tradeoffs","title":"Complexity Tradeoffs","text":"<p>Learning Curve:</p> <p>Challenge: Developers must learn actor model concepts (supervision, message passing, lifecycle).</p> <p>Benefit: Once learned, applicable across languages (Erlang, Akka, Orleans, AirsSys).</p> <p>Mitigation: - Comprehensive tutorials and examples - Builder patterns for common use cases - Clear error messages and debugging tools</p> <p>Debugging:</p> <p>Challenge: Asynchronous message passing makes stack traces less informative.</p> <p>Benefit: Isolated failures are easier to reproduce and reason about.</p> <p>Mitigation: - Distributed tracing support - Comprehensive logging in supervisors - Health monitoring infrastructure</p>"},{"location":"components/rt/explanation/actor-model/#architectural-tradeoffs","title":"Architectural Tradeoffs","text":"<p>Granularity:</p> <p>Too Fine-Grained: One actor per entity (e.g., one actor per user session)</p> <p>Risk: Excessive memory usage, high message overhead</p> <p>Too Coarse-Grained: One actor for many entities (e.g., one actor for all user sessions)</p> <p>Risk: Lost concurrency, state sharing complexity</p> <p>Guideline: Match actor granularity to natural concurrency boundaries (one actor per independent concurrent entity).</p>"},{"location":"components/rt/explanation/actor-model/#when-to-use-actors","title":"When to Use Actors","text":""},{"location":"components/rt/explanation/actor-model/#ideal-use-cases","title":"Ideal Use Cases","text":"<p>1. Stateful Services</p> <p>Scenario: Each user session, device connection, or game entity maintains independent state.</p> <p>Why Actors: Natural one-to-one mapping between actors and stateful entities. Isolation prevents cross-contamination.</p> <p>Example: Online gaming (one actor per player), IoT (one actor per device), web sessions (one actor per user).</p> <p>2. Fault-Tolerant Systems</p> <p>Scenario: System must continue operating despite individual component failures.</p> <p>Why Actors: Supervision trees isolate failures and enable automatic recovery without global system restart.</p> <p>Example: Telecom switches, payment processing, real-time analytics.</p> <p>3. Scalable Concurrent Systems</p> <p>Scenario: System must handle millions of concurrent operations with linear scalability.</p> <p>Why Actors: Independent actors scale horizontally, no shared locks to contend on.</p> <p>Example: Chat servers (one actor per conversation), stream processing (one actor per stream), microservices.</p> <p>4. Event-Driven Architectures</p> <p>Scenario: System reacts to external events (messages, HTTP requests, sensor data).</p> <p>Why Actors: Message-driven model naturally maps to event processing. Actors represent event handlers.</p> <p>Example: CQRS/Event Sourcing, reactive microservices, event stream processing.</p>"},{"location":"components/rt/explanation/actor-model/#when-not-to-use-actors","title":"When Not to Use Actors","text":"<p>1. Purely Computational Tasks</p> <p>Scenario: CPU-intensive computation with no state or I/O.</p> <p>Why Not: Message overhead adds latency. Simple parallel loops or <code>rayon</code> are more efficient.</p> <p>Alternative: Use <code>rayon</code> for data parallelism, reserve actors for coordination.</p> <p>2. Shared-Memory Performance Critical</p> <p>Scenario: Ultra-low latency (nanoseconds) shared-memory access required.</p> <p>Why Not: Message passing adds ~737ns overhead. Lock-free data structures may be faster.</p> <p>Alternative: Use <code>Arc&lt;RwLock&lt;T&gt;&gt;</code> or lock-free structures for hot shared state.</p> <p>3. Simple Request-Response</p> <p>Scenario: Basic HTTP API with stateless request handling.</p> <p>Why Not: Actor overhead unnecessary for stateless services. Simple async handlers suffice.</p> <p>Alternative: Use Axum/Actix-Web request handlers directly, reserve actors for stateful business logic.</p> <p>4. Tight Coupling Required</p> <p>Scenario: Components must share complex data structures frequently.</p> <p>Why Not: Actors enforce isolation. Frequent large message copying is inefficient.</p> <p>Alternative: Use shared ownership (<code>Arc&lt;T&gt;</code>) for read-heavy shared data, actors for coordination.</p>"},{"location":"components/rt/explanation/actor-model/#philosophical-perspective","title":"Philosophical Perspective","text":""},{"location":"components/rt/explanation/actor-model/#let-it-crash-philosophy","title":"\"Let it Crash\" Philosophy","text":"<p>Traditional Approach: Defensive programming - handle every possible error, prevent crashes.</p> <pre><code>// Traditional: exhaustive error handling\nmatch operation() {\n    Ok(result) =&gt; handle_success(result),\n    Err(NetworkError) =&gt; retry_with_backoff(),\n    Err(ParseError) =&gt; use_default_value(),\n    Err(AuthError) =&gt; request_new_credentials(),\n    // ...every possible error case\n}\n</code></pre> <p>Actor Model Approach: Accept that failures happen, design for recovery instead of prevention.</p> <pre><code>// Actor model: supervisor handles failures\nasync fn handle(&amp;mut self, msg: DoWork, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; Result&lt;(), ActorError&gt; {\n    operation()?  // If error, actor crashes\n    // Supervisor detects crash and restarts actor\n    Ok(())\n}\n</code></pre> <p>Rationale: In complex distributed systems, exhaustive error handling is impossible. Better to isolate failures and recover quickly than to handle every edge case.</p> <p>When to Apply: Services with complex failure modes, distributed systems, long-running processes.</p> <p>When Not to Apply: Critical infrastructure (kernel, databases), deterministic real-time systems.</p>"},{"location":"components/rt/explanation/actor-model/#the-erlang-legacy","title":"The Erlang Legacy","text":"<p>AirsSys RT builds on 35+ years of Erlang production experience:</p> <p>Proven Patterns: - Supervision trees for fault tolerance - Process isolation for reliability - Message passing for scalability - \"Let it crash\" for simplicity</p> <p>Modern Enhancements: - Rust's type safety eliminates entire classes of errors - Zero-cost abstractions provide performance without compromising safety - Async/await enables efficient cooperative scheduling - Compile-time guarantees catch bugs earlier</p>"},{"location":"components/rt/explanation/actor-model/#further-reading","title":"Further Reading","text":""},{"location":"components/rt/explanation/actor-model/#foundational-papers","title":"Foundational Papers","text":"<ul> <li>Hewitt, Bishop, Steiger (1973): \"A Universal Modular ACTOR Formalism for Artificial Intelligence\"</li> <li>Agha (1985): \"Actors: A Model of Concurrent Computation in Distributed Systems\"</li> </ul>"},{"location":"components/rt/explanation/actor-model/#actor-model-implementations","title":"Actor Model Implementations","text":"<ul> <li>Erlang/OTP: The original production actor system</li> <li>Akka (Scala/Java): JVM actor framework with location transparency</li> <li>Orleans (.NET): Virtual actors for cloud-scale systems</li> <li>Actix (Rust): High-performance actor framework</li> </ul>"},{"location":"components/rt/explanation/actor-model/#airssys-rt-documentation","title":"AirsSys RT Documentation","text":"<ul> <li>Architecture Overview</li> <li>Supervision Explained</li> <li>Message Passing Explained</li> <li>API Reference</li> </ul> <p>Last Updated: 2025-01-18 (RT-TASK-011 Phase 4 Day 7)</p>"},{"location":"components/rt/explanation/builder-pattern/","title":"Understanding the Builder Pattern","text":"<p>This document explains the builder pattern usage in AirsSys RT, the rationale for adopting it, and how it improves API ergonomics and type safety.</p>"},{"location":"components/rt/explanation/builder-pattern/#table-of-contents","title":"Table of Contents","text":"<ul> <li>What is the Builder Pattern?</li> <li>Why Builder Pattern in AirsSys RT?</li> <li>Builder Pattern Implementation</li> <li>Design Decisions</li> <li>Migration from Direct Construction</li> <li>Best Practices</li> </ul>"},{"location":"components/rt/explanation/builder-pattern/#what-is-the-builder-pattern","title":"What is the Builder Pattern?","text":"<p>The Builder Pattern is a creational design pattern that provides a fluent API for constructing complex objects step-by-step. Instead of using constructors with many parameters, builders allow setting each property individually with method chaining.</p>"},{"location":"components/rt/explanation/builder-pattern/#traditional-construction-without-builder","title":"Traditional Construction (Without Builder)","text":"<pre><code>// Constructor with many parameters\nlet supervisor = Supervisor::new(\n    RestartStrategy::OneForOne,\n    10,  // max_restarts\n    Duration::from_secs(60),  // restart_window\n    vec![\n        ChildSpec::new(\"worker-1\", ...),\n        ChildSpec::new(\"worker-2\", ...),\n    ],\n);\n\n// Problems:\n// 1. Parameter order easily confused\n// 2. No compile-time validation of required fields\n// 3. Difficult to add optional parameters\n// 4. Hard to read (what do 10 and 60 mean?)\n</code></pre>"},{"location":"components/rt/explanation/builder-pattern/#builder-pattern-construction","title":"Builder Pattern Construction","text":"<pre><code>// Fluent builder API\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)  // Clear intent\n    .with_max_restarts(10)                       // Named parameter\n    .with_restart_window(Duration::from_secs(60)) // Self-documenting\n    .with_child(\n        ChildSpec::new(\"worker-1\")\n            .with_actor::&lt;WorkerActor&gt;()\n    )\n    .with_child(\n        ChildSpec::new(\"worker-2\")\n            .with_actor::&lt;WorkerActor&gt;()\n    )\n    .build()  // Validates and constructs\n    .await?;\n\n// Benefits:\n// 1. Parameter names clear (self-documenting)\n// 2. Compile-time required field checking\n// 3. Easy to add optional parameters\n// 4. Readable, fluent API\n</code></pre>"},{"location":"components/rt/explanation/builder-pattern/#why-builder-pattern-in-airssys-rt","title":"Why Builder Pattern in AirsSys RT?","text":""},{"location":"components/rt/explanation/builder-pattern/#problem-complex-configuration","title":"Problem: Complex Configuration","text":"<p>AirsSys RT components (supervisors, actors, mailboxes) have many configuration options:</p> <p>Supervisor Configuration: - Restart strategy (OneForOne, OneForAll, RestForOne) - Max restarts and restart window - Child specifications (multiple children) - Health monitoring configuration - Shutdown policies</p> <p>Actor Configuration: - Mailbox type (Bounded, Unbounded) - Mailbox capacity (if bounded) - Backpressure strategy (Block, Drop, Error) - Initial state - Lifecycle hooks</p> <p>Challenge: How to provide flexible, ergonomic configuration without sacrificing type safety?</p>"},{"location":"components/rt/explanation/builder-pattern/#solution-builder-pattern","title":"Solution: Builder Pattern","text":"<p>Decision: Migrate all complex constructors to builder pattern.</p> <p>Rationale:</p> <ol> <li>Ergonomics: Method chaining provides fluent, readable API</li> <li>Type Safety: Compile-time checking of required fields</li> <li>Flexibility: Easy to add optional configuration without breaking changes</li> <li>Discoverability: IDEs autocomplete available configuration methods</li> <li>Validation: <code>build()</code> method validates configuration before construction</li> </ol> <p>Implementation Status: - \u2705 Completed: Supervisor builder pattern - \u2705 Completed: Batch supervisor operations - \u2705 Completed: Migration guide and examples - \ud83d\udd04 Future: Actor builder, ChildSpec builder, System builder</p>"},{"location":"components/rt/explanation/builder-pattern/#builder-pattern-implementation","title":"Builder Pattern Implementation","text":""},{"location":"components/rt/explanation/builder-pattern/#supervisor-builder","title":"Supervisor Builder","text":"<p>API Design:</p> <pre><code>pub struct SupervisorBuilder {\n    strategy: Option&lt;RestartStrategy&gt;,\n    max_restarts: Option&lt;u32&gt;,\n    restart_window: Option&lt;Duration&gt;,\n    children: Vec&lt;ChildSpec&gt;,\n    health_monitoring: bool,\n}\n\nimpl SupervisorBuilder {\n    pub fn new() -&gt; Self {\n        Self {\n            strategy: None,\n            max_restarts: Some(10),  // Sensible default\n            restart_window: Some(Duration::from_secs(60)),  // Sensible default\n            children: Vec::new(),\n            health_monitoring: false,\n        }\n    }\n\n    pub fn with_strategy(mut self, strategy: RestartStrategy) -&gt; Self {\n        self.strategy = Some(strategy);\n        self  // Return self for method chaining\n    }\n\n    pub fn with_max_restarts(mut self, max: u32) -&gt; Self {\n        self.max_restarts = Some(max);\n        self\n    }\n\n    pub fn with_restart_window(mut self, window: Duration) -&gt; Self {\n        self.restart_window = Some(window);\n        self\n    }\n\n    pub fn with_child(mut self, child: ChildSpec) -&gt; Self {\n        self.children.push(child);\n        self\n    }\n\n    pub async fn build(self) -&gt; Result&lt;Supervisor, BuildError&gt; {\n        // Validate required fields\n        let strategy = self.strategy\n            .ok_or(BuildError::MissingStrategy)?;\n\n        // Validate configuration\n        if self.children.is_empty() {\n            return Err(BuildError::NoChildren);\n        }\n\n        // Construct supervisor\n        Ok(Supervisor {\n            strategy,\n            max_restarts: self.max_restarts.unwrap(),\n            restart_window: self.restart_window.unwrap(),\n            children: self.children,\n            health_monitoring: self.health_monitoring,\n        })\n    }\n}\n</code></pre> <p>Key Design Elements:</p> <ol> <li>Builder struct with <code>Option&lt;T&gt;</code> fields - Track which fields are set</li> <li><code>new()</code> constructor - Initialize with defaults</li> <li><code>with_*()</code> methods - Set individual fields, return <code>self</code> for chaining</li> <li><code>build()</code> method - Validate and construct final object</li> </ol>"},{"location":"components/rt/explanation/builder-pattern/#childspec-builder-future","title":"ChildSpec Builder (Future)","text":"<p>Planned API:</p> <pre><code>let child = ChildSpec::builder(\"worker-1\")\n    .with_actor::&lt;WorkerActor&gt;()\n    .with_restart_policy(RestartPolicy::Permanent)\n    .with_shutdown_timeout(Duration::from_secs(5))\n    .build()?;\n</code></pre> <p>Current API (Direct Construction):</p> <pre><code>let child = ChildSpec::new(\"worker-1\")\n    .with_actor::&lt;WorkerActor&gt;()\n    .with_restart_policy(RestartPolicy::Permanent);\n</code></pre> <p>Migration: Current API already uses method chaining, formal builder provides validation.</p>"},{"location":"components/rt/explanation/builder-pattern/#design-decisions","title":"Design Decisions","text":""},{"location":"components/rt/explanation/builder-pattern/#decision-separate-builder-and-product","title":"Decision: Separate Builder and Product","text":"<p>Choice: Builder (<code>SupervisorBuilder</code>) and product (<code>Supervisor</code>) are separate types.</p> <p>Alternative: Mutable methods on <code>Supervisor</code> itself.</p> <pre><code>// Alternative: In-place mutation (NOT chosen)\nlet mut supervisor = Supervisor::new();\nsupervisor.set_strategy(RestartStrategy::OneForOne);\nsupervisor.add_child(child);\n</code></pre> <p>Rationale for Separation:</p> <ol> <li>Immutability: Built object is immutable (configuration frozen after <code>build()</code>)</li> <li>Validation: <code>build()</code> validates before construction (invalid config never creates object)</li> <li>Type State Pattern (Future): Builder can use type state to enforce required fields at compile time</li> </ol> <p>Tradeoff: More code (two types instead of one) vs. Better encapsulation and validation.</p>"},{"location":"components/rt/explanation/builder-pattern/#decision-sensible-defaults","title":"Decision: Sensible Defaults","text":"<p>Choice: Provide sensible defaults for optional configuration.</p> <pre><code>impl SupervisorBuilder {\n    pub fn new() -&gt; Self {\n        Self {\n            max_restarts: Some(10),  // Default: 10 restarts\n            restart_window: Some(Duration::from_secs(60)),  // Default: 60 seconds\n            strategy: None,  // Required field (no default)\n            children: Vec::new(),  // Required field (no default)\n            health_monitoring: false,  // Default: disabled\n        }\n    }\n}\n</code></pre> <p>Rationale:</p> <ul> <li>Required fields: No default (force user to specify)</li> <li>Optional fields: Sensible defaults (minimize boilerplate)</li> </ul> <p>Example:</p> <pre><code>// Minimal configuration (uses defaults for optional fields)\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)  // Required\n    .with_child(child)  // Required\n    .build()\n    .await?;\n// max_restarts, restart_window use defaults\n</code></pre> <p>Tradeoff: Hidden defaults may surprise users vs. Reduced boilerplate.</p>"},{"location":"components/rt/explanation/builder-pattern/#decision-async-build-method","title":"Decision: Async <code>build()</code> Method","text":"<p>Choice: <code>build()</code> is <code>async fn</code> returning <code>Future</code>.</p> <pre><code>pub async fn build(self) -&gt; Result&lt;Supervisor, BuildError&gt; { ... }\n</code></pre> <p>Rationale:</p> <ul> <li>Supervisor construction may involve async operations (spawning actors, initialization)</li> <li>Consistent with Rust async ecosystem (Tokio, async-trait)</li> </ul> <p>Alternative: Synchronous <code>build()</code> + separate <code>start()</code> method.</p> <pre><code>// Alternative: Two-phase construction (NOT chosen)\nlet supervisor = builder.build()?;  // Sync\nsupervisor.start().await?;  // Async\n</code></pre> <p>Tradeoff: Simpler API (one method) vs. Two-phase initialization flexibility.</p>"},{"location":"components/rt/explanation/builder-pattern/#decision-compile-time-vs-runtime-validation","title":"Decision: Compile-Time vs. Runtime Validation","text":"<p>Current: Runtime validation in <code>build()</code> method.</p> <pre><code>pub async fn build(self) -&gt; Result&lt;Supervisor, BuildError&gt; {\n    // Runtime check\n    let strategy = self.strategy.ok_or(BuildError::MissingStrategy)?;\n\n    if self.children.is_empty() {\n        return Err(BuildError::NoChildren);  // Runtime error\n    }\n\n    Ok(...)\n}\n</code></pre> <p>Future: Type-state pattern for compile-time validation.</p> <pre><code>// Type-state pattern (future enhancement)\nstruct SupervisorBuilder&lt;State&gt; {\n    strategy: RestartStrategy,  // Always set in this state\n    ...\n}\n\nimpl SupervisorBuilder&lt;NoStrategy&gt; {\n    pub fn with_strategy(self, strategy: RestartStrategy) -&gt; SupervisorBuilder&lt;HasStrategy&gt; {\n        SupervisorBuilder { strategy, ... }  // Transition to HasStrategy state\n    }\n}\n\nimpl SupervisorBuilder&lt;HasStrategy&gt; {\n    pub async fn build(self) -&gt; Supervisor {  // No Result, always succeeds\n        Supervisor { strategy: self.strategy, ... }\n    }\n}\n\n// Usage\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)  // Type changes to HasStrategy\n    .build()  // Compiles only if strategy is set\n    .await;\n</code></pre> <p>Tradeoff: Type-state is complex but provides compile-time guarantees.</p> <p>Decision: Start with runtime validation, migrate to type-state if proven beneficial.</p>"},{"location":"components/rt/explanation/builder-pattern/#migration-from-direct-construction","title":"Migration from Direct Construction","text":""},{"location":"components/rt/explanation/builder-pattern/#migration-guide","title":"Migration Guide","text":"<p>Old API (Direct Construction):</p> <pre><code>// Old: Direct constructor with positional arguments\nlet supervisor = Supervisor::new(\n    RestartStrategy::OneForOne,\n    10,\n    Duration::from_secs(60),\n    vec![child1, child2],\n);\n</code></pre> <p>New API (Builder Pattern):</p> <pre><code>// New: Fluent builder API\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .with_max_restarts(10)\n    .with_restart_window(Duration::from_secs(60))\n    .with_child(child1)\n    .with_child(child2)\n    .build()\n    .await?;\n</code></pre>"},{"location":"components/rt/explanation/builder-pattern/#migration-strategy","title":"Migration Strategy","text":"<p>Phase 1: Introduce builder alongside existing constructor (both APIs coexist)</p> <pre><code>// Old API still works (deprecated)\n#[deprecated(note = \"Use SupervisorBuilder instead\")]\nimpl Supervisor {\n    pub fn new(...) -&gt; Self { ... }\n}\n\n// New API available\nimpl SupervisorBuilder { ... }\n</code></pre> <p>Phase 2: Update examples and documentation to use builder</p> <p>Phase 3: Remove old constructor in next major version (breaking change)</p>"},{"location":"components/rt/explanation/builder-pattern/#backward-compatibility","title":"Backward Compatibility","text":"<p>Approach: Deprecate old API but keep functional for one major version.</p> <pre><code>#[deprecated(since = \"0.2.0\", note = \"Use SupervisorBuilder instead\")]\npub fn new(...) -&gt; Self { ... }\n</code></pre> <p>Timeline: - v0.1.x: Old API primary, builder experimental - v0.2.x: Builder primary, old API deprecated - v0.3.x: Old API removed (breaking change)</p>"},{"location":"components/rt/explanation/builder-pattern/#best-practices","title":"Best Practices","text":""},{"location":"components/rt/explanation/builder-pattern/#1-use-builders-for-complex-configuration","title":"1. Use Builders for Complex Configuration","text":"<p>When to Use Builder:</p> <ul> <li>\u2705 3+ configuration parameters</li> <li>\u2705 Optional parameters common</li> <li>\u2705 Configuration order not obvious</li> <li>\u2705 Validation required before construction</li> </ul> <p>When to Use Direct Constructor:</p> <ul> <li>\u2705 Simple objects (1-2 parameters)</li> <li>\u2705 All parameters required</li> <li>\u2705 No validation needed</li> <li>\u2705 Construction is straightforward</li> </ul> <p>Example:</p> <pre><code>// Simple object: Direct constructor ok\nlet actor_ref = ActorRef::new(actor_id);\n\n// Complex object: Builder preferred\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .with_max_restarts(10)\n    .with_child(child)\n    .build()\n    .await?;\n</code></pre>"},{"location":"components/rt/explanation/builder-pattern/#2-provide-sensible-defaults","title":"2. Provide Sensible Defaults","text":"<p>Principle: Required fields have no default, optional fields have sensible defaults.</p> <pre><code>impl SupervisorBuilder {\n    pub fn new() -&gt; Self {\n        Self {\n            // Required (no default) - user must specify\n            strategy: None,\n            children: Vec::new(),\n\n            // Optional (sensible defaults)\n            max_restarts: Some(10),\n            restart_window: Some(Duration::from_secs(60)),\n            health_monitoring: false,\n        }\n    }\n}\n</code></pre> <p>Guideline: Choose defaults that work for 80% of use cases.</p>"},{"location":"components/rt/explanation/builder-pattern/#3-validate-in-build-method","title":"3. Validate in <code>build()</code> Method","text":"<p>Principle: Validate configuration before constructing object.</p> <pre><code>pub async fn build(self) -&gt; Result&lt;Supervisor, BuildError&gt; {\n    // Validate required fields\n    let strategy = self.strategy.ok_or(BuildError::MissingStrategy)?;\n\n    // Validate constraints\n    if self.children.is_empty() {\n        return Err(BuildError::NoChildren);\n    }\n\n    if self.max_restarts.unwrap() == 0 {\n        return Err(BuildError::InvalidMaxRestarts);\n    }\n\n    // All valid, construct\n    Ok(Supervisor { ... })\n}\n</code></pre> <p>Benefits: - Invalid configuration detected early (at <code>build()</code>, not later) - Clear error messages (explain what's missing/wrong) - Prevents invalid objects from being constructed</p>"},{"location":"components/rt/explanation/builder-pattern/#4-document-builder-usage","title":"4. Document Builder Usage","text":"<p>Provide Examples:</p> <pre><code>/// # Examples\n///\n/// Basic usage:\n/// ```\n/// # use airssys_rt::supervisor::*;\n/// # async fn example() -&gt; Result&lt;(), BuildError&gt; {\n/// let supervisor = SupervisorBuilder::new()\n///     .with_strategy(RestartStrategy::OneForOne)\n///     .with_child(ChildSpec::new(\"worker\").with_actor::&lt;Worker&gt;())\n///     .build()\n///     .await?;\n/// # Ok(())\n/// # }\n/// ```\nimpl SupervisorBuilder { ... }\n</code></pre> <p>Rationale: Examples help users discover builder API and understand usage patterns.</p>"},{"location":"components/rt/explanation/builder-pattern/#builder-pattern-benefits","title":"Builder Pattern Benefits","text":""},{"location":"components/rt/explanation/builder-pattern/#1-self-documenting-code","title":"1. Self-Documenting Code","text":"<p>Without Builder: <pre><code>// What do these numbers mean?\nSupervisor::new(RestartStrategy::OneForOne, 10, 60, children);\n</code></pre></p> <p>With Builder: <pre><code>// Crystal clear intent\nSupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .with_max_restarts(10)  // 10 restarts\n    .with_restart_window(Duration::from_secs(60))  // in 60 seconds\n    .with_children(children)\n    .build()\n    .await?;\n</code></pre></p>"},{"location":"components/rt/explanation/builder-pattern/#2-easy-api-evolution","title":"2. Easy API Evolution","text":"<p>Adding Optional Parameter (Without Builder):</p> <pre><code>// Old constructor\npub fn new(strategy: RestartStrategy, children: Vec&lt;ChildSpec&gt;) -&gt; Self { ... }\n\n// New constructor (BREAKING CHANGE!)\npub fn new(\n    strategy: RestartStrategy,\n    children: Vec&lt;ChildSpec&gt;,\n    health_monitoring: bool,  // New parameter breaks all existing code!\n) -&gt; Self { ... }\n</code></pre> <p>Adding Optional Parameter (With Builder):</p> <pre><code>// Old builder\nimpl SupervisorBuilder {\n    pub fn with_strategy(...) -&gt; Self { ... }\n    pub fn with_children(...) -&gt; Self { ... }\n    pub fn build(...) -&gt; Result&lt;Supervisor, BuildError&gt; { ... }\n}\n\n// New builder (NON-BREAKING!)\nimpl SupervisorBuilder {\n    pub fn with_strategy(...) -&gt; Self { ... }\n    pub fn with_children(...) -&gt; Self { ... }\n    pub fn with_health_monitoring(mut self, enabled: bool) -&gt; Self {  // New method, old code unaffected!\n        self.health_monitoring = enabled;\n        self\n    }\n    pub fn build(...) -&gt; Result&lt;Supervisor, BuildError&gt; { ... }\n}\n</code></pre>"},{"location":"components/rt/explanation/builder-pattern/#3-compile-time-safety-future-type-state","title":"3. Compile-Time Safety (Future: Type-State)","text":"<p>Type-state pattern can enforce required fields at compile time:</p> <pre><code>// Won't compile: missing strategy\nlet supervisor = SupervisorBuilder::new()\n    .with_child(child)\n    .build()  // ERROR: cannot build without strategy\n    .await?;\n</code></pre> <p>Currently: Runtime validation, future enhancement for compile-time validation.</p>"},{"location":"components/rt/explanation/builder-pattern/#further-reading","title":"Further Reading","text":""},{"location":"components/rt/explanation/builder-pattern/#airssys-rt-documentation","title":"AirsSys RT Documentation","text":"<ul> <li>Supervisor Patterns Guide - Builder usage examples</li> <li>Architecture Overview - System design</li> </ul>"},{"location":"components/rt/explanation/builder-pattern/#external-resources","title":"External Resources","text":"<ul> <li>Rust API Guidelines: Builder pattern recommendations</li> <li>Effective Rust: Builder pattern chapter</li> <li>Type-State Pattern in Rust: Advanced compile-time validation</li> </ul> <p>Last Updated: 2025-01-18 (RT-TASK-011 Phase 4 Day 7)</p>"},{"location":"components/rt/explanation/future-use-cases/","title":"Future Use Cases","text":"<p>This document explores conceptual application patterns and future capabilities planned for <code>airssys-rt</code>. These examples illustrate the design vision and potential use cases that will be enabled as the runtime matures.</p> <p>[!IMPORTANT] Implementation Status: Planned</p> <p>The APIs and patterns shown here are conceptual designs representing planned functionality. They are not currently implemented and should not be used in production code.</p> <p>For working examples with current APIs, see: - Getting Started Guide - OSL Integration Example - Working Examples Directory</p>"},{"location":"components/rt/explanation/future-use-cases/#design-vision","title":"Design Vision","text":"<p>The <code>airssys-rt</code> runtime is designed to support high-level application patterns through its core actor model primitives. The following examples illustrate planned ergonomic APIs that will be built on top of the foundational components completed in Phases 1-2.</p>"},{"location":"components/rt/explanation/future-use-cases/#planned-use-case-patterns","title":"Planned Use Case Patterns","text":""},{"location":"components/rt/explanation/future-use-cases/#1-high-concurrency-server-pattern-planned","title":"1. High-Concurrency Server Pattern (Planned)","text":"<p>Concept: Leveraging actor isolation and supervision for handling thousands of concurrent network connections with fault tolerance.</p> <p>Planned API Design: <pre><code>// Conceptual API - NOT YET IMPLEMENTED\nuse airssys_rt::patterns::TcpServer;\nuse airssys_rt::supervisor::RestartStrategy;\n\nlet server = TcpServer::new()\n    .with_connection_actor(ConnectionActor::new())\n    .with_supervisor(connection_supervisor)\n    .bind(\"0.0.0.0:8080\").await?;\n</code></pre></p> <p>Design Rationale: - Each connection managed by isolated actor (fault containment) - Supervisor restarts failed connection handlers - Backpressure through actor mailbox capacity - Zero shared mutable state between connections</p> <p>Current Foundation: <pre><code>// What works today: Generic supervisor with broker-based actors\nuse airssys_rt::broker::InMemoryMessageBroker;\nuse airssys_rt::osl::OSLSupervisor;\n\nlet broker = InMemoryMessageBroker::new();\nlet supervisor = OSLSupervisor::new(broker.clone());\nsupervisor.start().await?;\n// Build high-level patterns on this foundation\n</code></pre></p> <p>Implementation Path: - Security context propagation for connection actors - TcpServer pattern implementation - Network actor integration with connection pooling</p>"},{"location":"components/rt/explanation/future-use-cases/#2-event-driven-architecture-pattern-planned","title":"2. Event-Driven Architecture Pattern (Planned)","text":"<p>Concept: Complex event processing with stateful actors, enabling event sourcing and CQRS patterns.</p> <p>Planned API Design: <pre><code>// Conceptual API - NOT YET IMPLEMENTED\nuse airssys_rt::patterns::EventProcessor;\n\nlet event_processor = EventProcessor::new()\n    .with_handler(OrderHandler::new())\n    .with_handler(PaymentHandler::new())\n    .with_supervisor(business_logic_supervisor)\n    .start().await?;\n</code></pre></p> <p>Design Rationale: - Event handlers as isolated actors (independent scaling) - Supervisor ensures handler availability - Event ordering preserved per handler - Failed events can be retried or dead-lettered</p> <p>Current Foundation: <pre><code>// What works today: Message broker with pub-sub pattern\nuse airssys_rt::broker::{MessageBroker, InMemoryMessageBroker};\nuse airssys_rt::message::Message;\n\n// Actors subscribe to message types, process independently\nbroker.subscribe().await?;\nbroker.publish(event_message).await?;\n// Event handlers built on broker primitives\n</code></pre></p> <p>Implementation Path: - Audit logging for event processing - Event handler pattern library - Event sourcing utilities and examples</p>"},{"location":"components/rt/explanation/future-use-cases/#3-system-service-management-pattern-planned","title":"3. System Service Management Pattern (Planned)","text":"<p>Concept: Reliable coordination of system services with dependency management and health monitoring.</p> <p>Planned API Design: <pre><code>// Conceptual API - NOT YET IMPLEMENTED\nuse airssys_rt::patterns::ServiceManager;\nuse airssys_rt::supervisor::RestartStrategy;\n\nlet service_manager = ServiceManager::new()\n    .service(\"database\", DatabaseService::new())\n    .service(\"cache\", CacheService::new())\n    .service(\"metrics\", MetricsService::new())\n    .with_restart_strategy(RestartStrategy::OneForOne)\n    .start().await?;\n</code></pre></p> <p>Design Rationale: - Services as supervised actors (automatic restart) - Dependency ordering with RestForOne strategy - Health checks via actor lifecycle - Graceful shutdown coordination</p> <p>Current Foundation: <pre><code>// What works today: Supervisor with restart strategies\nuse airssys_rt::supervisor::strategy::RestForOne;\nuse airssys_rt::osl::OSLSupervisor;\n\n// OSLSupervisor manages FileSystem, Process, Network actors\n// RestForOne strategy: dependent actors restart in order\nlet supervisor = OSLSupervisor::new(broker.clone());\n// Service manager pattern extends this model\n</code></pre></p> <p>Implementation Path: - Service health monitoring integration - ServiceManager pattern with dependency graph - Service orchestration examples</p>"},{"location":"components/rt/explanation/future-use-cases/#architecture-evolution","title":"Architecture Evolution","text":""},{"location":"components/rt/explanation/future-use-cases/#current-capabilities","title":"Current Capabilities","text":"<p>What's Working Today: - \u2705 Generic <code>Actor&lt;M, B&gt;</code> trait with broker dependency injection - \u2705 <code>OSLSupervisor</code> managing FileSystem, Process, Network actors - \u2705 <code>InMemoryMessageBroker</code> with pub-sub messaging - \u2705 RestForOne restart strategy - \u2705 Named actor addresses and message correlation - \u2705 Integration with airssys-osl for system operations</p> <p>Reference Implementation: See <code>examples/osl_integration_example.rs</code> for complete working code demonstrating current capabilities.</p>"},{"location":"components/rt/explanation/future-use-cases/#planned-evolution","title":"Planned Evolution","text":"<p>Security and Audit Integration (Next): - Security context propagation through actor hierarchy - Audit logging for all actor operations - Permission validation in supervisors</p> <p>High-Level Patterns (Future): - TcpServer, EventProcessor, ServiceManager patterns - Additional examples and pattern library - Performance benchmarks and optimization - Migration guides from raw actor APIs</p>"},{"location":"components/rt/explanation/future-use-cases/#design-principles","title":"Design Principles","text":"<p>The planned high-level patterns follow these core principles:</p> <ol> <li>Composition over Configuration: Patterns built from small, composable primitives</li> <li>Type Safety: Generic constraints prevent runtime type errors</li> <li>Dependency Injection: Broker and dependencies injected, not hard-coded</li> <li>Failure Isolation: Supervisor strategies contain failures</li> <li>Message-Based: No shared mutable state, only message passing</li> </ol>"},{"location":"components/rt/explanation/future-use-cases/#migration-from-foundation-to-patterns","title":"Migration from Foundation to Patterns","text":"<p>When high-level patterns become available, migration will follow this model:</p> <p>Current (Foundation API): <pre><code>// Direct use of core primitives\nlet broker = InMemoryMessageBroker::new();\nlet supervisor = OSLSupervisor::new(broker.clone());\nlet filesystem_actor = FileSystemActor::new(broker.clone());\n</code></pre></p> <p>Future (Pattern API): <pre><code>// Higher-level ergonomic patterns\nlet server = TcpServer::new()\n    .with_supervisor(...)  // Built on foundation primitives\n    .start().await?;\n</code></pre></p> <p>Key Point: Foundation APIs remain stable. Patterns are additive, not breaking changes.</p>"},{"location":"components/rt/explanation/future-use-cases/#references","title":"References","text":"<ul> <li>Current Implementation: See OSL Integration</li> <li>Architecture: See Supervisor Trees</li> <li>ADR-RT-009: Broker Dependency Injection pattern</li> <li>Development Status: See main README</li> </ul>"},{"location":"components/rt/explanation/future-use-cases/#providing-feedback","title":"Providing Feedback","text":"<p>These planned use cases represent our current design vision. If you have: - Feedback on planned APIs: Open a discussion in the repository - Alternative patterns to suggest: Submit an RFC (Request for Comments) - Use cases we haven't considered: File an issue with your requirements</p> <p>Your input helps shape the evolution of <code>airssys-rt</code> to better serve real-world needs.</p> <p>Last Updated: 2025-10-14 Status: Conceptual Design - Implementation Planned</p>"},{"location":"components/rt/explanation/message-passing/","title":"Understanding Message Passing","text":"<p>This document explains message passing in AirsSys RT, why it's fundamental to the actor model, design decisions around message routing, and performance considerations.</p>"},{"location":"components/rt/explanation/message-passing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Why Message Passing?</li> <li>Message Passing Semantics</li> <li>Message Routing Architecture</li> <li>Design Decisions</li> <li>Performance Characteristics</li> <li>Comparison with Alternatives</li> </ul>"},{"location":"components/rt/explanation/message-passing/#why-message-passing","title":"Why Message Passing?","text":""},{"location":"components/rt/explanation/message-passing/#the-shared-memory-problem","title":"The Shared-Memory Problem","text":"<p>Traditional concurrent programming relies on shared mutable state protected by locks:</p> <pre><code>// Shared-memory approach\nuse std::sync::{Arc, Mutex};\n\nstruct SharedCounter {\n    value: Arc&lt;Mutex&lt;i32&gt;&gt;,\n}\n\nimpl SharedCounter {\n    fn increment(&amp;self) {\n        let mut count = self.value.lock().unwrap();  // Acquire lock\n        *count += 1;  // Critical section - only one thread at a time\n        // Lock released when count drops\n    }\n}\n\n// Problems:\n// 1. Deadlocks: Complex lock ordering requirements\n// 2. Race conditions: Forgot to lock? Data corruption!\n// 3. Scalability: Lock contention limits parallelism\n// 4. Complexity: Difficult to reason about all interleavings\n</code></pre> <p>Fundamental Issue: Shared mutable state + concurrency = complexity and bugs.</p>"},{"location":"components/rt/explanation/message-passing/#the-message-passing-solution","title":"The Message Passing Solution","text":"<p>Actors eliminate shared mutable state by making message passing the sole communication mechanism:</p> <pre><code>// Message passing approach\nstruct Counter {\n    value: i32,  // Private state, no locks needed!\n}\n\nimpl Actor for Counter {}\n\n#[async_trait]\nimpl Handler&lt;Increment&gt; for Counter {\n    async fn handle(&amp;mut self, _msg: Increment, _ctx: &amp;mut ActorContext&lt;Self&gt;) {\n        self.value += 1;  // Safe! Sequential message processing\n        // No locks, no race conditions, no deadlocks\n    }\n}\n\n// Send message asynchronously\ncounter_ref.send(Increment).await?;\n</code></pre> <p>Benefits: - No locks: Actors process messages sequentially - No race conditions: Each actor owns its state exclusively - No deadlocks: Asynchronous message passing never blocks - Scalable: Independent actors run in parallel - Simple reasoning: Each actor is an isolated state machine</p> <p>Tradeoff: Message passing adds latency (~737ns) vs. shared memory (~nanoseconds), but eliminates concurrency complexity.</p>"},{"location":"components/rt/explanation/message-passing/#message-passing-semantics","title":"Message Passing Semantics","text":""},{"location":"components/rt/explanation/message-passing/#fire-and-forget-asynchronous-send","title":"Fire-and-Forget (Asynchronous Send)","text":"<p>Semantics: Send message and continue immediately without waiting for response.</p> <pre><code>// Sender continues without waiting\nactor_ref.send(DoWork { task_id: 1 }).await?;\nprintln!(\"Message sent!\");  // Executes before message is processed\n\n// Message delivered to mailbox\n// Actor processes when ready\n</code></pre> <p>Use Cases: - Logging and auditing (don't wait for log to be written) - Event notifications (fire events without blocking) - Background processing (queue work without waiting)</p> <p>Performance: Lowest latency (~181ns mailbox enqueue + ~400ns processing = ~600ns total)</p> <p>Guarantees: - \u2705 At-most-once delivery: Message delivered to mailbox or error returned - \u2705 Ordered within sender: Messages from same sender arrive in order - \u274c No delivery confirmation: Sender doesn't know if message was processed - \u274c No response: Sender cannot receive result</p>"},{"location":"components/rt/explanation/message-passing/#request-reply-synchronous-send","title":"Request-Reply (Synchronous Send)","text":"<p>Semantics: Send message and wait for response before continuing.</p> <pre><code>// Sender waits for response\nlet result: String = actor_ref.send(Query { id: 42 }).await?;\nprintln!(\"Got response: {}\", result);  // Waits for actor to respond\n</code></pre> <p>Use Cases: - Queries requiring responses (database lookups, calculations) - RPC-style interactions (client-server communication) - Synchronous workflows (need result before proceeding)</p> <p>Performance: Higher latency (~737ns roundtrip: send + receive + processing)</p> <p>Guarantees: - \u2705 Response guaranteed: Receive typed response or timeout error - \u2705 Type-safe: Response type matches <code>Message::Result</code> - \u2705 Timeout support: Prevent indefinite waiting - \u274c Blocks sender: Sender waits for response (can't do other work)</p>"},{"location":"components/rt/explanation/message-passing/#broadcast-pub-sub","title":"Broadcast (Pub-Sub)","text":"<p>Semantics: Send message to all subscribers of a topic.</p> <pre><code>// Publish event to all subscribers\nbroker.publish(\"user.login\", UserLoginEvent { user_id: 123 }).await?;\n\n// Multiple subscribers receive the event\nsubscriber_a.handle(UserLoginEvent { user_id: 123 });  // Analytics\nsubscriber_b.handle(UserLoginEvent { user_id: 123 });  // Audit log\nsubscriber_c.handle(UserLoginEvent { user_id: 123 });  // Notification service\n</code></pre> <p>Use Cases: - Event-driven architectures (domain events, notifications) - Multi-subscriber patterns (multiple services react to same event) - Decoupling (publishers don't know subscribers)</p> <p>Performance: Scales with subscriber count (~395ns per subscriber)</p> <p>Guarantees: - \u2705 All subscribers notified: Every active subscriber receives message - \u2705 Parallel delivery: Subscribers process independently - \u274c No delivery confirmation: Publisher doesn't know who received - \u274c No ordering between publishers: Messages from different publishers may interleave</p>"},{"location":"components/rt/explanation/message-passing/#message-routing-architecture","title":"Message Routing Architecture","text":"<p>AirsSys RT provides two message routing mechanisms:</p>"},{"location":"components/rt/explanation/message-passing/#direct-actor-references","title":"Direct Actor References","text":"<p>Mechanism: Send messages directly to actor via <code>ActorRef&lt;A&gt;</code>.</p> <pre><code>// Spawn actor, get direct reference\nlet actor_ref: ActorRef&lt;MyActor&gt; = system.spawn(MyActor::new()).await?;\n\n// Send message directly (no routing overhead)\nactor_ref.send(MyMessage).await?;\n</code></pre> <p>Performance: Fastest path (~737ns roundtrip, no routing overhead)</p> <p>Use Cases: - Parent-child communication (supervisor \u2192 children) - Request-reply patterns (client \u2192 server) - Known recipient (reference available at compile time)</p> <p>Tradeoffs: - \u2705 Fastest: No routing overhead - \u2705 Type-safe: Compiler ensures actor handles message type - \u274c Tight coupling: Sender must have reference to specific actor - \u274c No discovery: Cannot find actors dynamically</p>"},{"location":"components/rt/explanation/message-passing/#message-broker-pub-sub","title":"Message Broker (Pub-Sub)","text":"<p>Mechanism: Send messages through <code>MessageBroker</code> which routes to subscribers.</p> <pre><code>// Register actor with broker for topic\nbroker.subscribe(\"events.user\", user_analytics_ref).await?;\nbroker.subscribe(\"events.user\", user_audit_ref).await?;\n\n// Publish to topic (broker routes to all subscribers)\nbroker.publish(\"events.user\", UserEvent { user_id: 123 }).await?;\n// Both user_analytics_ref and user_audit_ref receive the event\n</code></pre> <p>Performance: Adds routing overhead (~180ns + ~395ns per subscriber)</p> <p>Use Cases: - Pub-sub patterns (one-to-many messaging) - Dynamic discovery (find actors by topic at runtime) - Decoupling (senders don't need specific actor references)</p> <p>Tradeoffs: - \u2705 Decoupling: Publisher doesn't know subscribers - \u2705 Dynamic: Subscribe/unsubscribe at runtime - \u2705 One-to-many: Single publish reaches multiple subscribers - \u274c Routing overhead: ~180ns per message - \u274c Topic management: Must agree on topic naming scheme</p>"},{"location":"components/rt/explanation/message-passing/#choosing-between-direct-and-broker","title":"Choosing Between Direct and Broker","text":"<p>Use Direct References When: - Communication is point-to-point (one sender, one receiver) - Actors are tightly coupled (parent-child, client-server) - Performance critical (hot path, high-frequency messaging) - Type safety important (compiler enforces handler exists)</p> <p>Use Message Broker When: - Communication is one-to-many (pub-sub, events) - Actors are loosely coupled (decoupled services) - Dynamic discovery needed (find actors at runtime) - Flexibility more important than performance</p> <p>Hybrid Approach: <pre><code>// Use direct references for hot path\nlet worker_ref = system.spawn(Worker::new()).await?;\nworker_ref.send(HighFrequencyRequest).await?;  // Fast path\n\n// Use broker for events\nbroker.publish(\"worker.completed\", WorkCompleted { id: 1 }).await?;  // Decoupled\n</code></pre></p>"},{"location":"components/rt/explanation/message-passing/#design-decisions","title":"Design Decisions","text":""},{"location":"components/rt/explanation/message-passing/#decision-typed-messages-with-associated-result","title":"Decision: Typed Messages with Associated Result","text":"<p>Context: Messages must specify their response type for request-reply.</p> <p>Choice: Use associated type <code>Message::Result</code> for type-safe responses.</p> <pre><code>#[derive(Clone)]\nstruct Query {\n    id: u64,\n}\n\nimpl Message for Query {\n    type Result = String;  // Response type\n}\n\n#[async_trait]\nimpl Handler&lt;Query&gt; for MyActor {\n    async fn handle(&amp;mut self, msg: Query, _ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; String {\n        format!(\"Result for {}\", msg.id)  // Must return String\n    }\n}\n</code></pre> <p>Rationale: - Compile-time type checking (response type must match) - Self-documenting (message definition includes response type) - No runtime type errors (impossible to return wrong type)</p> <p>Tradeoff: More verbose (must define <code>Message::Result</code>) vs. Type safety.</p>"},{"location":"components/rt/explanation/message-passing/#decision-asynchronous-send-with-asyncawait","title":"Decision: Asynchronous Send with <code>async/await</code>","text":"<p>Context: Message sending could be blocking or asynchronous.</p> <p>Choice: All message sends are <code>async</code> and use <code>await</code>.</p> <pre><code>// All sends are async\nactor_ref.send(msg).await?;\n</code></pre> <p>Rationale: - Non-blocking: Sender can do other work while message is in flight - Integrates with Tokio: Natural fit with async ecosystem - Backpressure support: Bounded mailbox can apply backpressure</p> <p>Tradeoff: <code>async/await</code> syntax overhead vs. Non-blocking concurrency.</p>"},{"location":"components/rt/explanation/message-passing/#decision-mailbox-as-message-buffer","title":"Decision: Mailbox as Message Buffer","text":"<p>Context: Messages need temporary storage between send and receive.</p> <p>Choice: Each actor has a mailbox (queue) for pending messages.</p> <pre><code>pub enum Mailbox&lt;A&gt; {\n    Bounded(BoundedMailbox&lt;A&gt;),    // Fixed capacity, backpressure\n    Unbounded(UnboundedMailbox&lt;A&gt;), // Unlimited capacity\n}\n</code></pre> <p>Rationale: - Decoupling: Sender doesn't block waiting for receiver - Buffering: Absorbs traffic bursts - Backpressure: Bounded mailbox prevents memory exhaustion</p> <p>Tradeoff: Memory overhead (mailbox storage) vs. Asynchronous messaging.</p>"},{"location":"components/rt/explanation/message-passing/#decision-fifo-message-order","title":"Decision: FIFO Message Order","text":"<p>Context: Messages could be processed in FIFO, LIFO, or priority order.</p> <p>Choice: Strictly FIFO (first-in-first-out) message processing.</p> <p>Rationale: - Predictable: Messages processed in send order - Fair: No message starvation - Simple: Easy to reason about</p> <p>Tradeoff: No priority support vs. Simplicity and predictability.</p>"},{"location":"components/rt/explanation/message-passing/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"components/rt/explanation/message-passing/#latency-breakdown-october-2025-baseline","title":"Latency Breakdown (October 2025 Baseline)","text":"<p>Point-to-Point Messaging:</p> Operation Latency (P50) Components Direct Send 737ns Enqueue (181ns) + Processing (400ns) + Response (156ns) Via Broker 917ns Routing (180ns) + Direct Send (737ns) <p>Broadcast Messaging:</p> Subscribers Latency (P50) Per-Subscriber 1 subscriber 395ns 395ns 10 subscribers 3.95\u00b5s 395ns 100 subscribers 39.5\u00b5s 395ns <p>Scaling: Linear with subscriber count (expected for independent delivery).</p>"},{"location":"components/rt/explanation/message-passing/#throughput-capacity","title":"Throughput Capacity","text":"<p>Theoretical Limits:</p> Pattern Throughput Calculation Direct Point-to-Point 1.36M msgs/sec 1 / 737ns Via Broker (1:1) 1.09M msgs/sec 1 / 917ns Broadcast (1:10) 253K events/sec 1 / 3.95\u00b5s <p>Real-World Capacity (Conservative):</p> <ul> <li>Direct messaging: ~1M msgs/sec (accounting for processing overhead)</li> <li>Broker routing: ~800K msgs/sec (with routing overhead)</li> <li>Broadcast events: ~200K events/sec (10 subscribers)</li> </ul> <p>Bottlenecks: - Mailbox contention (multiple senders to one actor) - Message processing time (handler complexity) - Memory allocation (large message payloads)</p>"},{"location":"components/rt/explanation/message-passing/#memory-overhead","title":"Memory Overhead","text":"<p>Per-Message Overhead:</p> <pre><code>struct MessageEnvelope&lt;M&gt; {\n    message: M,              // Message size\n    reply_channel: Option&lt;...&gt;, // 24 bytes (if request-reply)\n}\n</code></pre> <p>Total: Message size + 24 bytes (request-reply) or 0 bytes (fire-and-forget)</p> <p>Mailbox Memory:</p> <ul> <li>Bounded: <code>capacity * (message_size + envelope)</code> bytes</li> <li>Unbounded: <code>current_queue_depth * (message_size + envelope)</code> bytes</li> </ul> <p>Optimization: Use <code>Arc&lt;T&gt;</code> for large messages to share data instead of copying.</p>"},{"location":"components/rt/explanation/message-passing/#comparison-with-alternatives","title":"Comparison with Alternatives","text":""},{"location":"components/rt/explanation/message-passing/#message-passing-vs-channels","title":"Message Passing vs. Channels","text":"<p>Rust Channels (mpsc, broadcast):</p> <pre><code>// Channel-based communication\nlet (tx, rx) = tokio::sync::mpsc::channel(100);\n\ntokio::spawn(async move {\n    tx.send(42).await.unwrap();\n});\n\nlet value = rx.recv().await.unwrap();\n</code></pre> <p>Pros: - Lightweight (no actor framework) - Simple producer-consumer pattern - Built into Tokio</p> <p>Cons: - No state encapsulation (just pipes) - No supervision or fault tolerance - Manual lifecycle management</p> <p>When to Use: Simple pipelines, stream processing, basic producer-consumer.</p> <p>Actor Message Passing:</p> <p>Pros: - Encapsulates state with behavior - Built-in supervision and fault tolerance - Typed message handlers</p> <p>Cons: - Requires actor framework - More abstraction overhead</p> <p>When to Use: Stateful services, fault-tolerant systems, entity-oriented design.</p>"},{"location":"components/rt/explanation/message-passing/#message-passing-vs-rpc","title":"Message Passing vs. RPC","text":"<p>Remote Procedure Call (gRPC, JSON-RPC):</p> <pre><code>// RPC-style call\nlet response = client.call_remote(\"service.method\", params).await?;\n</code></pre> <p>Pros: - Familiar (like local function calls) - Language-agnostic (network protocols) - Tooling (code generation, service definitions)</p> <p>Cons: - Synchronous (blocks waiting for response) - Network overhead (serialization, latency) - Tight coupling (client must know service API)</p> <p>When to Use: Cross-language communication, network services, REST APIs.</p> <p>Actor Message Passing:</p> <p>Pros: - Asynchronous by default (non-blocking) - Local optimization (no serialization overhead) - Type-safe (compile-time checking)</p> <p>Cons: - Local only (not distributed by default) - Requires actor framework</p> <p>When to Use: Local concurrency, high-performance messaging, type-safe APIs.</p>"},{"location":"components/rt/explanation/message-passing/#message-passing-patterns","title":"Message Passing Patterns","text":""},{"location":"components/rt/explanation/message-passing/#pattern-1-request-reply","title":"Pattern 1: Request-Reply","text":"<pre><code>// Client sends query, waits for response\nlet result: Data = data_actor.send(GetData { id: 123 }).await?;\nprintln!(\"Received: {:?}\", result);\n</code></pre> <p>Use Case: Synchronous workflows, queries, RPC-style calls.</p>"},{"location":"components/rt/explanation/message-passing/#pattern-2-fire-and-forget","title":"Pattern 2: Fire-and-Forget","text":"<pre><code>// Client sends notification, continues immediately\nlogger.send(LogEvent { message: \"User logged in\" }).await?;\n// Don't wait for log to be written\n</code></pre> <p>Use Case: Logging, auditing, background processing.</p>"},{"location":"components/rt/explanation/message-passing/#pattern-3-pub-sub","title":"Pattern 3: Pub-Sub","text":"<pre><code>// Multiple subscribers react to event\nbroker.publish(\"order.created\", OrderCreated { order_id: 456 }).await?;\n// Analytics, inventory, shipping all receive event\n</code></pre> <p>Use Case: Event-driven architectures, decoupled services.</p>"},{"location":"components/rt/explanation/message-passing/#pattern-4-request-multicast","title":"Pattern 4: Request-Multicast","text":"<pre><code>// Send request to multiple actors, collect responses\nlet futures: Vec&lt;_&gt; = actors.iter()\n    .map(|actor| actor.send(Query { id }))\n    .collect();\nlet results = futures::future::join_all(futures).await;\n</code></pre> <p>Use Case: Scatter-gather, parallel queries, map-reduce.</p>"},{"location":"components/rt/explanation/message-passing/#pattern-5-pipeline","title":"Pattern 5: Pipeline","text":"<pre><code>// Chain actors in processing pipeline\nreader_ref.send(ReadData).await?;\n// Reader sends to Processor\n// Processor sends to Writer\n// Writer completes pipeline\n</code></pre> <p>Use Case: ETL pipelines, stream processing, multi-stage workflows.</p>"},{"location":"components/rt/explanation/message-passing/#best-practices","title":"Best Practices","text":""},{"location":"components/rt/explanation/message-passing/#1-choose-appropriate-messaging-pattern","title":"1. Choose Appropriate Messaging Pattern","text":"<ul> <li>Known recipient + need response: Request-Reply (direct reference)</li> <li>Known recipient + no response needed: Fire-and-Forget (direct reference)</li> <li>Multiple recipients: Pub-Sub (message broker)</li> <li>Unknown recipient: Discovery via broker, then direct reference</li> </ul>"},{"location":"components/rt/explanation/message-passing/#2-optimize-hot-paths","title":"2. Optimize Hot Paths","text":"<pre><code>// Hot path: Use direct reference\nlet worker_ref = get_worker().await?;\nfor i in 0..1_000_000 {\n    worker_ref.send(HighFrequency { data: i }).await?;  // Fast!\n}\n\n// Cold path: Use broker\nbroker.publish(\"worker.stats\", WorkerStats { ... }).await?;  // Infrequent\n</code></pre>"},{"location":"components/rt/explanation/message-passing/#3-use-arc-for-large-messages","title":"3. Use Arc for Large Messages","text":"<pre><code>// \u274c Bad: Copy large data for each message\n#[derive(Clone)]\nstruct LargeMessage {\n    data: Vec&lt;u8&gt;,  // Copied on every send!\n}\n\n// \u2705 Good: Share data via Arc\nuse std::sync::Arc;\n\n#[derive(Clone)]\nstruct EfficientMessage {\n    data: Arc&lt;Vec&lt;u8&gt;&gt;,  // Cheap clone, shared data\n}\n</code></pre>"},{"location":"components/rt/explanation/message-passing/#4-monitor-mailbox-queue-depth","title":"4. Monitor Mailbox Queue Depth","text":"<pre><code>// Detect mailbox backlog\nif ctx.mailbox_size() &gt; 1000 {\n    log::warn!(\"Mailbox backlog: {} messages\", ctx.mailbox_size());\n    // Consider scaling out (more workers)\n}\n</code></pre>"},{"location":"components/rt/explanation/message-passing/#further-reading","title":"Further Reading","text":""},{"location":"components/rt/explanation/message-passing/#airssys-rt-documentation","title":"AirsSys RT Documentation","text":"<ul> <li>Messaging API Reference</li> <li>Message Broker Reference</li> <li>Performance Reference</li> </ul>"},{"location":"components/rt/explanation/message-passing/#external-resources","title":"External Resources","text":"<ul> <li>Erlang Message Passing: Official Erlang documentation</li> <li>Akka Messaging: Akka framework message passing guide</li> <li>CSP vs. Actors: Comparing communicating sequential processes with actors</li> </ul> <p>Last Updated: 2025-01-18 (RT-TASK-011 Phase 4 Day 7)</p>"},{"location":"components/rt/explanation/performance-design/","title":"Understanding Performance Design","text":"<p>This document explains the performance philosophy behind AirsSys RT, design decisions that impact performance, and how to reason about actor system scalability.</p>"},{"location":"components/rt/explanation/performance-design/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Performance Philosophy</li> <li>Zero-Cost Abstractions</li> <li>Performance by Design</li> <li>Scalability Characteristics</li> <li>Performance Tradeoffs</li> <li>When Performance Matters</li> </ul>"},{"location":"components/rt/explanation/performance-design/#performance-philosophy","title":"Performance Philosophy","text":""},{"location":"components/rt/explanation/performance-design/#guiding-principles","title":"Guiding Principles","text":"<p>1. \"Fast Enough\" is Not Enough</p> <p>Philosophy: AirsSys RT aims for predictable, measurable performance with clear baselines and characteristics.</p> <p>Why: \"Fast enough\" is subjective and changes with scale. Concrete baselines enable capacity planning and performance regression detection.</p> <p>Approach: - Establish baseline measurements (actor spawn: 624ns, messaging: 737ns) - Document scaling characteristics (linear O(n), sub-linear, super-linear) - Provide performance reference for capacity planning</p> <p>2. Zero-Cost Abstractions (Rust Philosophy)</p> <p>Philosophy: Abstractions should not cost performance. Pay only for what you use.</p> <p>Why: Actor model provides high-level abstractions (message passing, supervision). These must not impose prohibitive overhead.</p> <p>Approach: - Generic traits compile to concrete types (no virtual dispatch) - Inline hot paths (message handling, mailbox operations) - Benchmark abstractions against hand-coded alternatives</p> <p>3. Performance is a Feature</p> <p>Philosophy: Performance is not an afterthought - it's designed into the architecture from the start.</p> <p>Why: Retrofitting performance into a slow system is harder than building it in from day one.</p> <p>Approach: - Benchmarks from RT-TASK-008 (baseline measurement) - Performance regression detection in CI (future) - Documentation of performance characteristics</p>"},{"location":"components/rt/explanation/performance-design/#zero-cost-abstractions","title":"Zero-Cost Abstractions","text":""},{"location":"components/rt/explanation/performance-design/#what-are-zero-cost-abstractions","title":"What are Zero-Cost Abstractions?","text":"<p>Definition: High-level abstractions that compile down to the same code a programmer would write by hand.</p> <p>Rust's Promise: \"What you don't use, you don't pay for. What you do use, you couldn't hand code any better.\"</p>"},{"location":"components/rt/explanation/performance-design/#example-generic-message-handlers","title":"Example: Generic Message Handlers","text":"<p>High-Level Code (What You Write):</p> <pre><code>#[async_trait]\nimpl Handler&lt;MyMessage&gt; for MyActor {\n    async fn handle(&amp;mut self, msg: MyMessage, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; String {\n        format!(\"Processed: {:?}\", msg)\n    }\n}\n</code></pre> <p>Compiled Code (What Runs):</p> <pre><code>// Compiler monomorphizes generics into concrete types\nimpl MyActor {\n    async fn handle_MyMessage(&amp;mut self, msg: MyMessage, ctx: &amp;mut ActorContext&lt;MyActor&gt;) -&gt; String {\n        format!(\"Processed: {:?}\", msg)\n    }\n}\n\n// Direct function call (no virtual dispatch, no runtime overhead)\nactor.handle_MyMessage(msg, ctx).await\n</code></pre> <p>Cost: Zero runtime overhead compared to writing the concrete function directly.</p> <p>Benefit: Type-safe, generic API without performance penalty.</p>"},{"location":"components/rt/explanation/performance-design/#example-mailbox-abstraction","title":"Example: Mailbox Abstraction","text":"<p>High-Level API:</p> <pre><code>// User-friendly API\nlet mailbox = Mailbox::bounded(100);\nmailbox.enqueue(msg).await?;\nlet msg = mailbox.dequeue().await?;\n</code></pre> <p>Implementation (Under the Hood):</p> <pre><code>// Compiles to efficient tokio::sync::mpsc\nstruct BoundedMailbox&lt;M&gt; {\n    tx: mpsc::Sender&lt;MessageEnvelope&lt;M&gt;&gt;,  // Tokio channel\n    rx: mpsc::Receiver&lt;MessageEnvelope&lt;M&gt;&gt;,\n}\n\n// Zero abstraction overhead - direct channel operations\n</code></pre> <p>Cost: 181ns enqueue, 150ns dequeue (same as raw tokio::mpsc)</p> <p>Benefit: Ergonomic API without sacrificing performance.</p>"},{"location":"components/rt/explanation/performance-design/#performance-by-design","title":"Performance by Design","text":""},{"location":"components/rt/explanation/performance-design/#design-decision-lightweight-actor-spawn","title":"Design Decision: Lightweight Actor Spawn","text":"<p>Goal: Enable millions of actors without excessive memory overhead.</p> <p>Design:</p> <pre><code>// Minimal actor footprint\nstruct ActorRuntime&lt;A&gt; {\n    actor: A,               // User's actor struct\n    mailbox: Mailbox&lt;A&gt;,    // Message queue\n    context: ActorContext&lt;A&gt;, // Lifecycle management\n}\n</code></pre> <p>Memory Footprint: ~1KB per actor (struct size + mailbox buffer)</p> <p>Spawn Performance: - Single spawn: 624.74ns (P50) - Batch spawn (10 actors): 681.40ns per actor (P50)</p> <p>Capacity: 1.6M actors/second spawn rate</p> <p>Rationale: Lightweight actors enable actor-per-entity patterns (one actor per user session, device, game entity).</p>"},{"location":"components/rt/explanation/performance-design/#design-decision-direct-mailbox-access","title":"Design Decision: Direct Mailbox Access","text":"<p>Goal: Minimize message latency for high-frequency messaging.</p> <p>Design:</p> <pre><code>// Direct enqueue without routing overhead\nimpl&lt;A: Actor&gt; ActorRef&lt;A&gt; {\n    pub async fn send&lt;M&gt;(&amp;self, msg: M) -&gt; Result&lt;M::Result, SendError&gt;\n    where\n        A: Handler&lt;M&gt;,\n        M: Message,\n    {\n        self.mailbox.enqueue(msg).await?;  // Direct access, no indirection\n    }\n}\n</code></pre> <p>Performance: 737ns roundtrip (enqueue + process + reply)</p> <p>Rationale: Hot paths (request-reply within service) benefit from direct access. Message broker reserved for pub-sub.</p>"},{"location":"components/rt/explanation/performance-design/#design-decision-bounded-and-unbounded-mailboxes","title":"Design Decision: Bounded and Unbounded Mailboxes","text":"<p>Goal: Support both high-throughput (unbounded) and backpressure (bounded) use cases.</p> <p>Design:</p> <pre><code>pub enum Mailbox&lt;A&gt; {\n    Bounded(BoundedMailbox&lt;A&gt;),    // Fixed capacity, backpressure\n    Unbounded(UnboundedMailbox&lt;A&gt;), // Unlimited capacity\n}\n</code></pre> <p>Performance:</p> Mailbox Type Enqueue Dequeue Memory Bounded 181ns 150ns <code>capacity * msg_size</code> Unbounded 181ns 150ns <code>queue_depth * msg_size</code> <p>Tradeoff: - Bounded: Prevents memory exhaustion, applies backpressure (may block sender) - Unbounded: Never blocks sender, but may exhaust memory</p> <p>Guideline: Use bounded for production, unbounded for development/testing.</p>"},{"location":"components/rt/explanation/performance-design/#design-decision-inline-message-processing","title":"Design Decision: Inline Message Processing","text":"<p>Goal: Minimize virtual dispatch overhead in message handling hot path.</p> <p>Design:</p> <pre><code>// Generic trait compiles to concrete implementations (monomorphization)\n#[async_trait]\npub trait Handler&lt;M: Message&gt;: Actor {\n    async fn handle(&amp;mut self, msg: M, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; M::Result;\n}\n\n// Compiler generates:\nimpl MyActor {\n    #[inline]  // Inlined for zero overhead\n    async fn handle_MyMessage(&amp;mut self, msg: MyMessage, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; String {\n        // User implementation\n    }\n}\n</code></pre> <p>Performance: 31.55ns per message processing (after dequeue, before enqueue reply)</p> <p>Rationale: Inlining eliminates function call overhead. Generic monomorphization enables compiler optimizations.</p>"},{"location":"components/rt/explanation/performance-design/#scalability-characteristics","title":"Scalability Characteristics","text":""},{"location":"components/rt/explanation/performance-design/#linear-scaling-on","title":"Linear Scaling (O(n))","text":"<p>Characteristic: Performance scales linearly with number of actors.</p> <p>Evidence:</p> Actors Total Spawn Time Per-Actor Cost 1 624ns 624ns 10 6.81\u00b5s 681ns 100 68.1\u00b5s 681ns 1,000 681\u00b5s 681ns <p>Slope: ~681ns per actor (constant)</p> <p>Implication: Doubling actors doubles total time, but per-actor cost remains constant.</p> <p>Why Linear: - Independent actor spawning (no shared locks) - Per-actor mailboxes (no contention) - Isolated state (no synchronization overhead)</p>"},{"location":"components/rt/explanation/performance-design/#message-broker-overhead","title":"Message Broker Overhead","text":"<p>Characteristic: Broker routing adds constant overhead per message.</p> <p>Measurement:</p> Path Latency Overhead Direct (no broker) 737ns Baseline Via Broker 917ns +180ns <p>Overhead Factor: 6.7x slower than direct messaging</p> <p>Implication: Broker suitable for infrequent messaging (pub-sub, discovery), not hot paths.</p> <p>Why Constant: - Hash map lookup for topic \u2192 subscribers (O(1)) - Fixed routing logic (no dynamic dispatch) - Parallel delivery to subscribers</p>"},{"location":"components/rt/explanation/performance-design/#broadcast-scaling","title":"Broadcast Scaling","text":"<p>Characteristic: Broadcast latency scales linearly with subscriber count.</p> <p>Measurement:</p> Subscribers Total Latency Per-Subscriber 1 395ns 395ns 10 3.95\u00b5s 395ns 100 39.5\u00b5s 395ns <p>Slope: 395ns per subscriber (constant)</p> <p>Implication: Each subscriber adds fixed cost. 1,000 subscribers = ~400\u00b5s total.</p> <p>Why Linear: - Independent message delivery (parallel sends) - No synchronization between subscribers - Each subscriber has own mailbox</p>"},{"location":"components/rt/explanation/performance-design/#supervision-overhead","title":"Supervision Overhead","text":"<p>Characteristic: Supervision adds constant overhead per child operation.</p> <p>Measurement:</p> Operation Without Supervisor With Supervisor Overhead Spawn Actor 624ns 1.28\u00b5s +656ns (105%) Restart Actor - 1.28\u00b5s - <p>Overhead Factor: ~2x slower with supervision</p> <p>Implication: Supervision worthwhile for fault tolerance, but not free.</p> <p>Why Constant: - Fixed supervisor bookkeeping (child registration) - One-time restart policy evaluation - No scaling with child count (per-child overhead)</p>"},{"location":"components/rt/explanation/performance-design/#performance-tradeoffs","title":"Performance Tradeoffs","text":""},{"location":"components/rt/explanation/performance-design/#tradeoff-1-type-safety-vs-runtime-flexibility","title":"Tradeoff 1: Type Safety vs. Runtime Flexibility","text":"<p>Type-Safe Approach (AirsSys RT):</p> <pre><code>// Compiler ensures MyActor implements Handler&lt;MyMessage&gt;\nimpl Handler&lt;MyMessage&gt; for MyActor { ... }\n\n// Compile-time error if not implemented\nactor_ref.send(MyMessage).await?;  // Type-checked!\n</code></pre> <p>Pros: - Catch errors at compile time - Zero runtime type checking overhead - Self-documenting (handler existence proven by types)</p> <p>Cons: - Cannot send arbitrary messages at runtime - Requires implementing trait for each message type</p> <p>Dynamic Approach (Erlang, Akka):</p> <pre><code>% Erlang: Send any message to any actor (runtime checked)\nActor ! {my_message, Data}.\n</code></pre> <p>Pros: - Maximum flexibility (send any message anytime) - Rapid prototyping (no trait implementations)</p> <p>Cons: - Runtime errors (message not handled crashes actor) - No compile-time verification - Runtime type matching overhead</p> <p>AirsSys RT Choice: Prioritize type safety and compile-time guarantees over runtime flexibility.</p>"},{"location":"components/rt/explanation/performance-design/#tradeoff-2-message-passing-vs-shared-memory","title":"Tradeoff 2: Message Passing vs. Shared Memory","text":"<p>Message Passing:</p> <pre><code>// Actor approach: Copy message to mailbox\nactor_ref.send(LargeData { vec: large_vec }).await?;\n// Message copied to mailbox (memory overhead)\n</code></pre> <p>Pros: - Isolation (no data races) - Type-safe (compiler-checked message types) - Location transparent (can be made distributed)</p> <p>Cons: - Memory copying overhead (message size dependent) - Latency overhead (~737ns per message)</p> <p>Shared Memory:</p> <pre><code>// Shared memory: Reference shared data\nlet data = Arc::new(Mutex::new(large_vec));\nlet data_clone = data.clone();  // Cheap Arc clone\n// No copying, just reference counting\n</code></pre> <p>Pros: - No memory copying (shared reference) - Minimal overhead (Arc increment/decrement)</p> <p>Cons: - Potential data races (if locking incorrect) - Deadlock risk (complex lock orderings) - Not location transparent (cannot distribute)</p> <p>AirsSys RT Choice: Message passing by default, but users can use <code>Arc&lt;T&gt;</code> for large shared data:</p> <pre><code>// Hybrid: Message passing with shared data\n#[derive(Clone)]\nstruct EfficientMessage {\n    data: Arc&lt;Vec&lt;u8&gt;&gt;,  // Shared via Arc, cheap clone\n}\n</code></pre>"},{"location":"components/rt/explanation/performance-design/#tradeoff-3-bounded-vs-unbounded-mailboxes","title":"Tradeoff 3: Bounded vs. Unbounded Mailboxes","text":"<p>Bounded Mailbox:</p> <pre><code>let mailbox = Mailbox::bounded(100);  // Max 100 messages\n</code></pre> <p>Pros: - Prevents memory exhaustion (finite memory use) - Applies backpressure (slows down fast producers) - Predictable memory footprint</p> <p>Cons: - May block senders (if mailbox full) - May drop messages (if Drop strategy) - Requires capacity tuning</p> <p>Unbounded Mailbox:</p> <pre><code>let mailbox = Mailbox::unbounded();  // No limit\n</code></pre> <p>Pros: - Never blocks senders (always accepts messages) - Simple (no capacity configuration) - Matches Erlang semantics</p> <p>Cons: - Risk of memory exhaustion (queue grows unbounded) - No backpressure (fast producer can overwhelm slow consumer) - Unpredictable memory use</p> <p>AirsSys RT Choice: Provide both, recommend bounded for production with appropriate capacity.</p>"},{"location":"components/rt/explanation/performance-design/#when-performance-matters","title":"When Performance Matters","text":""},{"location":"components/rt/explanation/performance-design/#high-frequency-messaging","title":"High-Frequency Messaging","text":"<p>Scenario: Actors exchange messages at &gt;100K msgs/sec.</p> <p>Optimization:</p> <pre><code>// Use direct references (avoid broker overhead)\nlet worker_ref = system.spawn(Worker::new()).await?;\n\nfor i in 0..100_000 {\n    worker_ref.send(HighFrequency { data: i }).await?;  // Direct path\n}\n</code></pre> <p>Avoid: Routing through message broker (+180ns per message)</p> <p>Expected: ~1M msgs/sec throughput via direct references</p>"},{"location":"components/rt/explanation/performance-design/#large-scale-actor-systems","title":"Large-Scale Actor Systems","text":"<p>Scenario: System with millions of concurrent actors.</p> <p>Optimization:</p> <pre><code>// Batch actor spawning\nlet actors: Vec&lt;_&gt; = (0..1_000_000)\n    .map(|i| system.spawn(Worker::new()))\n    .collect();\nfutures::future::join_all(actors).await;\n\n// Expected: 1.6M actors/sec spawn rate\n</code></pre> <p>Memory Planning: 1M actors \u00d7 1KB = ~1GB minimum</p> <p>Avoid: Spawning actors synchronously in loop (slower)</p>"},{"location":"components/rt/explanation/performance-design/#low-latency-request-reply","title":"Low-Latency Request-Reply","text":"<p>Scenario: Client requires &lt;1ms response time.</p> <p>Optimization:</p> <pre><code>// Minimize message processing time\n#[async_trait]\nimpl Handler&lt;Query&gt; for FastActor {\n    async fn handle(&amp;mut self, msg: Query, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; Data {\n        // Keep handler simple and fast\n        self.cache.get(&amp;msg.id).cloned().unwrap_or_default()\n        // Avoid: External I/O, complex computation, blocking operations\n    }\n}\n</code></pre> <p>Expected: 737ns messaging + handler time</p> <p>Avoid: Blocking operations in handler (use <code>spawn_blocking</code>)</p>"},{"location":"components/rt/explanation/performance-design/#pub-sub-with-many-subscribers","title":"Pub-Sub with Many Subscribers","text":"<p>Scenario: Broadcasting events to 100+ subscribers.</p> <p>Optimization:</p> <pre><code>// Consider batching events to reduce broadcast frequency\nlet mut batch = Vec::new();\nfor event in events {\n    batch.push(event);\n    if batch.len() &gt;= 100 {\n        broker.publish(\"topic\", EventBatch { events: batch.clone() }).await?;\n        batch.clear();\n    }\n}\n</code></pre> <p>Expected: 395ns \u00d7 100 subscribers = ~40\u00b5s per broadcast</p> <p>Avoid: Individual events if batch semantics acceptable</p>"},{"location":"components/rt/explanation/performance-design/#performance-monitoring","title":"Performance Monitoring","text":""},{"location":"components/rt/explanation/performance-design/#metrics-to-track","title":"Metrics to Track","text":"<p>1. Message Latency (P50, P95, P99)</p> <pre><code>// Measure end-to-end message latency\nlet start = Instant::now();\nlet result = actor_ref.send(msg).await?;\nlet latency = start.elapsed();\n\n// Compare against baseline: 737ns for simple messages\nif latency &gt; Duration::from_micros(10) {\n    log::warn!(\"High latency: {:?}\", latency);\n}\n</code></pre> <p>2. Mailbox Queue Depth</p> <pre><code>// Monitor mailbox backlog\nlet queue_depth = ctx.mailbox_size();\n\nif queue_depth &gt; 1000 {\n    log::warn!(\"Mailbox backlog: {} messages\", queue_depth);\n    // Consider: Add more workers, increase capacity, apply backpressure\n}\n</code></pre> <p>3. Actor Spawn Rate</p> <pre><code>// Track actor creation throughput\nlet start = Instant::now();\nlet actors: Vec&lt;_&gt; = (0..1000)\n    .map(|_| system.spawn(Worker::new()))\n    .collect();\nfutures::future::join_all(actors).await;\nlet elapsed = start.elapsed();\nlet rate = 1000.0 / elapsed.as_secs_f64();\n\n// Expected: ~1.6M actors/sec\nif rate &lt; 1_000_000.0 {\n    log::warn!(\"Low spawn rate: {:.0} actors/sec\", rate);\n}\n</code></pre> <p>4. Supervisor Restart Rate</p> <pre><code>// Monitor fault tolerance overhead\n// High restart rate may indicate:\n// - Buggy actors (frequent crashes)\n// - Configuration issues (max_restarts too high)\n// - System overload (resource exhaustion)\n</code></pre>"},{"location":"components/rt/explanation/performance-design/#benchmarking-workflow","title":"Benchmarking Workflow","text":"<p>1. Establish Baseline:</p> <pre><code># Run benchmarks to establish baseline\ncargo bench --bench actor_benchmarks\ncargo bench --bench message_benchmarks\n</code></pre> <p>2. Compare Against Baseline:</p> <pre><code>// In your application\nassert!(latency &lt; BASELINE_LATENCY * 2.0, \"Performance regression detected\");\n</code></pre> <p>3. Profile Hot Paths:</p> <pre><code># CPU profiling\ncargo flamegraph --bin my_app\n\n# Memory profiling\nheaptrack target/release/my_app\n</code></pre>"},{"location":"components/rt/explanation/performance-design/#design-guidelines-for-performance","title":"Design Guidelines for Performance","text":""},{"location":"components/rt/explanation/performance-design/#1-design-for-hot-and-cold-paths","title":"1. Design for Hot and Cold Paths","text":"<p>Hot Path (High-Frequency): - Use direct actor references - Minimize message size (use Arc for large data) - Keep handlers simple and fast - Avoid broker overhead</p> <p>Cold Path (Infrequent): - Message broker acceptable - Pub-sub for events - Complex processing ok - External I/O acceptable</p>"},{"location":"components/rt/explanation/performance-design/#2-size-mailboxes-appropriately","title":"2. Size Mailboxes Appropriately","text":"<p>Formula:</p> <pre><code>mailbox_capacity = peak_msg_rate \u00d7 burst_duration\n\nExample:\n- Peak rate: 1,000 msgs/sec\n- Burst duration: 5 seconds\n- Capacity: 1,000 \u00d7 5 = 5,000 messages\n</code></pre>"},{"location":"components/rt/explanation/performance-design/#3-use-batching-when-appropriate","title":"3. Use Batching When Appropriate","text":"<p>Instead of: <pre><code>for event in events {\n    broker.publish(\"topic\", event).await?;  // N broadcasts\n}\n</code></pre></p> <p>Prefer: <pre><code>broker.publish(\"topic\", EventBatch { events }).await?;  // 1 broadcast\n</code></pre></p> <p>Tradeoff: Latency (batching delays) vs. Throughput (fewer broadcasts)</p>"},{"location":"components/rt/explanation/performance-design/#4-profile-before-optimizing","title":"4. Profile Before Optimizing","text":"<p>Measure, don't guess:</p> <pre><code>// Add timing to suspected hot paths\nlet start = Instant::now();\n// ... suspected slow code ...\nlet elapsed = start.elapsed();\nif elapsed &gt; Duration::from_millis(1) {\n    log::warn!(\"Slow operation: {:?}\", elapsed);\n}\n</code></pre> <p>Use profiling tools: - <code>cargo flamegraph</code> for CPU profiling - <code>heaptrack</code> for memory profiling - <code>criterion</code> for micro-benchmarking</p>"},{"location":"components/rt/explanation/performance-design/#further-reading","title":"Further Reading","text":""},{"location":"components/rt/explanation/performance-design/#airssys-rt-documentation","title":"AirsSys RT Documentation","text":"<ul> <li>Performance Reference - Detailed baseline metrics</li> <li>BENCHMARKING.md - Complete benchmark suite</li> <li>API Reference - Performance characteristics</li> </ul>"},{"location":"components/rt/explanation/performance-design/#external-resources","title":"External Resources","text":"<ul> <li>Zero-Cost Abstractions in Rust: Rust language philosophy</li> <li>Performance Matters (Emery Berger): Academic perspective on performance</li> <li>The Art of Performance Engineering: Systematic performance optimization</li> </ul> <p>Last Updated: 2025-01-18 (RT-TASK-011 Phase 4 Day 7)</p>"},{"location":"components/rt/explanation/supervision/","title":"Understanding Supervision","text":"<p>This document explains the supervision model in AirsSys RT, its design philosophy, how it achieves fault tolerance, and the reasoning behind different restart strategies.</p>"},{"location":"components/rt/explanation/supervision/#table-of-contents","title":"Table of Contents","text":"<ul> <li>What is Supervision?</li> <li>The \"Let it Crash\" Philosophy</li> <li>Supervision Tree Architecture</li> <li>Restart Strategies Explained</li> <li>Design Decisions and Rationale</li> <li>Comparison with Alternative Approaches</li> <li>When to Use Each Strategy</li> </ul>"},{"location":"components/rt/explanation/supervision/#what-is-supervision","title":"What is Supervision?","text":"<p>Supervision is a fault tolerance pattern where a \"supervisor\" actor monitors \"child\" actors and automatically restarts them when they fail. This creates a hierarchical structure of fault tolerance called a supervision tree.</p>"},{"location":"components/rt/explanation/supervision/#the-supervision-relationship","title":"The Supervision Relationship","text":"<pre><code>Supervisor (Parent)\n\u251c\u2500\u2500 Child A (Worker)\n\u251c\u2500\u2500 Child B (Worker)\n\u2514\u2500\u2500 Child C (Supervisor)\n    \u251c\u2500\u2500 Child C.1 (Worker)\n    \u2514\u2500\u2500 Child C.2 (Worker)\n</code></pre> <p>Key Responsibilities:</p> <p>Supervisor: - Starts child actors during initialization - Monitors child actors for failures - Decides how to handle failures (restart, stop, escalate) - Cleans up resources when children terminate</p> <p>Child: - Performs actual work (processing messages, managing state) - Reports failures to supervisor - Accepts restart commands from supervisor - Cleans up resources during shutdown</p>"},{"location":"components/rt/explanation/supervision/#why-supervision-matters","title":"Why Supervision Matters","text":"<p>Without Supervision: <pre><code>// Actor crashes -&gt; error propagates -&gt; entire system crashes\nlet actor = MyActor::new();\nactor.process(msg)?;  // If this fails, what happens?\n// System stops. No recovery mechanism.\n</code></pre></p> <p>With Supervision: <pre><code>// Actor crashes -&gt; supervisor detects -&gt; restart actor -&gt; system continues\nlet supervisor = SupervisorBuilder::new()\n    .with_child(ChildSpec::new(\"worker\").with_actor::&lt;MyActor&gt;())\n    .build()\n    .await?;\n// Child crashes? Supervisor automatically restarts it.\n// System continues operating with fresh child instance.\n</code></pre></p> <p>The Value Proposition: Supervision isolates failures and enables automatic recovery, transforming crashes from catastrophic failures into recoverable events.</p>"},{"location":"components/rt/explanation/supervision/#the-let-it-crash-philosophy","title":"The \"Let it Crash\" Philosophy","text":""},{"location":"components/rt/explanation/supervision/#traditional-error-handling","title":"Traditional Error Handling","text":"<p>Defensive Programming Approach:</p> <pre><code>// Traditional: anticipate and handle every possible error\nasync fn process_request(req: Request) -&gt; Result&lt;Response, Error&gt; {\n    // Validate input\n    if req.data.is_empty() {\n        return Err(Error::InvalidInput);\n    }\n\n    // Check preconditions\n    if !is_ready() {\n        return Err(Error::NotReady);\n    }\n\n    // Retry on transient errors\n    let result = match call_external_service(&amp;req).await {\n        Ok(r) =&gt; r,\n        Err(NetworkError::Timeout) =&gt; {\n            // Retry with backoff\n            retry_with_backoff().await?\n        }\n        Err(NetworkError::ConnectionRefused) =&gt; {\n            // Use cached data\n            get_cached_response()?\n        }\n        Err(e) =&gt; return Err(e),\n    };\n\n    // Validate output\n    if !result.is_valid() {\n        return Err(Error::InvalidResponse);\n    }\n\n    Ok(result)\n}\n</code></pre> <p>Problems: - Complex error handling logic in every function - Difficult to anticipate all possible failure modes - Error handling code often larger than business logic - Recovery strategies may be incorrect or incomplete</p>"},{"location":"components/rt/explanation/supervision/#let-it-crash-approach","title":"\"Let it Crash\" Approach","text":"<p>Supervision-Based Recovery:</p> <pre><code>// Supervision: simple error handling, rely on supervisor for recovery\nasync fn handle(&amp;mut self, msg: ProcessRequest, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; Result&lt;Response, ActorError&gt; {\n    let result = call_external_service(&amp;msg).await?;  // If error, actor crashes\n\n    // Supervisor detects crash and restarts actor\n    // Fresh actor instance begins with clean state\n\n    Ok(result)\n}\n\n// Supervisor configuration\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .with_child(\n        ChildSpec::new(\"processor\")\n            .with_actor::&lt;RequestProcessor&gt;()\n            .with_max_restarts(5)  // Limit restart rate\n            .with_restart_window(Duration::from_secs(60))\n    )\n    .build()\n    .await?;\n</code></pre> <p>Benefits: - Simpler code focused on happy path - Supervisor handles recovery consistently - Failed actor state is discarded (no corrupted state) - Restart limits prevent infinite restart loops</p>"},{"location":"components/rt/explanation/supervision/#when-to-let-it-crash","title":"When to \"Let it Crash\"","text":"<p>\u2705 Good Candidates: - Transient failures: Network timeouts, temporary resource unavailability - Corrupted state: State machine in unexpected state, data corruption detected - Resource exhaustion: Out of memory, file descriptors exhausted - Unexpected conditions: Assertion failures, invariant violations</p> <p>\u274c Poor Candidates: - Expected errors: User input validation, business logic errors - Recoverable errors: Authentication failures (should return error, not crash) - Deterministic failures: Configuration errors (restart won't fix) - Critical operations: Financial transactions (must complete or rollback, not crash)</p> <p>Guideline: Let actors crash for unexpected errors that indicate corrupted state. Handle expected errors explicitly.</p>"},{"location":"components/rt/explanation/supervision/#supervision-tree-architecture","title":"Supervision Tree Architecture","text":""},{"location":"components/rt/explanation/supervision/#hierarchical-fault-tolerance","title":"Hierarchical Fault Tolerance","text":"<p>Supervision trees create fault isolation boundaries where failures are contained and handled locally rather than propagating system-wide.</p> <pre><code>                Application Supervisor (Root)\n                       |\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502              \u2502              \u2502\n   API Supervisor   DB Supervisor  Worker Pool Supervisor\n        \u2502              \u2502              \u2502\n   \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2510\n   \u2502        \u2502     \u2502       \u2502     \u2502    ...  \u2502\nHTTP    WebSocket \u2502      \u2502    Worker1  WorkerN\nHandler  Handler  Reader Writer\n</code></pre> <p>Fault Isolation Zones:</p> <p>Level 1 (Application Supervisor): - Supervises major subsystems (API, Database, Workers) - Strategy: OneForOne (independent subsystems) - Failure impact: Only failed subsystem restarts</p> <p>Level 2 (Subsystem Supervisors): - Supervises related components (HTTP handlers, DB connections) - Strategy: May vary (OneForAll for coordinated state) - Failure impact: Contained within subsystem</p> <p>Level 3 (Worker Actors): - Performs actual work - Not supervisors themselves - Failure impact: Individual worker only</p>"},{"location":"components/rt/explanation/supervision/#supervision-decision-tree","title":"Supervision Decision Tree","text":"<p>When a child fails, the supervisor follows this decision process:</p> <pre><code>Child Failure Detected\n        \u2502\n        \u25bc\nHas max_restarts been exceeded? \u2500\u2500YES\u2500\u2500&gt; Escalate to Parent Supervisor\n        \u2502\n       NO\n        \u2502\n        \u25bc\nWhat is the restart_policy?\n        \u2502\n        \u251c\u2500 Permanent \u2500\u2500&gt; Always Restart\n        \u2502\n        \u251c\u2500 Transient \u2500\u2500&gt; Normal Exit? \u2500\u2500YES\u2500\u2500&gt; Don't Restart\n        \u2502                    \u2502\n        \u2502                   NO\n        \u2502                    \u2502\n        \u2502                    \u25bc\n        \u2502                 Restart\n        \u2502\n        \u2514\u2500 Temporary \u2500\u2500&gt; Never Restart, Remove Child\n</code></pre> <p>Escalation: If a supervisor cannot recover a child (max restarts exceeded), it escalates to its parent supervisor, which may restart the entire subtree.</p>"},{"location":"components/rt/explanation/supervision/#restart-strategies-explained","title":"Restart Strategies Explained","text":"<p>AirsSys RT provides three restart strategies inspired by Erlang/OTP.</p>"},{"location":"components/rt/explanation/supervision/#oneforone-strategy","title":"OneForOne Strategy","text":"<p>Behavior: When a child fails, only that child is restarted. Other children continue running unaffected.</p> <p>Diagram: <pre><code>Before Failure:          After Failure:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Supervisor  \u2502          \u2502 Supervisor  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Child A \u2713   \u2502          \u2502 Child A \u2713   \u2502 \u2190 Continues running\n\u2502 Child B \u2717   \u2502  \u2500\u2500\u2500\u2500\u2500\u2500&gt; \u2502 Child B \u21bb   \u2502 \u2190 Restarted\n\u2502 Child C \u2713   \u2502          \u2502 Child C \u2713   \u2502 \u2190 Continues running\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Use Case: Children are independent - failure of one does not affect others.</p> <p>Example: <pre><code>// HTTP request handlers - each independent\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)  // Only restart failed handler\n    .with_child(ChildSpec::new(\"handler-1\").with_actor::&lt;HttpHandler&gt;())\n    .with_child(ChildSpec::new(\"handler-2\").with_actor::&lt;HttpHandler&gt;())\n    .with_child(ChildSpec::new(\"handler-3\").with_actor::&lt;HttpHandler&gt;())\n    .build()\n    .await?;\n// Handler-2 crashes -&gt; Only handler-2 restarts\n// Handler-1 and Handler-3 continue processing requests\n</code></pre></p> <p>Performance: Low overhead - only failed child affected (~1.28\u00b5s restart latency).</p> <p>When to Use: - Workers processing independent tasks (HTTP handlers, job processors) - Stateless services with no shared state - High-throughput systems where restarting everything is too expensive</p>"},{"location":"components/rt/explanation/supervision/#oneforall-strategy","title":"OneForAll Strategy","text":"<p>Behavior: When any child fails, all children are restarted. Ensures coordinated state across children.</p> <p>Diagram: <pre><code>Before Failure:          After Failure:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Supervisor  \u2502          \u2502 Supervisor  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Child A \u2713   \u2502          \u2502 Child A \u21bb   \u2502 \u2190 Restarted (even though healthy)\n\u2502 Child B \u2717   \u2502  \u2500\u2500\u2500\u2500\u2500\u2500&gt; \u2502 Child B \u21bb   \u2502 \u2190 Restarted (failure trigger)\n\u2502 Child C \u2713   \u2502          \u2502 Child C \u21bb   \u2502 \u2190 Restarted (even though healthy)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Use Case: Children have interdependent state - all must restart together to maintain consistency.</p> <p>Example: <pre><code>// Distributed transaction coordinators - must stay synchronized\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForAll)  // Restart all to maintain consistency\n    .with_child(ChildSpec::new(\"coordinator-1\").with_actor::&lt;TxCoordinator&gt;())\n    .with_child(ChildSpec::new(\"coordinator-2\").with_actor::&lt;TxCoordinator&gt;())\n    .with_child(ChildSpec::new(\"coordinator-3\").with_actor::&lt;TxCoordinator&gt;())\n    .build()\n    .await?;\n// Coordinator-2 crashes -&gt; All coordinators restart\n// Ensures consistent state across distributed transaction\n</code></pre></p> <p>Performance: Higher overhead - all children affected (30-150\u00b5s for full restart).</p> <p>When to Use: - State machines with coordinated state across actors - Distributed consensus protocols (Raft, Paxos) - Tightly coupled services that must stay synchronized</p>"},{"location":"components/rt/explanation/supervision/#restforone-strategy","title":"RestForOne Strategy","text":"<p>Behavior: When a child fails, restart that child and all children started after it. Preserves dependency order.</p> <p>Diagram: <pre><code>Before Failure:          After Failure:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Supervisor  \u2502          \u2502 Supervisor  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524          \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Child A \u2713   \u2502          \u2502 Child A \u2713   \u2502 \u2190 Continues (started before B)\n\u2502 Child B \u2717   \u2502  \u2500\u2500\u2500\u2500\u2500\u2500&gt; \u2502 Child B \u21bb   \u2502 \u2190 Restarted (failure trigger)\n\u2502 Child C \u2713   \u2502          \u2502 Child C \u21bb   \u2502 \u2190 Restarted (depends on B)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Use Case: Children have dependency chains - later children depend on earlier ones.</p> <p>Example: <pre><code>// Pipeline: Reader -&gt; Processor -&gt; Writer\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::RestForOne)  // Maintain dependency order\n    .with_child(ChildSpec::new(\"reader\").with_actor::&lt;DataReader&gt;())     // Independent\n    .with_child(ChildSpec::new(\"processor\").with_actor::&lt;DataProcessor&gt;()) // Depends on reader\n    .with_child(ChildSpec::new(\"writer\").with_actor::&lt;DataWriter&gt;())     // Depends on processor\n    .build()\n    .await?;\n// Processor crashes -&gt; Processor + Writer restart (Reader continues)\n// Writer crashes -&gt; Only Writer restarts\n// Reader crashes -&gt; All restart (everything depends on reader)\n</code></pre></p> <p>Performance: Medium overhead - only dependent children affected.</p> <p>When to Use: - Processing pipelines with dependency order - Services with startup dependencies (database connection before query executor) - Systems where later stages depend on earlier stages</p>"},{"location":"components/rt/explanation/supervision/#design-decisions-and-rationale","title":"Design Decisions and Rationale","text":""},{"location":"components/rt/explanation/supervision/#decision-three-restart-strategies","title":"Decision: Three Restart Strategies","text":"<p>Context: Erlang provides OneForOne, OneForAll, RestForOne, and SimpleOneForOne.</p> <p>Choice: Implement OneForOne, OneForAll, RestForOne (skip SimpleOneForOne).</p> <p>Rationale: - OneForOne: Most common, covers independent workers (80% of use cases) - OneForAll: Essential for coordinated state (15% of use cases) - RestForOne: Handles dependency chains (5% of use cases) - SimpleOneForOne: Dynamic worker pools - can be built with actor pools instead</p> <p>Tradeoff: Simpler API (fewer strategies to choose from) vs. Completeness (missing SimpleOneForOne).</p>"},{"location":"components/rt/explanation/supervision/#decision-restart-rate-limiting","title":"Decision: Restart Rate Limiting","text":"<p>Context: Unlimited restarts can cause \"restart storms\" consuming resources.</p> <p>Choice: Require <code>max_restarts</code> and <code>restart_window</code> configuration.</p> <pre><code>ChildSpec::new(\"worker\")\n    .with_max_restarts(5)  // Max 5 restarts\n    .with_restart_window(Duration::from_secs(60))  // Within 60 seconds\n</code></pre> <p>Rationale: - Prevents infinite restart loops (deterministic failures) - Escalates persistent failures to parent supervisor - Protects system resources from thrashing</p> <p>Behavior: If child crashes more than <code>max_restarts</code> times within <code>restart_window</code>, supervisor escalates to its parent.</p> <p>Tradeoff: Configuration complexity vs. System stability.</p>"},{"location":"components/rt/explanation/supervision/#decision-graceful-shutdown","title":"Decision: Graceful Shutdown","text":"<p>Context: Child actors may need time to clean up resources (flush buffers, close connections).</p> <p>Choice: Provide <code>ShutdownPolicy</code> with timeout options.</p> <pre><code>pub enum ShutdownPolicy {\n    Graceful(Duration),  // Wait for graceful shutdown, timeout after duration\n    Immediate,           // Stop immediately, no cleanup\n    Infinity,            // Wait indefinitely for shutdown\n}\n</code></pre> <p>Rationale: - Graceful: Most services need cleanup time (default) - Immediate: For non-critical workers (faster restarts) - Infinity: For critical transactions (must complete)</p> <p>Tradeoff: Shutdown latency vs. Data consistency.</p>"},{"location":"components/rt/explanation/supervision/#decision-supervisor-builder-pattern","title":"Decision: Supervisor Builder Pattern","text":"<p>Context: Creating supervisors requires many configuration options.</p> <p>Choice: Implement builder pattern for ergonomic configuration.</p> <pre><code>let supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .with_max_restarts(10)\n    .with_restart_window(Duration::from_secs(60))\n    .with_child(\n        ChildSpec::new(\"worker-1\")\n            .with_actor::&lt;Worker&gt;()\n            .with_restart_policy(RestartPolicy::Permanent)\n    )\n    .with_child(\n        ChildSpec::new(\"worker-2\")\n            .with_actor::&lt;Worker&gt;()\n            .with_restart_policy(RestartPolicy::Transient)\n    )\n    .build()\n    .await?;\n</code></pre> <p>Rationale: - Clear, readable configuration - Compile-time validation of required fields - Follows Rust builder pattern conventions (RT-TASK-013)</p> <p>Tradeoff: More code to maintain vs. Better developer experience.</p>"},{"location":"components/rt/explanation/supervision/#comparison-with-alternative-approaches","title":"Comparison with Alternative Approaches","text":""},{"location":"components/rt/explanation/supervision/#supervision-vs-try-catch-error-handling","title":"Supervision vs. Try-Catch Error Handling","text":"<p>Try-Catch Approach:</p> <pre><code>// Traditional exception handling\nloop {\n    match worker.process().await {\n        Ok(_) =&gt; continue,\n        Err(e) =&gt; {\n            log::error!(\"Worker failed: {:?}\", e);\n            // Manual recovery logic\n            worker = Worker::new()?;  // Recreate worker\n            // What about worker state? Cleanup? Resource leaks?\n        }\n    }\n}\n</code></pre> <p>Problems: - Recovery logic scattered throughout code - Inconsistent recovery strategies - Difficult to test recovery paths - No isolation (failure may corrupt surrounding code)</p> <p>Supervision Approach:</p> <pre><code>// Supervisor handles recovery consistently\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .with_child(ChildSpec::new(\"worker\").with_actor::&lt;Worker&gt;())\n    .build()\n    .await?;\n// Supervisor monitors worker, restarts on failure\n// Recovery strategy centralized and tested\n// Failure isolated to child actor boundary\n</code></pre> <p>Advantages: - Centralized recovery strategy - Consistent across all supervised actors - Testable recovery logic - Clear fault isolation boundaries</p>"},{"location":"components/rt/explanation/supervision/#supervision-vs-circuit-breaker-pattern","title":"Supervision vs. Circuit Breaker Pattern","text":"<p>Circuit Breaker:</p> <pre><code>// Circuit breaker prevents cascading failures\nlet circuit_breaker = CircuitBreaker::new()\n    .failure_threshold(5)\n    .timeout(Duration::from_secs(60));\n\nmatch circuit_breaker.call(|| external_service.call()).await {\n    Ok(result) =&gt; handle_success(result),\n    Err(CircuitBreakerError::Open) =&gt; handle_circuit_open(),\n    Err(CircuitBreakerError::ServiceError(e)) =&gt; handle_service_error(e),\n}\n</code></pre> <p>Use Case: Protects caller from failing service, prevents resource exhaustion.</p> <p>Supervision:</p> <pre><code>// Supervision restarts failed actors\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .with_child(ChildSpec::new(\"service\").with_actor::&lt;ExternalService&gt;())\n    .build()\n    .await?;\n</code></pre> <p>Use Case: Recovers failed actor with fresh state, maintains service availability.</p> <p>Comparison:</p> Aspect Circuit Breaker Supervision Purpose Prevent cascading failures Recover from failures Behavior Stop calling failing service Restart failed actor When to Use External dependencies Internal actors Failure Detection Error rate threshold Crash detection Recovery Manual (wait for circuit close) Automatic (supervisor restart) <p>Best Practice: Use both - circuit breakers for external services, supervision for internal actors.</p>"},{"location":"components/rt/explanation/supervision/#when-to-use-each-strategy","title":"When to Use Each Strategy","text":""},{"location":"components/rt/explanation/supervision/#oneforone-strategy_1","title":"OneForOne Strategy","text":"<p>Choose When: - \u2705 Workers are stateless or have independent state - \u2705 High throughput required (minimize restart impact) - \u2705 Failures are isolated to individual workers</p> <p>Examples: - HTTP request handlers (each request independent) - Job processors (each job independent) - WebSocket connections (each connection independent)</p> <p>Anti-Patterns: - \u274c Workers share mutable state (use OneForAll) - \u274c Workers have dependencies (use RestForOne)</p>"},{"location":"components/rt/explanation/supervision/#oneforall-strategy_1","title":"OneForAll Strategy","text":"<p>Choose When: - \u2705 Workers have coordinated state (must stay synchronized) - \u2705 Partial restart would cause inconsistency - \u2705 Workers are tightly coupled</p> <p>Examples: - Distributed consensus (Raft nodes must synchronize) - State machine replicas (must maintain identical state) - Transaction coordinators (must agree on outcome)</p> <p>Anti-Patterns: - \u274c Workers are independent (unnecessary restart overhead) - \u274c High-throughput system (OneForAll restarts too disruptive)</p>"},{"location":"components/rt/explanation/supervision/#restforone-strategy_1","title":"RestForOne Strategy","text":"<p>Choose When: - \u2705 Workers have dependency chains (A depends on B depends on C) - \u2705 Later workers depend on earlier workers - \u2705 Restart order matters</p> <p>Examples: - Processing pipelines (Reader -&gt; Transformer -&gt; Writer) - Service initialization (Config -&gt; Database -&gt; API Server) - Layered architecture (Data Layer -&gt; Business Layer -&gt; Presentation Layer)</p> <p>Anti-Patterns: - \u274c No clear dependency order (use OneForOne) - \u274c Circular dependencies (redesign architecture)</p>"},{"location":"components/rt/explanation/supervision/#supervision-best-practices","title":"Supervision Best Practices","text":""},{"location":"components/rt/explanation/supervision/#1-design-supervision-trees-top-down","title":"1. Design Supervision Trees Top-Down","text":"<p>Start with fault isolation boundaries:</p> <pre><code>// Level 1: Major subsystems\nApplication Supervisor\n\u251c\u2500\u2500 API Supervisor\n\u251c\u2500\u2500 Database Supervisor\n\u2514\u2500\u2500 Background Jobs Supervisor\n</code></pre> <p>Then drill down into components:</p> <pre><code>// Level 2: Components within subsystem\nAPI Supervisor\n\u251c\u2500\u2500 HTTP Handler Pool\n\u251c\u2500\u2500 WebSocket Handler Pool\n\u2514\u2500\u2500 Authentication Service\n</code></pre> <p>Guideline: Each supervisor manages 3-10 children for clarity.</p>"},{"location":"components/rt/explanation/supervision/#2-match-strategy-to-failure-characteristics","title":"2. Match Strategy to Failure Characteristics","text":"<p>Ask yourself:</p> <ol> <li>Are children independent? \u2192 Use OneForOne</li> <li>Must children stay synchronized? \u2192 Use OneForAll</li> <li>Do children have dependencies? \u2192 Use RestForOne</li> </ol>"},{"location":"components/rt/explanation/supervision/#3-set-realistic-restart-limits","title":"3. Set Realistic Restart Limits","text":"<p>Conservative (critical services): <pre><code>.with_max_restarts(3)\n.with_restart_window(Duration::from_secs(300))  // 3 restarts per 5 minutes\n</code></pre></p> <p>Moderate (typical services): <pre><code>.with_max_restarts(5)\n.with_restart_window(Duration::from_secs(60))  // 5 restarts per minute\n</code></pre></p> <p>Aggressive (transient failures expected): <pre><code>.with_max_restarts(10)\n.with_restart_window(Duration::from_secs(60))  // 10 restarts per minute\n</code></pre></p> <p>Guideline: Start conservative, increase limits if transient failures are common.</p>"},{"location":"components/rt/explanation/supervision/#4-monitor-supervisor-health","title":"4. Monitor Supervisor Health","text":"<pre><code>use airssys_rt::monitoring::{HealthMonitor, SupervisorHealthCheck};\n\nlet monitor = HealthMonitor::new();\nmonitor.register(supervisor_ref, SupervisorHealthCheck::new()).await?;\n\n// Check supervisor health periodically\nlet status = monitor.check_health(supervisor_ref).await?;\nif status.is_unhealthy() {\n    log::error!(\"Supervisor unhealthy: {:?}\", status);\n    // Alert operations team\n}\n</code></pre>"},{"location":"components/rt/explanation/supervision/#further-reading","title":"Further Reading","text":""},{"location":"components/rt/explanation/supervision/#airssys-rt-documentation","title":"AirsSys RT Documentation","text":"<ul> <li>Supervisor API Reference</li> <li>Supervisor Patterns Guide</li> <li>Architecture: Supervision</li> </ul>"},{"location":"components/rt/explanation/supervision/#external-resources","title":"External Resources","text":"<ul> <li>Erlang/OTP Design Principles: Official Erlang supervision documentation</li> <li>\"Let it Crash\" Philosophy: Joe Armstrong's writings on fault tolerance</li> <li>Release It! (Michael Nygard): Stability patterns including supervision</li> </ul> <p>Last Updated: 2025-01-18 (RT-TASK-011 Phase 4 Day 7)</p>"},{"location":"components/rt/guides/actor-development/","title":"Actor Development Tutorial","text":"<p>This comprehensive tutorial teaches you how to build robust, production-ready actors. You'll learn lifecycle management, state patterns, message design, error handling, and testing strategies.</p> <p>Prerequisites: - Completed Getting Started - Understanding of async/await in Rust - Basic familiarity with actor model concepts</p> <p>What You'll Learn: - Actor lifecycle in depth (pre_start, handle_message, post_stop) - State management patterns (immutable, mutable, persistent) - Message design patterns (commands, queries, events) - Error handling strategies (recoverable, escalation, supervision) - Testing actors (unit, integration, property-based)</p>"},{"location":"components/rt/guides/actor-development/#1-actor-lifecycle-in-depth","title":"1. Actor Lifecycle in Depth","text":"<p>Understanding the complete actor lifecycle is crucial for building reliable systems.</p>"},{"location":"components/rt/guides/actor-development/#lifecycle-states","title":"Lifecycle States","text":"<p>Actors progress through distinct states:</p> <pre><code>Created \u2192 Starting \u2192 Running \u2192 Stopping \u2192 Stopped\n                       \u2193\n                   Restarting (on error)\n</code></pre> <p>State Transitions: - Created: Initial state after instantiation - Starting: Executing <code>pre_start()</code>, initializing resources - Running: Processing messages via <code>handle_message()</code> - Stopping: Executing <code>post_stop()</code>, cleaning up resources - Stopped: Terminal state, actor no longer active</p>"},{"location":"components/rt/guides/actor-development/#pre_start-resource-initialization","title":"pre_start() - Resource Initialization","text":"<p>The <code>pre_start()</code> hook runs once before the actor begins processing messages.</p> <p>When to use: - Open file handles or database connections - Initialize network connections - Load configuration or state from disk - Register with external services - Allocate expensive resources</p> <p>Example: <pre><code>use airssys_rt::prelude::*;\nuse async_trait::async_trait;\nuse std::fs::File;\nuse std::io::{self, BufReader};\n\nstruct FileProcessor {\n    file: Option&lt;BufReader&lt;File&gt;&gt;,\n    path: String,\n}\n\n#[async_trait]\nimpl Actor for FileProcessor {\n    type Message = ProcessCommand;\n    type Error = io::Error;\n\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        // Open file during initialization\n        let file = File::open(&amp;self.path)?;\n        self.file = Some(BufReader::new(file));\n\n        println!(\"[{}] File opened: {}\", \n                 context.address().name().unwrap_or(\"unknown\"), \n                 self.path);\n        Ok(())\n    }\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        // File is guaranteed to be open here\n        let file = self.file.as_mut().expect(\"File not initialized\");\n        // ... process file\n        context.record_message();\n        Ok(())\n    }\n\n    async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        _context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        // File automatically closed when dropped\n        self.file = None;\n        println!(\"File processor stopped\");\n        Ok(())\n    }\n}\n</code></pre></p> <p>Best practices: - Return <code>Err</code> if initialization fails (prevents starting broken actor) - Keep initialization fast (&lt;100ms ideal) - Log initialization steps for debugging - Use <code>?</code> operator for early error returns</p>"},{"location":"components/rt/guides/actor-development/#handle_message-message-processing","title":"handle_message() - Message Processing","text":"<p>The core of your actor's behavior. Messages are processed sequentially (no concurrent access).</p> <p>Patterns:</p>"},{"location":"components/rt/guides/actor-development/#1-state-mutations","title":"1. State Mutations","text":"<pre><code>async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    message: Self::Message,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    match message {\n        CounterMsg::Increment =&gt; {\n            self.count += 1;  // Safe - exclusive access\n        }\n        CounterMsg::Reset =&gt; {\n            self.count = 0;\n        }\n    }\n    context.record_message();\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/guides/actor-development/#2-requestreply-pattern","title":"2. Request/Reply Pattern","text":"<pre><code>use tokio::sync::oneshot;\n\n#[derive(Clone)]\nenum QueryMessage {\n    GetCount(oneshot::Sender&lt;u64&gt;),\n    GetStats(oneshot::Sender&lt;Stats&gt;),\n}\n\nasync fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    message: Self::Message,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    match message {\n        QueryMessage::GetCount(reply) =&gt; {\n            // Send current count back to requester\n            let _ = reply.send(self.count);\n        }\n        QueryMessage::GetStats(reply) =&gt; {\n            let stats = Stats {\n                count: self.count,\n                messages: context.message_count(),\n            };\n            let _ = reply.send(stats);\n        }\n    }\n    context.record_message();\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/guides/actor-development/#3-side-effects","title":"3. Side Effects","text":"<pre><code>async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    message: Self::Message,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    match message {\n        LogMessage::Write(entry) =&gt; {\n            // Write to file (side effect)\n            writeln!(self.file, \"{}\", entry)?;\n            self.file.flush()?;\n\n            // Update metrics\n            self.entries_written += 1;\n        }\n    }\n    context.record_message();\n    Ok(())\n}\n</code></pre> <p>Performance Note: - Message processing baseline: ~31.5ns per message - Keep processing fast for high throughput - Offload expensive I/O to separate actors - Use async operations for blocking calls</p>"},{"location":"components/rt/guides/actor-development/#post_stop-resource-cleanup","title":"post_stop() - Resource Cleanup","text":"<p>The <code>post_stop()</code> hook runs when the actor is shutting down.</p> <p>When to use: - Close file handles or connections - Flush buffers to disk - Deregister from external services - Release locks or semaphores - Save state for persistence</p> <p>Example: <pre><code>async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    // Flush pending writes\n    if let Some(ref mut file) = self.file {\n        file.flush()?;\n    }\n\n    // Save state to disk\n    let state = ActorState {\n        count: self.count,\n        timestamp: context.start_time(),\n    };\n    tokio::fs::write(&amp;self.state_path, serde_json::to_string(&amp;state)?).await?;\n\n    println!(\"[{}] State persisted, shutting down\", \n             context.address().name().unwrap_or(\"unknown\"));\n    Ok(())\n}\n</code></pre></p> <p>Best practices: - Always clean up resources (prevent leaks) - Handle cleanup errors gracefully (log, don't panic) - Keep shutdown fast (&lt;1 second ideal) - Persist critical state before shutdown</p>"},{"location":"components/rt/guides/actor-development/#2-state-management-patterns","title":"2. State Management Patterns","text":"<p>Choosing the right state management pattern affects correctness, performance, and maintainability.</p>"},{"location":"components/rt/guides/actor-development/#pattern-1-immutable-state","title":"Pattern 1: Immutable State","text":"<p>When to use: - State changes are infrequent - State is small (&lt; 1KB) - Functional programming style preferred</p> <p>Example: <pre><code>#[derive(Clone, Debug)]\nstruct ImmutableState {\n    count: u64,\n    name: String,\n    config: Config,\n}\n\nstruct ImmutableActor {\n    state: ImmutableState,\n}\n\nasync fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    message: Self::Message,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    // Create new state instead of mutating\n    self.state = ImmutableState {\n        count: self.state.count + 1,\n        ..self.state.clone()\n    };\n    context.record_message();\n    Ok(())\n}\n</code></pre></p> <p>Pros: - Simple reasoning (no hidden mutations) - Easy to test (pure functions) - Works well with undo/redo patterns</p> <p>Cons: - Memory allocation on every change - Slower for large state (cloning overhead)</p>"},{"location":"components/rt/guides/actor-development/#pattern-2-mutable-state","title":"Pattern 2: Mutable State","text":"<p>When to use: - Frequent state updates - Large state objects (&gt; 1KB) - Performance-critical paths</p> <p>Example: <pre><code>struct MutableActor {\n    count: u64,\n    cache: HashMap&lt;String, CachedValue&gt;,\n    buffer: Vec&lt;u8&gt;,\n}\n\nasync fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    message: Self::Message,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    match message {\n        Msg::Increment =&gt; {\n            self.count += 1;  // Direct mutation - zero allocation\n        }\n        Msg::UpdateCache(key, value) =&gt; {\n            self.cache.insert(key, value);  // HashMap mutation\n        }\n        Msg::Append(data) =&gt; {\n            self.buffer.extend_from_slice(&amp;data);  // Vec mutation\n        }\n    }\n    context.record_message();\n    Ok(())\n}\n</code></pre></p> <p>Pros: - Zero allocation for updates - Best performance - Natural for imperative style</p> <p>Cons: - Must track mutations carefully - More complex testing</p>"},{"location":"components/rt/guides/actor-development/#pattern-3-interior-mutability-advanced","title":"Pattern 3: Interior Mutability (Advanced)","text":"<p>When to use: - Shared state across async boundaries - Complex borrowing scenarios - Performance-critical with thread safety</p> <p>Example: <pre><code>use std::sync::Arc;\nuse tokio::sync::RwLock;\n\nstruct SharedActor {\n    // Shared mutable state\n    state: Arc&lt;RwLock&lt;SharedState&gt;&gt;,\n}\n\nasync fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    message: Self::Message,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    match message {\n        Msg::Read =&gt; {\n            let state = self.state.read().await;\n            println!(\"Count: {}\", state.count);\n        }\n        Msg::Write(value) =&gt; {\n            let mut state = self.state.write().await;\n            state.count = value;\n        }\n    }\n    context.record_message();\n    Ok(())\n}\n</code></pre></p> <p>Pros: - Share state across async tasks - Fine-grained locking - Concurrent reads</p> <p>Cons: - Complexity (deadlock risk) - Slower than direct mutation - Requires careful lock management</p> <p>\u26a0\ufe0f Warning: Use only when necessary. Most actors don't need interior mutability.</p>"},{"location":"components/rt/guides/actor-development/#pattern-4-state-persistence","title":"Pattern 4: State Persistence","text":"<p>When to use: - Actors must survive restarts - Audit trail required - Recovery from crashes needed</p> <p>Example: <pre><code>use serde::{Serialize, Deserialize};\nuse tokio::fs;\n\n#[derive(Serialize, Deserialize, Clone)]\nstruct PersistentState {\n    count: u64,\n    last_updated: chrono::DateTime&lt;chrono::Utc&gt;,\n}\n\nstruct PersistentActor {\n    state: PersistentState,\n    state_path: String,\n}\n\nimpl PersistentActor {\n    async fn save_state(&amp;self) -&gt; io::Result&lt;()&gt; {\n        let json = serde_json::to_string(&amp;self.state)?;\n        fs::write(&amp;self.state_path, json).await?;\n        Ok(())\n    }\n\n    async fn load_state(path: &amp;str) -&gt; io::Result&lt;PersistentState&gt; {\n        let json = fs::read_to_string(path).await?;\n        Ok(serde_json::from_str(&amp;json)?)\n    }\n}\n\nasync fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    _context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    // Load state on startup\n    if let Ok(state) = Self::load_state(&amp;self.state_path).await {\n        self.state = state;\n        println!(\"State restored from disk\");\n    }\n    Ok(())\n}\n\nasync fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    message: Self::Message,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    // Update state\n    self.state.count += 1;\n    self.state.last_updated = chrono::Utc::now();\n\n    // Persist every N messages\n    if context.message_count() % 100 == 0 {\n        self.save_state().await?;\n    }\n\n    context.record_message();\n    Ok(())\n}\n</code></pre></p> <p>Best practices: - Batch writes (don't persist every message) - Use write-ahead logging for durability - Handle corruption gracefully - Version your state format</p>"},{"location":"components/rt/guides/actor-development/#3-message-design-patterns","title":"3. Message Design Patterns","text":"<p>Well-designed messages improve clarity, type safety, and maintainability.</p>"},{"location":"components/rt/guides/actor-development/#pattern-1-command-messages","title":"Pattern 1: Command Messages","text":"<p>Commands instruct the actor to do something.</p> <p>Characteristics: - Imperative naming (Verb + Object) - Fire-and-forget semantics - May have side effects</p> <p>Example: <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nenum FileCommand {\n    Write(String),           // Write data\n    Flush,                   // Flush buffers\n    Close,                   // Close file\n    Rotate,                  // Rotate log file\n}\n\nimpl Message for FileCommand {\n    const MESSAGE_TYPE: &amp;'static str = \"file_command\";\n}\n</code></pre></p>"},{"location":"components/rt/guides/actor-development/#pattern-2-query-messages","title":"Pattern 2: Query Messages","text":"<p>Queries request information without modifying state.</p> <p>Characteristics: - Request/reply pattern (oneshot channel) - No side effects (read-only) - Returns data to caller</p> <p>Example: <pre><code>use tokio::sync::oneshot;\n\n#[derive(Clone)]\nenum FileQuery {\n    GetSize(oneshot::Sender&lt;u64&gt;),\n    GetPath(oneshot::Sender&lt;String&gt;),\n    GetStats(oneshot::Sender&lt;FileStats&gt;),\n}\n\nimpl Message for FileQuery {\n    const MESSAGE_TYPE: &amp;'static str = \"file_query\";\n}\n\n// Usage:\nasync fn query_file_size(file_actor: &amp;ActorAddress) -&gt; Result&lt;u64, Error&gt; {\n    let (tx, rx) = oneshot::channel();\n    file_actor.send(FileQuery::GetSize(tx)).await?;\n    let size = rx.await?;\n    Ok(size)\n}\n</code></pre></p>"},{"location":"components/rt/guides/actor-development/#pattern-3-event-messages","title":"Pattern 3: Event Messages","text":"<p>Events notify observers that something happened.</p> <p>Characteristics: - Past tense naming (Subject + Past Verb) - Pub/sub semantics (via MessageBroker) - Immutable facts</p> <p>Example: <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nenum FileEvent {\n    FileOpened { path: String, size: u64 },\n    BytesWritten { count: u64 },\n    FileClosed { final_size: u64 },\n    ErrorOccurred { error: String },\n}\n\nimpl Message for FileEvent {\n    const MESSAGE_TYPE: &amp;'static str = \"file_event\";\n}\n</code></pre></p>"},{"location":"components/rt/guides/actor-development/#pattern-4-message-versioning","title":"Pattern 4: Message Versioning","text":"<p>Support evolution of message types over time.</p> <p>Example: <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"version\")]\nenum VersionedMessage {\n    #[serde(rename = \"v1\")]\n    V1(MessageV1),\n\n    #[serde(rename = \"v2\")]\n    V2(MessageV2),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct MessageV1 {\n    data: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct MessageV2 {\n    data: String,\n    timestamp: chrono::DateTime&lt;chrono::Utc&gt;,  // New field\n    priority: u8,                               // New field\n}\n\nasync fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    message: VersionedMessage,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    match message {\n        VersionedMessage::V1(msg) =&gt; {\n            // Handle old format\n            self.process_legacy(msg)?;\n        }\n        VersionedMessage::V2(msg) =&gt; {\n            // Handle new format\n            self.process_current(msg)?;\n        }\n    }\n    context.record_message();\n    Ok(())\n}\n</code></pre></p> <p>Best practices: - Use enums for message variants - Derive <code>Clone</code> (messages are cloned when sent) - Derive <code>Serialize</code> for routing/persistence - Version messages for backward compatibility - Keep messages small (&lt; 1KB ideal)</p>"},{"location":"components/rt/guides/actor-development/#4-error-handling","title":"4. Error Handling","text":"<p>Actors use supervision for fault tolerance. Understanding error handling is critical.</p>"},{"location":"components/rt/guides/actor-development/#error-types","title":"Error Types","text":"<p>Recoverable Errors: - Temporary failures (network timeout, file lock) - Can be retried - Don't indicate actor corruption</p> <p>Non-Recoverable Errors: - Logic errors (invalid state) - Resource exhaustion - Indicate actor needs restart</p>"},{"location":"components/rt/guides/actor-development/#erroraction-strategy","title":"ErrorAction Strategy","text":"<p>The <code>on_error()</code> hook determines supervision behavior:</p> <pre><code>#[async_trait]\nimpl Actor for MyActor {\n    async fn on_error&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        error: Self::Error,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; ErrorAction {\n        match error {\n            MyError::Temporary(_) =&gt; {\n                // Retry-able error - keep running\n                ErrorAction::Resume\n            }\n            MyError::RateLimitExceeded =&gt; {\n                // Need backoff, but don't restart\n                ErrorAction::Resume\n            }\n            MyError::InvalidState =&gt; {\n                // Corrupted state - restart to clean slate\n                ErrorAction::Restart\n            }\n            MyError::Fatal(_) =&gt; {\n                // Can't recover - let supervisor decide\n                ErrorAction::Escalate\n            }\n        }\n    }\n}\n</code></pre> <p>ErrorAction variants: - Resume: Continue processing (error handled) - Stop: Graceful shutdown - Restart: Reset state and restart - Escalate: Let supervisor decide</p>"},{"location":"components/rt/guides/actor-development/#retry-pattern","title":"Retry Pattern","text":"<p>Implement exponential backoff for transient failures:</p> <pre><code>use tokio::time::{sleep, Duration};\n\nstruct RetryableActor {\n    retry_count: u32,\n    max_retries: u32,\n}\n\nasync fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n    &amp;mut self,\n    message: Self::Message,\n    context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n) -&gt; Result&lt;(), Self::Error&gt; {\n    // Try operation with retries\n    let mut attempt = 0;\n    loop {\n        match self.try_operation(&amp;message).await {\n            Ok(result) =&gt; {\n                self.retry_count = 0;  // Reset on success\n                context.record_message();\n                return Ok(());\n            }\n            Err(e) if attempt &lt; self.max_retries =&gt; {\n                attempt += 1;\n                let delay = Duration::from_millis(100 * 2_u64.pow(attempt));\n                sleep(delay).await;\n                continue;\n            }\n            Err(e) =&gt; {\n                // Exhausted retries\n                return Err(e);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/guides/actor-development/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<p>Prevent cascading failures:</p> <pre><code>use std::time::Instant;\n\nstruct CircuitBreaker {\n    state: BreakerState,\n    failure_count: u32,\n    threshold: u32,\n    timeout: Duration,\n    last_failure: Option&lt;Instant&gt;,\n}\n\nenum BreakerState {\n    Closed,   // Normal operation\n    Open,     // Failing, reject requests\n    HalfOpen, // Testing if service recovered\n}\n\nimpl CircuitBreaker {\n    fn should_attempt(&amp;mut self) -&gt; bool {\n        match self.state {\n            BreakerState::Closed =&gt; true,\n            BreakerState::Open =&gt; {\n                // Check if timeout expired\n                if let Some(last) = self.last_failure {\n                    if last.elapsed() &gt; self.timeout {\n                        self.state = BreakerState::HalfOpen;\n                        true\n                    } else {\n                        false\n                    }\n                } else {\n                    false\n                }\n            }\n            BreakerState::HalfOpen =&gt; true,\n        }\n    }\n\n    fn on_success(&amp;mut self) {\n        self.failure_count = 0;\n        self.state = BreakerState::Closed;\n    }\n\n    fn on_failure(&amp;mut self) {\n        self.failure_count += 1;\n        self.last_failure = Some(Instant::now());\n\n        if self.failure_count &gt;= self.threshold {\n            self.state = BreakerState::Open;\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/guides/actor-development/#5-testing-actors","title":"5. Testing Actors","text":"<p>Comprehensive testing ensures actor correctness and reliability.</p>"},{"location":"components/rt/guides/actor-development/#unit-testing","title":"Unit Testing","text":"<p>Test actor logic in isolation:</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_counter_increment() {\n        // Arrange\n        let mut actor = CounterActor { count: 0 };\n        let address = ActorAddress::named(\"test-counter\");\n        let broker = InMemoryMessageBroker::new();\n        let mut context = ActorContext::new(address, broker);\n\n        // Act\n        let result = actor.handle_message(\n            CounterMsg::Increment, \n            &amp;mut context\n        ).await;\n\n        // Assert\n        assert!(result.is_ok());\n        assert_eq!(actor.count, 1);\n        assert_eq!(context.message_count(), 1);\n    }\n\n    #[tokio::test]\n    async fn test_error_handling() {\n        let mut actor = CounterActor { count: 100 };\n        let address = ActorAddress::named(\"test-counter\");\n        let broker = InMemoryMessageBroker::new();\n        let mut context = ActorContext::new(address, broker);\n\n        // Test error condition\n        let result = actor.handle_message(\n            CounterMsg::SetValue(1000),  // Over limit\n            &amp;mut context\n        ).await;\n\n        assert!(result.is_err());\n\n        // Test error action\n        let action = actor.on_error(\n            result.unwrap_err(), \n            &amp;mut context\n        ).await;\n        assert_eq!(action, ErrorAction::Restart);\n    }\n}\n</code></pre>"},{"location":"components/rt/guides/actor-development/#integration-testing","title":"Integration Testing","text":"<p>Test actor interactions:</p> <pre><code>#[cfg(test)]\nmod integration_tests {\n    use super::*;\n    use tokio::sync::oneshot;\n\n    #[tokio::test]\n    async fn test_request_reply() {\n        // Setup\n        let mut actor = QueryActor { count: 42 };\n        let address = ActorAddress::named(\"query-actor\");\n        let broker = InMemoryMessageBroker::new();\n        let mut context = ActorContext::new(address, broker);\n\n        // Create query with reply channel\n        let (tx, rx) = oneshot::channel();\n        let msg = QueryMsg::GetCount(tx);\n\n        // Send query\n        actor.handle_message(msg, &amp;mut context).await.unwrap();\n\n        // Verify response\n        let count = rx.await.unwrap();\n        assert_eq!(count, 42);\n    }\n}\n</code></pre>"},{"location":"components/rt/guides/actor-development/#lifecycle-testing","title":"Lifecycle Testing","text":"<p>Test complete actor lifecycle:</p> <pre><code>#[tokio::test]\nasync fn test_full_lifecycle() {\n    let mut actor = FileActor::new(\"test.txt\");\n    let address = ActorAddress::named(\"file-actor\");\n    let broker = InMemoryMessageBroker::new();\n    let mut context = ActorContext::new(address, broker);\n    let mut lifecycle = ActorLifecycle::new();\n\n    // Test pre_start\n    actor.pre_start(&amp;mut context).await.unwrap();\n    lifecycle.transition_to(ActorState::Running);\n    assert_eq!(lifecycle.state(), ActorState::Running);\n\n    // Test message processing\n    actor.handle_message(\n        FileMsg::Write(\"test data\".into()),\n        &amp;mut context\n    ).await.unwrap();\n\n    // Test post_stop\n    lifecycle.transition_to(ActorState::Stopping);\n    actor.post_stop(&amp;mut context).await.unwrap();\n    lifecycle.transition_to(ActorState::Stopped);\n    assert_eq!(lifecycle.state(), ActorState::Stopped);\n}\n</code></pre>"},{"location":"components/rt/guides/actor-development/#property-based-testing","title":"Property-Based Testing","text":"<p>Test actor properties with <code>proptest</code>:</p> <pre><code>#[cfg(test)]\nmod property_tests {\n    use proptest::prelude::*;\n\n    proptest! {\n        #[test]\n        fn counter_always_increases(increments in prop::collection::vec(1..100u64, 1..100)) {\n            // Setup\n            let rt = tokio::runtime::Runtime::new().unwrap();\n            rt.block_on(async {\n                let mut actor = CounterActor { count: 0 };\n                let address = ActorAddress::named(\"prop-counter\");\n                let broker = InMemoryMessageBroker::new();\n                let mut context = ActorContext::new(address, broker);\n\n                let mut expected = 0u64;\n\n                // Apply increments\n                for inc in increments {\n                    actor.handle_message(\n                        CounterMsg::Add(inc),\n                        &amp;mut context\n                    ).await.unwrap();\n                    expected += inc;\n                }\n\n                // Property: count equals sum of increments\n                assert_eq!(actor.count, expected);\n            });\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/guides/actor-development/#next-steps","title":"Next Steps","text":"<p>Congratulations! You now understand actor development deeply. Continue your learning:</p>"},{"location":"components/rt/guides/actor-development/#build-fault-tolerant-systems","title":"\ud83c\udfaf Build Fault-Tolerant Systems","text":"<ul> <li>Supervisor Patterns Guide - Supervision trees and strategies</li> <li>Error Recovery Patterns - Production-ready fault tolerance</li> </ul>"},{"location":"components/rt/guides/actor-development/#master-message-patterns","title":"\ud83d\udce8 Master Message Patterns","text":"<ul> <li>Message Passing Guide - Communication patterns and optimization</li> <li>Performance Optimization - Tuning message throughput</li> </ul>"},{"location":"components/rt/guides/actor-development/#monitor-your-actors","title":"\ud83d\udcca Monitor Your Actors","text":"<ul> <li>Monitoring Guide - Observability and health checks</li> <li>Debugging Actors - Common issues and solutions</li> </ul>"},{"location":"components/rt/guides/actor-development/#architecture-patterns","title":"\ud83c\udfd7\ufe0f Architecture Patterns","text":"<ul> <li>Actor Hierarchies - Multi-level supervision</li> <li>Event Sourcing - State management patterns</li> </ul>"},{"location":"components/rt/guides/actor-development/#summary","title":"Summary","text":"<p>\u2705 Lifecycle Management: pre_start, handle_message, post_stop \u2705 State Patterns: Immutable, mutable, interior mutability, persistence \u2705 Message Design: Commands, queries, events, versioning \u2705 Error Handling: ErrorAction, retries, circuit breakers \u2705 Testing: Unit, integration, lifecycle, property-based  </p> <p>You're now ready to build production-ready actor systems with AirsSys-RT!</p>"},{"location":"components/rt/guides/message-passing/","title":"Message Passing Best Practices","text":"<p>Target Audience: Developers optimizing message patterns and communication in actor systems</p> <p>Guide Type: HOW-TO (task-oriented) - Solutions for message design and performance optimization</p>"},{"location":"components/rt/guides/message-passing/#overview","title":"Overview","text":"<p>This guide covers best practices for designing, implementing, and optimizing message passing in AirsSys RT. Message passing is the fundamental communication mechanism in the actor model, and proper message design directly impacts system performance, maintainability, and reliability.</p> <p>What you'll learn: - How to design efficient message types - Communication patterns for different scenarios - Performance optimization techniques - Error handling strategies in messaging - Type safety and message evolution</p> <p>Prerequisites: - Completed Getting Started - Understanding of Actor Development basics - Familiarity with Rust async/await and channels</p>"},{"location":"components/rt/guides/message-passing/#1-message-design-principles","title":"1. Message Design Principles","text":"<p>Effective message design balances performance, clarity, and maintainability. Follow these principles for optimal results.</p>"},{"location":"components/rt/guides/message-passing/#11-keep-messages-small","title":"1.1 Keep Messages Small","text":"<p>Principle: Small messages improve throughput and reduce memory pressure.</p> <pre><code>use airssys_rt::message::Message;\n\n// \u2705 GOOD - Small, focused message\n#[derive(Debug, Clone)]\npub enum CounterMsg {\n    Increment,\n    Decrement,\n    GetValue(tokio::sync::oneshot::Sender&lt;i32&gt;),\n}\n\nimpl Message for CounterMsg {\n    type Result = ();\n}\n\n// \u274c BAD - Large message with unnecessary data\n#[derive(Debug, Clone)]\npub struct BloatedMsg {\n    pub large_vec: Vec&lt;u8&gt;,           // Large allocation\n    pub metadata: HashMap&lt;String, String&gt;, // Cloned on every send\n    pub timestamp: String,             // Could be computed\n}\n</code></pre> <p>Why it matters: - Smaller messages = faster serialization (if needed) - Reduced memory allocations - Better cache locality - Lower clone costs</p> <p>Performance data (from BENCHMARKING.md \u00a76.2): - Small messages (&lt;64 bytes): ~50-100ns send latency - Medium messages (64-512 bytes): ~100-200ns send latency - Large messages (&gt;512 bytes): ~200ns+ send latency</p>"},{"location":"components/rt/guides/message-passing/#12-immutable-message-data","title":"1.2 Immutable Message Data","text":"<p>Principle: Messages should be immutable to prevent data races and simplify reasoning.</p> <pre><code>// \u2705 GOOD - Immutable message\n#[derive(Debug, Clone)]\npub struct UpdateConfig {\n    pub new_value: String,  // Owned, immutable\n    pub version: u32,\n}\n\n// \u274c BAD - Mutable shared state\npub struct MutableMsg {\n    pub shared_data: Arc&lt;Mutex&lt;Vec&lt;String&gt;&gt;&gt;, // Invites race conditions\n}\n</code></pre> <p>Benefits: - Thread-safe by design - No accidental mutations - Easier to test and debug - Aligns with actor model isolation</p>"},{"location":"components/rt/guides/message-passing/#13-avoid-large-clones-with-arct","title":"1.3 Avoid Large Clones with <code>Arc&lt;T&gt;</code>","text":"<p>Principle: For large data, use <code>Arc&lt;T&gt;</code> to avoid expensive clones.</p> <pre><code>use std::sync::Arc;\n\n// \u2705 GOOD - Share large data efficiently\n#[derive(Debug, Clone)]\npub struct ProcessData {\n    pub data: Arc&lt;Vec&lt;u8&gt;&gt;,  // Cheap clone (ref count increment)\n    pub metadata: String,     // Small, owned\n}\n\nimpl Message for ProcessData {\n    type Result = ();\n}\n\n// Example usage\nlet large_data = vec![0u8; 1_000_000]; // 1MB\nlet msg = ProcessData {\n    data: Arc::new(large_data),\n    metadata: \"sensor_data\".to_string(),\n};\n\n// Clone is cheap - only increments reference count\nlet msg_clone = msg.clone(); // ~10ns, not 1MB copy\n</code></pre> <p>Guidelines: - Use <code>Arc&lt;T&gt;</code> when data &gt; 1KB - Use <code>Arc&lt;T&gt;</code> when sending to multiple actors - Use owned data for small types (&lt;64 bytes) - Consider <code>Arc&lt;[T]&gt;</code> for immutable slices</p> <p>Performance comparison: <pre><code>Clone 1KB Vec&lt;u8&gt;:        ~1,000ns (copy)\nClone Arc&lt;1KB Vec&lt;u8&gt;&gt;:   ~10ns (ref count)\nClone 1MB Vec&lt;u8&gt;:        ~1,000,000ns (copy)\nClone Arc&lt;1MB Vec&lt;u8&gt;&gt;:   ~10ns (ref count)\n</code></pre></p>"},{"location":"components/rt/guides/message-passing/#14-message-type-organization","title":"1.4 Message Type Organization","text":"<p>Principle: Choose between enum messages and separate types based on actor complexity.</p> <p>Pattern A: Enum Messages (Simple Actors)</p> <pre><code>// \u2705 GOOD - Single enum for related operations\n#[derive(Debug, Clone)]\npub enum WorkerMsg {\n    Start,\n    Stop,\n    Process(Arc&lt;Vec&lt;u8&gt;&gt;),\n    Status(tokio::sync::oneshot::Sender&lt;String&gt;),\n}\n\nimpl Message for WorkerMsg {\n    type Result = ();\n}\n</code></pre> <p>Benefits: - Clear API surface - Easy pattern matching - Single message type per actor</p> <p>Pattern B: Separate Types (Complex Actors)</p> <pre><code>// \u2705 GOOD - Separate types for distinct domains\n#[derive(Debug, Clone)]\npub struct StartProcessing {\n    pub config: Arc&lt;Config&gt;,\n}\n\nimpl Message for StartProcessing {\n    type Result = Result&lt;(), String&gt;;\n}\n\n#[derive(Debug, Clone)]\npub struct GetMetrics {\n    pub reply: tokio::sync::oneshot::Sender&lt;Metrics&gt;,\n}\n\nimpl Message for GetMetrics {\n    type Result = ();\n}\n</code></pre> <p>Benefits: - Explicit type signatures - Better for actors with many operations - Easier to evolve independently</p> <p>Choose enum when: - Actor has &lt;10 message types - Messages are closely related - Simple request/response patterns</p> <p>Choose separate types when: - Actor has &gt;10 message types - Messages have different result types - Complex domain logic</p>"},{"location":"components/rt/guides/message-passing/#2-communication-patterns","title":"2. Communication Patterns","text":"<p>Different communication needs require different patterns. Choose the right pattern for your use case.</p>"},{"location":"components/rt/guides/message-passing/#21-fire-and-forget-async-send","title":"2.1 Fire-and-Forget (Async Send)","text":"<p>Use case: Send message without waiting for result.</p> <pre><code>use airssys_rt::actor::{Actor, ActorContext, ActorError};\nuse airssys_rt::message::Message;\n\n#[derive(Debug, Clone)]\npub enum LogMsg {\n    Info(String),\n    Error(String),\n}\n\nimpl Message for LogMsg {\n    type Result = ();\n}\n\npub struct Logger;\n\n#[async_trait::async_trait]\nimpl Actor for Logger {\n    type Message = LogMsg;\n\n    async fn handle(&amp;mut self, msg: Self::Message, _ctx: &amp;ActorContext) -&gt; Result&lt;(), ActorError&gt; {\n        match msg {\n            LogMsg::Info(msg) =&gt; println!(\"[INFO] {}\", msg),\n            LogMsg::Error(msg) =&gt; eprintln!(\"[ERROR] {}\", msg),\n        }\n        Ok(())\n    }\n}\n\n// Usage - fire and forget\nasync fn example(logger_ref: ActorRef&lt;LogMsg&gt;) {\n    // Send without awaiting - fire and forget\n    logger_ref.send(LogMsg::Info(\"Processing started\".to_string())).await.ok();\n\n    // Continue immediately without waiting for log to be processed\n    do_work().await;\n}\n</code></pre> <p>When to use: - Logging, metrics, notifications - One-way commands - When sender doesn't need confirmation - High-throughput scenarios</p> <p>Performance: ~50-100ns send latency (BENCHMARKING.md \u00a76.2)</p>"},{"location":"components/rt/guides/message-passing/#22-requestreply-oneshot-channels","title":"2.2 Request/Reply (Oneshot Channels)","text":"<p>Use case: Send message and wait for response.</p> <pre><code>use tokio::sync::oneshot;\n\n#[derive(Debug, Clone)]\npub enum QueryMsg {\n    GetCount(oneshot::Sender&lt;i32&gt;),\n    GetStatus(oneshot::Sender&lt;String&gt;),\n}\n\nimpl Message for QueryMsg {\n    type Result = ();\n}\n\npub struct Counter {\n    count: i32,\n}\n\n#[async_trait::async_trait]\nimpl Actor for Counter {\n    type Message = QueryMsg;\n\n    async fn handle(&amp;mut self, msg: Self::Message, _ctx: &amp;ActorContext) -&gt; Result&lt;(), ActorError&gt; {\n        match msg {\n            QueryMsg::GetCount(reply) =&gt; {\n                let _ = reply.send(self.count);\n            }\n            QueryMsg::GetStatus(reply) =&gt; {\n                let status = format!(\"Counter at {}\", self.count);\n                let _ = reply.send(status);\n            }\n        }\n        Ok(())\n    }\n}\n\n// Usage - request/reply\nasync fn example(counter_ref: ActorRef&lt;QueryMsg&gt;) -&gt; Result&lt;i32, String&gt; {\n    let (tx, rx) = oneshot::channel();\n\n    counter_ref.send(QueryMsg::GetCount(tx))\n        .await\n        .map_err(|e| format!(\"Send failed: {}\", e))?;\n\n    rx.await\n        .map_err(|e| format!(\"Receive failed: {}\", e))\n}\n</code></pre> <p>When to use: - Queries that need results - Synchronous-style APIs - When caller needs confirmation - RPC-style interactions</p> <p>Pattern variations: <pre><code>// Variation 1: Return Result\n#[derive(Debug, Clone)]\npub struct Compute {\n    pub value: i32,\n    pub reply: oneshot::Sender&lt;Result&lt;i32, String&gt;&gt;,\n}\n\n// Variation 2: Multiple response types\npub enum Response {\n    Success(Data),\n    NotFound,\n    Error(String),\n}\n\n#[derive(Debug, Clone)]\npub struct Query {\n    pub key: String,\n    pub reply: oneshot::Sender&lt;Response&gt;,\n}\n</code></pre></p>"},{"location":"components/rt/guides/message-passing/#23-pubsub-via-messagebroker","title":"2.3 Pub/Sub (Via MessageBroker)","text":"<p>Use case: Broadcast messages to multiple subscribers.</p> <p>Note: MessageBroker is implemented in RT-TASK-007. See broker module for details.</p> <pre><code>use airssys_rt::broker::{MessageBroker, Topic};\nuse std::sync::Arc;\n\n#[derive(Debug, Clone)]\npub struct SensorReading {\n    pub sensor_id: String,\n    pub value: f64,\n    pub timestamp: i64,\n}\n\nimpl Message for SensorReading {\n    type Result = ();\n}\n\n// Publisher\npub struct SensorPublisher {\n    broker: Arc&lt;MessageBroker&lt;SensorReading&gt;&gt;,\n}\n\nimpl SensorPublisher {\n    pub async fn publish_reading(&amp;self, reading: SensorReading) {\n        self.broker.publish(\"sensor.readings\".into(), reading).await;\n    }\n}\n\n// Subscriber\npub struct MetricsCollector {\n    broker: Arc&lt;MessageBroker&lt;SensorReading&gt;&gt;,\n}\n\n#[async_trait::async_trait]\nimpl Actor for MetricsCollector {\n    type Message = SensorReading;\n\n    async fn handle(&amp;mut self, msg: Self::Message, _ctx: &amp;ActorContext) -&gt; Result&lt;(), ActorError&gt; {\n        // Process sensor reading\n        println!(\"Received reading: {} = {}\", msg.sensor_id, msg.value);\n        Ok(())\n    }\n}\n\nasync fn setup_pubsub() {\n    let broker = Arc::new(MessageBroker::new());\n\n    // Subscribe to topic\n    let topic: Topic = \"sensor.readings\".into();\n    let mut subscriber = broker.subscribe(topic.clone()).await;\n\n    // Spawn subscriber task\n    tokio::spawn(async move {\n        while let Some(reading) = subscriber.recv().await {\n            // Process reading\n            println!(\"Subscriber received: {:?}\", reading);\n        }\n    });\n\n    // Publish messages\n    broker.publish(topic, SensorReading {\n        sensor_id: \"temp-001\".to_string(),\n        value: 23.5,\n        timestamp: 1234567890,\n    }).await;\n}\n</code></pre> <p>When to use: - Event notifications - Broadcasting state changes - Decoupling publishers from subscribers - Fan-out patterns</p> <p>Performance: ~100-200ns per subscriber (BENCHMARKING.md \u00a76.2.3)</p>"},{"location":"components/rt/guides/message-passing/#24-broadcast-patterns","title":"2.4 Broadcast Patterns","text":"<p>Use case: Send same message to multiple actors.</p> <pre><code>use airssys_rt::actor::ActorRef;\n\nasync fn broadcast_shutdown(workers: Vec&lt;ActorRef&lt;WorkerMsg&gt;&gt;) {\n    for worker in workers {\n        worker.send(WorkerMsg::Stop).await.ok();\n    }\n}\n\n// Parallel broadcast with timeout\nasync fn parallel_broadcast(\n    workers: Vec&lt;ActorRef&lt;WorkerMsg&gt;&gt;,\n    timeout: Duration,\n) -&gt; Result&lt;(), String&gt; {\n    use tokio::time::timeout as tokio_timeout;\n\n    let futures: Vec&lt;_&gt; = workers.iter()\n        .map(|w| w.send(WorkerMsg::Stop))\n        .collect();\n\n    tokio_timeout(timeout, futures::future::join_all(futures))\n        .await\n        .map_err(|_| \"Broadcast timeout\")?;\n\n    Ok(())\n}\n</code></pre> <p>When to use: - Shutdown/restart commands - Configuration updates - Coordinated state changes</p>"},{"location":"components/rt/guides/message-passing/#25-scattergather-patterns","title":"2.5 Scatter/Gather Patterns","text":"<p>Use case: Send to multiple actors and collect responses.</p> <pre><code>async fn scatter_gather_query(\n    workers: Vec&lt;ActorRef&lt;QueryMsg&gt;&gt;,\n) -&gt; Vec&lt;i32&gt; {\n    let mut replies = Vec::new();\n\n    for worker in workers {\n        let (tx, rx) = oneshot::channel();\n        if worker.send(QueryMsg::GetCount(tx)).await.is_ok() {\n            if let Ok(count) = rx.await {\n                replies.push(count);\n            }\n        }\n    }\n\n    replies\n}\n\n// Parallel scatter/gather with timeout\nasync fn parallel_scatter_gather(\n    workers: Vec&lt;ActorRef&lt;QueryMsg&gt;&gt;,\n    timeout: Duration,\n) -&gt; Result&lt;Vec&lt;i32&gt;, String&gt; {\n    use tokio::time::timeout as tokio_timeout;\n\n    let futures: Vec&lt;_&gt; = workers.iter().map(|worker| async {\n        let (tx, rx) = oneshot::channel();\n        worker.send(QueryMsg::GetCount(tx)).await.ok()?;\n        rx.await.ok()\n    }).collect();\n\n    let results = tokio_timeout(timeout, futures::future::join_all(futures))\n        .await\n        .map_err(|_| \"Gather timeout\")?;\n\n    Ok(results.into_iter().flatten().collect())\n}\n</code></pre> <p>When to use: - Aggregating data from multiple sources - Parallel query processing - Consensus algorithms - Load distribution</p>"},{"location":"components/rt/guides/message-passing/#3-performance-optimization","title":"3. Performance Optimization","text":"<p>Optimize message passing for high-throughput scenarios.</p>"},{"location":"components/rt/guides/message-passing/#31-zero-copy-patterns-with-arc","title":"3.1 Zero-Copy Patterns with Arc","text":"<p>Strategy: Share data without copying using <code>Arc&lt;T&gt;</code>.</p> <pre><code>use std::sync::Arc;\n\n// Efficient data sharing\npub struct DataProcessor;\n\n#[async_trait::async_trait]\nimpl Actor for DataProcessor {\n    type Message = ProcessData;\n\n    async fn handle(&amp;mut self, msg: Self::Message, ctx: &amp;ActorContext) -&gt; Result&lt;(), ActorError&gt; {\n        // Data is shared, not copied\n        let data_ref = &amp;msg.data; // Arc&lt;Vec&lt;u8&gt;&gt;\n\n        // Send to another actor - no copy!\n        let downstream_msg = ProcessData {\n            data: Arc::clone(&amp;msg.data), // Just ref count increment\n            metadata: \"processed\".to_string(),\n        };\n\n        // downstream_actor.send(downstream_msg).await?;\n        Ok(())\n    }\n}\n</code></pre> <p>Performance gain: - 1MB message copy: ~1ms - 1MB Arc clone: ~10ns - 100x faster for large data</p>"},{"location":"components/rt/guides/message-passing/#32-batching-messages","title":"3.2 Batching Messages","text":"<p>Strategy: Process multiple messages together to reduce per-message overhead.</p> <pre><code>#[derive(Debug, Clone)]\npub enum BatchedMsg {\n    Single(String),\n    Batch(Vec&lt;String&gt;),\n}\n\nimpl Message for BatchedMsg {\n    type Result = ();\n}\n\npub struct BatchProcessor {\n    batch: Vec&lt;String&gt;,\n    batch_size: usize,\n}\n\nimpl BatchProcessor {\n    fn new(batch_size: usize) -&gt; Self {\n        Self {\n            batch: Vec::with_capacity(batch_size),\n            batch_size,\n        }\n    }\n\n    async fn process_batch(&amp;mut self) {\n        if !self.batch.is_empty() {\n            // Process entire batch at once\n            println!(\"Processing batch of {} items\", self.batch.len());\n            // ... bulk processing logic ...\n            self.batch.clear();\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl Actor for BatchProcessor {\n    type Message = BatchedMsg;\n\n    async fn handle(&amp;mut self, msg: Self::Message, _ctx: &amp;ActorContext) -&gt; Result&lt;(), ActorError&gt; {\n        match msg {\n            BatchedMsg::Single(item) =&gt; {\n                self.batch.push(item);\n                if self.batch.len() &gt;= self.batch_size {\n                    self.process_batch().await;\n                }\n            }\n            BatchedMsg::Batch(items) =&gt; {\n                self.batch.extend(items);\n                if self.batch.len() &gt;= self.batch_size {\n                    self.process_batch().await;\n                }\n            }\n        }\n        Ok(())\n    }\n}\n</code></pre> <p>Performance gain: - Individual processing: ~1,000ns per message - Batched processing: ~100ns per message (10x improvement) - Trade-off: Increased latency for batch accumulation</p> <p>When to use: - Database writes - Network requests - File I/O operations - High-volume data processing</p>"},{"location":"components/rt/guides/message-passing/#33-priority-messages","title":"3.3 Priority Messages","text":"<p>Strategy: Process critical messages before normal messages.</p> <p>Note: Priority messaging is available via custom mailbox implementations.</p> <pre><code>use airssys_rt::mailbox::{Mailbox, MailboxConfig};\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Priority {\n    High,\n    Normal,\n}\n\n#[derive(Debug, Clone)]\npub struct PriorityMsg {\n    pub priority: Priority,\n    pub data: String,\n}\n\nimpl Message for PriorityMsg {\n    type Result = ();\n}\n\n// Custom mailbox with priority handling\npub struct PriorityMailbox {\n    high_priority: Vec&lt;PriorityMsg&gt;,\n    normal: Vec&lt;PriorityMsg&gt;,\n}\n\nimpl PriorityMailbox {\n    pub fn next_message(&amp;mut self) -&gt; Option&lt;PriorityMsg&gt; {\n        // Always process high priority first\n        if let Some(msg) = self.high_priority.pop() {\n            Some(msg)\n        } else {\n            self.normal.pop()\n        }\n    }\n}\n</code></pre> <p>When to use: - Health check messages (high priority) - Shutdown commands (high priority) - Control plane vs data plane separation - Real-time vs batch processing</p>"},{"location":"components/rt/guides/message-passing/#34-message-pooling","title":"3.4 Message Pooling","text":"<p>Strategy: Reuse message allocations for extremely high-throughput scenarios.</p> <p>Note: Message pooling is an advanced optimization. Only use when profiling shows allocation overhead.</p> <pre><code>use std::sync::Arc;\nuse parking_lot::Mutex;\n\n// Object pool for message data\npub struct MessagePool&lt;T&gt; {\n    pool: Arc&lt;Mutex&lt;Vec&lt;Box&lt;T&gt;&gt;&gt;&gt;,\n}\n\nimpl&lt;T: Default&gt; MessagePool&lt;T&gt; {\n    pub fn new(capacity: usize) -&gt; Self {\n        let mut pool = Vec::with_capacity(capacity);\n        for _ in 0..capacity {\n            pool.push(Box::new(T::default()));\n        }\n\n        Self {\n            pool: Arc::new(Mutex::new(pool)),\n        }\n    }\n\n    pub fn acquire(&amp;self) -&gt; Option&lt;Box&lt;T&gt;&gt; {\n        self.pool.lock().pop()\n    }\n\n    pub fn release(&amp;self, mut item: Box&lt;T&gt;) {\n        *item = T::default(); // Reset\n        self.pool.lock().push(item);\n    }\n}\n\n// Example usage\npub struct PooledData {\n    pub buffer: Vec&lt;u8&gt;,\n}\n\nimpl Default for PooledData {\n    fn default() -&gt; Self {\n        Self {\n            buffer: Vec::with_capacity(1024),\n        }\n    }\n}\n</code></pre> <p>Performance gain: - Without pooling: ~1,000ns per allocation - With pooling: ~100ns per acquisition - 10x faster for allocation-heavy workloads</p> <p>When to use: - Message rates &gt;100,000/sec - Large message buffers - Real-time systems with strict latency requirements - Only after profiling confirms allocation bottleneck</p>"},{"location":"components/rt/guides/message-passing/#35-performance-benchmarks","title":"3.5 Performance Benchmarks","text":"<p>Reference data from BENCHMARKING.md \u00a76.2:</p> <pre><code>Message Send Latency:\n- Small message (&lt;64B):     50-100ns\n- Medium message (64-512B): 100-200ns\n- Large message (&gt;512B):    200ns+\n\nMessage Throughput:\n- Single actor:             1M+ messages/sec\n- With Arc&lt;T&gt; sharing:      2M+ messages/sec\n- Batched (100/batch):      5M+ messages/sec\n\nChannel Performance:\n- Unbounded send:           ~50ns\n- Bounded send (empty):     ~75ns\n- Bounded send (full):      ~1,000ns (backpressure)\n</code></pre> <p>Optimization priorities: 1. Profile first - measure before optimizing 2. Use Arc for large data (&gt;1KB) 3. Batch when latency tolerance allows 4. Consider priority for critical messages 5. Pool only when allocations are proven bottleneck"},{"location":"components/rt/guides/message-passing/#4-error-handling-in-messaging","title":"4. Error Handling in Messaging","text":"<p>Robust error handling ensures system reliability.</p>"},{"location":"components/rt/guides/message-passing/#41-send-failures","title":"4.1 Send Failures","text":"<p>Scenario: Actor stopped or mailbox full.</p> <pre><code>use airssys_rt::actor::ActorRef;\n\nasync fn robust_send(actor_ref: &amp;ActorRef&lt;WorkerMsg&gt;) -&gt; Result&lt;(), String&gt; {\n    actor_ref.send(WorkerMsg::Process(Arc::new(vec![1, 2, 3])))\n        .await\n        .map_err(|e| format!(\"Send failed: {}\", e))?;\n\n    Ok(())\n}\n\n// Handle specific error types\nasync fn handle_send_errors(actor_ref: &amp;ActorRef&lt;WorkerMsg&gt;) {\n    match actor_ref.send(WorkerMsg::Start).await {\n        Ok(_) =&gt; println!(\"Message sent successfully\"),\n        Err(e) =&gt; {\n            eprintln!(\"Send failed: {}\", e);\n            // Common causes:\n            // - Actor stopped\n            // - Mailbox full (bounded mailbox)\n            // - System shutdown\n\n            // Recovery strategies:\n            // 1. Retry with backoff\n            // 2. Log and continue\n            // 3. Escalate to supervisor\n            // 4. Use circuit breaker pattern\n        }\n    }\n}\n</code></pre> <p>Error handling strategies:</p> <p>Strategy 1: Retry with Exponential Backoff <pre><code>use tokio::time::{sleep, Duration};\n\nasync fn send_with_retry(\n    actor_ref: &amp;ActorRef&lt;WorkerMsg&gt;,\n    msg: WorkerMsg,\n    max_retries: u32,\n) -&gt; Result&lt;(), String&gt; {\n    let mut delay = Duration::from_millis(10);\n\n    for attempt in 0..max_retries {\n        match actor_ref.send(msg.clone()).await {\n            Ok(_) =&gt; return Ok(()),\n            Err(e) if attempt &lt; max_retries - 1 =&gt; {\n                eprintln!(\"Send failed (attempt {}): {}\", attempt + 1, e);\n                sleep(delay).await;\n                delay *= 2; // Exponential backoff\n            }\n            Err(e) =&gt; return Err(format!(\"Send failed after {} retries: {}\", max_retries, e)),\n        }\n    }\n\n    Err(\"Max retries exceeded\".to_string())\n}\n</code></pre></p> <p>Strategy 2: Circuit Breaker <pre><code>pub struct CircuitBreaker {\n    failure_count: u32,\n    threshold: u32,\n    state: CircuitState,\n}\n\npub enum CircuitState {\n    Closed,   // Normal operation\n    Open,     // Failing, reject requests\n    HalfOpen, // Testing recovery\n}\n\nimpl CircuitBreaker {\n    pub async fn send_protected(\n        &amp;mut self,\n        actor_ref: &amp;ActorRef&lt;WorkerMsg&gt;,\n        msg: WorkerMsg,\n    ) -&gt; Result&lt;(), String&gt; {\n        match self.state {\n            CircuitState::Open =&gt; {\n                Err(\"Circuit breaker open\".to_string())\n            }\n            CircuitState::Closed | CircuitState::HalfOpen =&gt; {\n                match actor_ref.send(msg).await {\n                    Ok(_) =&gt; {\n                        self.on_success();\n                        Ok(())\n                    }\n                    Err(e) =&gt; {\n                        self.on_failure();\n                        Err(format!(\"Send failed: {}\", e))\n                    }\n                }\n            }\n        }\n    }\n\n    fn on_success(&amp;mut self) {\n        self.failure_count = 0;\n        self.state = CircuitState::Closed;\n    }\n\n    fn on_failure(&amp;mut self) {\n        self.failure_count += 1;\n        if self.failure_count &gt;= self.threshold {\n            self.state = CircuitState::Open;\n        }\n    }\n}\n</code></pre></p>"},{"location":"components/rt/guides/message-passing/#42-timeout-patterns","title":"4.2 Timeout Patterns","text":"<p>Strategy: Set time limits on request/reply operations.</p> <pre><code>use tokio::time::{timeout, Duration};\n\nasync fn query_with_timeout(\n    actor_ref: &amp;ActorRef&lt;QueryMsg&gt;,\n    timeout_duration: Duration,\n) -&gt; Result&lt;i32, String&gt; {\n    let (tx, rx) = oneshot::channel();\n\n    // Send message\n    actor_ref.send(QueryMsg::GetCount(tx))\n        .await\n        .map_err(|e| format!(\"Send failed: {}\", e))?;\n\n    // Wait for response with timeout\n    timeout(timeout_duration, rx)\n        .await\n        .map_err(|_| \"Request timeout\".to_string())?\n        .map_err(|_| \"Reply channel closed\".to_string())\n}\n\n// Usage\nasync fn example(actor_ref: ActorRef&lt;QueryMsg&gt;) {\n    match query_with_timeout(&amp;actor_ref, Duration::from_secs(5)).await {\n        Ok(count) =&gt; println!(\"Count: {}\", count),\n        Err(e) =&gt; eprintln!(\"Query failed: {}\", e),\n    }\n}\n</code></pre> <p>Timeout guidelines: - Fast queries: 100ms - 1s - Normal operations: 1s - 5s - Long-running tasks: 30s - 5min - Always set timeouts for request/reply patterns</p>"},{"location":"components/rt/guides/message-passing/#43-dead-letter-handling","title":"4.3 Dead Letter Handling","text":"<p>Note: Dead letter queues are a planned feature (future RT task). Current approach: log and handle manually.</p> <p>Current approach: <pre><code>async fn send_with_dead_letter_logging(\n    actor_ref: &amp;ActorRef&lt;WorkerMsg&gt;,\n    msg: WorkerMsg,\n) {\n    if let Err(e) = actor_ref.send(msg.clone()).await {\n        // Log dead letter\n        eprintln!(\"DEAD LETTER: Failed to send {:?}: {}\", msg, e);\n\n        // Optional: persist for later replay\n        // dead_letter_store.save(msg).await;\n    }\n}\n</code></pre></p> <p>Planned feature (future): <pre><code>// Future: Automatic dead letter queue\npub struct DeadLetterQueue&lt;M: Message&gt; {\n    queue: Vec&lt;M&gt;,\n}\n\n// Messages that fail to send will be automatically queued\n// for manual inspection or replay\n</code></pre></p>"},{"location":"components/rt/guides/message-passing/#5-type-safety-and-message-versioning","title":"5. Type Safety and Message Versioning","text":"<p>Maintain type safety and evolve messages over time.</p>"},{"location":"components/rt/guides/message-passing/#51-strong-typing-benefits","title":"5.1 Strong Typing Benefits","text":"<p>Principle: Use Rust's type system to prevent message errors at compile time.</p> <pre><code>// \u2705 GOOD - Strong types prevent errors\n#[derive(Debug, Clone)]\npub struct UpdateConfig {\n    pub timeout: Duration,      // Type-safe duration\n    pub max_retries: u32,       // Unsigned, can't be negative\n    pub endpoint: Url,          // Validated URL type\n}\n\n// \u274c BAD - Weak types allow invalid states\npub struct WeakConfig {\n    pub timeout_ms: i32,        // Could be negative!\n    pub max_retries: String,    // Should be a number\n    pub endpoint: String,       // Could be invalid URL\n}\n\n// \u2705 GOOD - Enums prevent invalid states\n#[derive(Debug, Clone)]\npub enum ConnectionState {\n    Connected { session_id: String },\n    Disconnected { reason: String },\n    Reconnecting { attempt: u32 },\n}\n\n// \u274c BAD - Booleans create invalid combinations\npub struct WeakState {\n    pub connected: bool,\n    pub disconnected: bool,     // Both could be true!\n    pub session_id: Option&lt;String&gt;, // Could be Some when disconnected!\n}\n</code></pre> <p>Type safety checklist: - Use enums for finite states - Use newtypes for domain-specific values - Use Result for operations that can fail - Use Option only when absence is meaningful - Avoid stringly-typed data"},{"location":"components/rt/guides/message-passing/#52-message-evolution-strategies","title":"5.2 Message Evolution Strategies","text":"<p>Strategy 1: Versioned Messages</p> <pre><code>#[derive(Debug, Clone)]\npub enum ConfigMsg {\n    V1(ConfigV1),\n    V2(ConfigV2),\n}\n\n#[derive(Debug, Clone)]\npub struct ConfigV1 {\n    pub timeout: Duration,\n}\n\n#[derive(Debug, Clone)]\npub struct ConfigV2 {\n    pub timeout: Duration,\n    pub max_retries: u32,  // New field\n}\n\nimpl Message for ConfigMsg {\n    type Result = ();\n}\n\n// Handler supports both versions\n#[async_trait::async_trait]\nimpl Actor for ConfigurableActor {\n    type Message = ConfigMsg;\n\n    async fn handle(&amp;mut self, msg: Self::Message, _ctx: &amp;ActorContext) -&gt; Result&lt;(), ActorError&gt; {\n        match msg {\n            ConfigMsg::V1(v1) =&gt; {\n                // Handle old version\n                self.timeout = v1.timeout;\n                self.max_retries = 3; // Default\n            }\n            ConfigMsg::V2(v2) =&gt; {\n                // Handle new version\n                self.timeout = v2.timeout;\n                self.max_retries = v2.max_retries;\n            }\n        }\n        Ok(())\n    }\n}\n</code></pre> <p>Strategy 2: Non-Breaking Additions</p> <pre><code>#[derive(Debug, Clone)]\npub struct ExtensibleConfig {\n    // Required fields (never remove these)\n    pub timeout: Duration,\n\n    // Optional new fields (non-breaking)\n    pub max_retries: Option&lt;u32&gt;,\n    pub endpoint: Option&lt;String&gt;,\n}\n\nimpl ExtensibleConfig {\n    pub fn new(timeout: Duration) -&gt; Self {\n        Self {\n            timeout,\n            max_retries: None,\n            endpoint: None,\n        }\n    }\n\n    pub fn with_retries(mut self, retries: u32) -&gt; Self {\n        self.max_retries = Some(retries);\n        self\n    }\n}\n</code></pre> <p>Strategy 3: Builder Pattern for Complex Messages</p> <pre><code>pub struct ComplexMsgBuilder {\n    required_field: Option&lt;String&gt;,\n    optional_field1: Option&lt;u32&gt;,\n    optional_field2: Option&lt;Duration&gt;,\n}\n\nimpl ComplexMsgBuilder {\n    pub fn new(required: String) -&gt; Self {\n        Self {\n            required_field: Some(required),\n            optional_field1: None,\n            optional_field2: None,\n        }\n    }\n\n    pub fn with_field1(mut self, value: u32) -&gt; Self {\n        self.optional_field1 = Some(value);\n        self\n    }\n\n    pub fn with_field2(mut self, value: Duration) -&gt; Self {\n        self.optional_field2 = Some(value);\n        self\n    }\n\n    pub fn build(self) -&gt; ComplexMsg {\n        ComplexMsg {\n            required: self.required_field.expect(\"required field missing\"),\n            optional1: self.optional_field1.unwrap_or(10),\n            optional2: self.optional_field2.unwrap_or(Duration::from_secs(30)),\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct ComplexMsg {\n    required: String,\n    optional1: u32,\n    optional2: Duration,\n}\n\nimpl Message for ComplexMsg {\n    type Result = ();\n}\n\n// Usage\nlet msg = ComplexMsgBuilder::new(\"value\".to_string())\n    .with_field1(42)\n    .build();\n</code></pre>"},{"location":"components/rt/guides/message-passing/#53-backward-compatibility-patterns","title":"5.3 Backward Compatibility Patterns","text":"<p>Pattern 1: Default Values <pre><code>#[derive(Debug, Clone)]\npub struct ConfigV2 {\n    pub timeout: Duration,\n\n    #[serde(default = \"default_max_retries\")]\n    pub max_retries: u32,\n}\n\nfn default_max_retries() -&gt; u32 {\n    3\n}\n</code></pre></p> <p>Pattern 2: Conversion Traits <pre><code>impl From&lt;ConfigV1&gt; for ConfigV2 {\n    fn from(v1: ConfigV1) -&gt; Self {\n        Self {\n            timeout: v1.timeout,\n            max_retries: 3, // Sensible default\n        }\n    }\n}\n\n// Upgrade messages automatically\nlet v1_msg = ConfigV1 { timeout: Duration::from_secs(10) };\nlet v2_msg: ConfigV2 = v1_msg.into();\n</code></pre></p> <p>Pattern 3: Feature Flags <pre><code>#[derive(Debug, Clone)]\npub struct FeatureConfig {\n    pub timeout: Duration,\n\n    #[cfg(feature = \"advanced\")]\n    pub circuit_breaker: CircuitBreakerConfig,\n\n    #[cfg(feature = \"advanced\")]\n    pub retry_policy: RetryPolicy,\n}\n</code></pre></p>"},{"location":"components/rt/guides/message-passing/#summary","title":"Summary","text":"<p>Message Design Principles: - Keep messages small (&lt;64 bytes ideal) - Use immutable data structures - Share large data with <code>Arc&lt;T&gt;</code> - Choose enum vs separate types based on complexity</p> <p>Communication Patterns: - Fire-and-forget: One-way commands, logging - Request/reply: Queries, RPC-style interactions - Pub/Sub: Event broadcasting, decoupling - Broadcast: Multiple recipients, same message - Scatter/gather: Parallel queries, aggregation</p> <p>Performance Optimization: - Use <code>Arc&lt;T&gt;</code> for zero-copy sharing (100x faster for large data) - Batch messages for high throughput (10x improvement) - Implement priority queues for critical messages - Pool objects only after profiling confirms bottleneck - Reference BENCHMARKING.md \u00a76.2 for performance targets</p> <p>Error Handling: - Handle send failures with retry and backoff - Always use timeouts for request/reply - Log dead letters for debugging - Implement circuit breakers for failing actors</p> <p>Type Safety: - Use strong types to prevent runtime errors - Version messages for backward compatibility - Use builder patterns for complex messages - Leverage Rust's type system for correctness</p> <p>Performance Reference (BENCHMARKING.md \u00a76.2): - Small message send: 50-100ns - Arc clone vs copy: 10ns vs 1ms (100x) - Single actor throughput: 1M+ msg/sec - Batched throughput: 5M+ msg/sec</p> <p>Next Steps: - See message_patterns.rs for working examples - Review Actor Development for message handling patterns - Check Supervisor Patterns for error recovery integration - Consult BENCHMARKING.md for performance tuning guidance</p> <p>Related Documentation: - Getting Started - Basic message passing - Actor Development - Message handling implementation - Supervisor Patterns - Error recovery with messages - BENCHMARKING.md \u00a76.2 - Message passing performance data - MessageBroker API - Pub/sub implementation details</p>"},{"location":"components/rt/guides/supervisor-patterns/","title":"Supervisor Patterns Guide","text":"<p>This guide teaches you how to build fault-tolerant systems using supervision trees. You'll learn the \"let it crash\" philosophy, restart strategies, supervision hierarchies, and health monitoring integration.</p> <p>Prerequisites: - Completed Getting Started - Understanding of basic Rust async programming - Familiarity with error handling patterns</p> <p>What You'll Learn: - \"Let it crash\" philosophy and when to use it - Restart strategies (OneForOne, OneForAll, RestForOne) - Supervision tree patterns (flat, hierarchical) - Child specification and factory patterns - Health monitoring integration</p> <p>Note: This guide documents the current supervisor API (RT-TASK-009). A builder pattern API (RT-TASK-013) is planned for future release.</p>"},{"location":"components/rt/guides/supervisor-patterns/#1-supervision-philosophy","title":"1. Supervision Philosophy","text":""},{"location":"components/rt/guides/supervisor-patterns/#the-let-it-crash-approach","title":"The \"Let It Crash\" Approach","text":"<p>Instead of defensive programming with extensive error handling, let actors fail and rely on supervisors to restart them with clean state.</p> <p>Traditional Approach (Defensive): <pre><code>// \u274c Overly defensive - cluttered with error handling\nasync fn handle_message(&amp;mut self, msg: Message) -&gt; Result&lt;()&gt; {\n    if let Some(connection) = &amp;self.connection {\n        if connection.is_valid() {\n            if let Ok(data) = connection.read().await {\n                if data.is_valid() {\n                    self.process(data)?;\n                } else {\n                    self.reconnect()?;\n                }\n            } else {\n                self.reconnect()?;\n            }\n        } else {\n            self.reconnect()?;\n        }\n    } else {\n        self.connect()?;\n    }\n    Ok(())\n}\n</code></pre></p> <p>Supervision Approach (Let It Crash): <pre><code>use airssys_rt::supervisor::Child;\nuse async_trait::async_trait;\n\n// \u2705 Simple - let supervisor handle failures\nstruct Worker {\n    connection: Option&lt;Connection&gt;,\n}\n\n#[async_trait]\nimpl Child for Worker {\n    type Error = WorkerError;\n\n    async fn start(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {\n        // Supervisor ensures we always start with fresh connection\n        self.connection = Some(Connection::new().await?);\n        Ok(())\n    }\n\n    async fn stop(&amp;mut self, timeout: Duration) -&gt; Result&lt;(), Self::Error&gt; {\n        if let Some(conn) = &amp;self.connection {\n            conn.close().await?;\n        }\n        Ok(())\n    }\n}\n\n// Main processing logic - if this fails, supervisor restarts us\nasync fn process_work(&amp;mut self) -&gt; Result&lt;()&gt; {\n    let connection = self.connection.as_ref()\n        .ok_or(Error::NotConnected)?;\n\n    let data = connection.read().await?;\n    self.process(data)?;  // If this fails, supervisor restarts us\n    Ok(())\n}\n</code></pre></p> <p>Benefits: - Simpler code: Less error handling clutter - Clean state: Restart gives fresh state - Fault isolation: Failures don't cascade - Self-healing: System automatically recovers</p>"},{"location":"components/rt/guides/supervisor-patterns/#when-to-use-supervisors-vs-defensive-programming","title":"When to Use Supervisors vs Defensive Programming","text":"<p>Use Supervisors When: - Errors indicate corrupted state (restart needed) - External dependencies fail (network, database) - Resource exhaustion (memory, file handles) - Recovery requires reinitialization</p> <p>Use Defensive Programming When: - Expected errors (user input validation) - Recoverable conditions (retry-able operations) - Performance-critical paths (avoid restart overhead) - Errors don't indicate state corruption</p> <p>Example Decision Tree: <pre><code>Error Occurred\n    \u251c\u2500 Is state corrupted? \n    \u2502   \u2514\u2500 YES \u2192 Let it crash (supervisor restart)\n    \u2502\n    \u251c\u2500 Is it a temporary failure?\n    \u2502   \u2514\u2500 YES \u2192 Retry with backoff\n    \u2502\n    \u251c\u2500 Is it expected/valid input?\n    \u2502   \u2514\u2500 YES \u2192 Handle defensively\n    \u2502\n    \u2514\u2500 Is it a resource issue?\n        \u2514\u2500 YES \u2192 Let it crash (supervisor restart)\n</code></pre></p>"},{"location":"components/rt/guides/supervisor-patterns/#fault-isolation-through-supervision-trees","title":"Fault Isolation Through Supervision Trees","text":"<p>Supervision trees prevent cascading failures by isolating faults:</p> <pre><code>                   Root Supervisor\n                         \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502                \u2502                \u2502\n   WebServer        Database          Cache\n   Supervisor       Supervisor      Supervisor\n        \u2502                \u2502                \u2502\n    \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510      \u250c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2510\nWorker Worker    Conn  Conn      Read  Write\n Pool  Pool     Pool  Pool      Cache Cache\n</code></pre> <p>Isolation Benefits: - Web server failure doesn't affect database - Individual worker failure doesn't crash server - Cache failure doesn't break core functionality</p>"},{"location":"components/rt/guides/supervisor-patterns/#2-restart-strategies-in-practice","title":"2. Restart Strategies in Practice","text":""},{"location":"components/rt/guides/supervisor-patterns/#oneforone-independent-workers","title":"OneForOne: Independent Workers","text":"<p>Use When: - Workers are independent - One failure shouldn't affect others - Examples: HTTP request handlers, background jobs</p> <p>Pattern: <pre><code>use airssys_rt::prelude::*;\n\n// Independent worker actors\nstruct HttpWorker {\n    request_count: u64,\n}\n\n// Supervisor with OneForOne strategy\nlet supervisor = SupervisorNode::new(\n    \"http-workers\",\n    OneForOne,  // Each worker restarts independently\n    RestartPolicy::Permanent,  // Always restart\n);\n\n// Spawn multiple independent workers\nfor i in 0..10 {\n    supervisor.spawn_child(\n        format!(\"worker-{}\", i),\n        HttpWorker { request_count: 0 },\n    ).await?;\n}\n</code></pre></p> <p>Behavior: - Worker-3 crashes \u2192 Only Worker-3 restarts - Other workers continue unaffected - No cascading failures</p> <p>Real-World Example: HTTP Server <pre><code>struct RequestHandler {\n    id: usize,\n    processed: u64,\n}\n\nimpl Actor for RequestHandler {\n    type Message = HttpRequest;\n    type Error = HandlerError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        request: Self::Message,\n        _ctx: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        // Process request\n        let response = self.process_request(request)?;\n\n        self.processed += 1;\n        Ok(())\n    }\n}\n\n// Setup supervisor with OneForOne\nlet http_supervisor = SupervisorNode::new(\n    \"http-server\",\n    OneForOne,  // Independent request handlers\n    RestartPolicy::Permanent,\n);\n\n// Spawn worker pool\nfor id in 0..num_cpus::get() {\n    http_supervisor.spawn_child(\n        format!(\"handler-{}\", id),\n        RequestHandler { id, processed: 0 },\n    ).await?;\n}\n</code></pre></p>"},{"location":"components/rt/guides/supervisor-patterns/#oneforall-tightly-coupled-services","title":"OneForAll: Tightly Coupled Services","text":"<p>Use When: - Services depend on each other - Inconsistent state if one fails - Examples: Transaction processors, coordinated caches</p> <p>Pattern: <pre><code>// Tightly coupled services\nstruct OrderProcessor { /* ... */ }\nstruct InventoryManager { /* ... */ }\nstruct PaymentGateway { /* ... */ }\n\n// Supervisor with OneForAll strategy\nlet supervisor = SupervisorNode::new(\n    \"transaction-services\",\n    OneForAll,  // All services restart together\n    RestartPolicy::Permanent,\n);\n\nsupervisor.spawn_child(\"orders\", OrderProcessor::new()).await?;\nsupervisor.spawn_child(\"inventory\", InventoryManager::new()).await?;\nsupervisor.spawn_child(\"payment\", PaymentGateway::new()).await?;\n</code></pre></p> <p>Behavior: - Payment gateway crashes \u2192 All three services restart - Ensures consistent state across services - Prevents partial transaction state</p> <p>Real-World Example: Trading System <pre><code>struct MarketDataFeed { positions: HashMap&lt;String, Position&gt; }\nstruct RiskCalculator { limits: HashMap&lt;String, Limit&gt; }\nstruct OrderExecutor { pending: Vec&lt;Order&gt; }\n\n// All must be consistent - restart together\nlet trading_supervisor = SupervisorNode::new(\n    \"trading-system\",\n    OneForAll,  // Restart all on any failure\n    RestartPolicy::Permanent,\n);\n\ntrading_supervisor.spawn_child(\"market-data\", MarketDataFeed::new()).await?;\ntrading_supervisor.spawn_child(\"risk-calc\", RiskCalculator::new()).await?;\ntrading_supervisor.spawn_child(\"executor\", OrderExecutor::new()).await?;\n</code></pre></p>"},{"location":"components/rt/guides/supervisor-patterns/#restforone-pipelinesequential-dependencies","title":"RestForOne: Pipeline/Sequential Dependencies","text":"<p>Use When: - Services form a pipeline - Later stages depend on earlier ones - Examples: Data processing pipelines, message queues</p> <p>Pattern: <pre><code>// Pipeline stages\nstruct DataIngestion { /* ... */ }\nstruct DataValidation { /* ... */ }\nstruct DataTransform { /* ... */ }\nstruct DataStorage { /* ... */ }\n\n// Supervisor with RestForOne strategy\nlet supervisor = SupervisorNode::new(\n    \"data-pipeline\",\n    RestForOne,  // Restart this and following children\n    RestartPolicy::Permanent,\n);\n\n// Order matters! Earlier stages first\nsupervisor.spawn_child(\"ingestion\", DataIngestion::new()).await?;\nsupervisor.spawn_child(\"validation\", DataValidation::new()).await?;\nsupervisor.spawn_child(\"transform\", DataTransform::new()).await?;\nsupervisor.spawn_child(\"storage\", DataStorage::new()).await?;\n</code></pre></p> <p>Behavior: - Validation crashes \u2192 Restart validation, transform, storage - Ingestion keeps running (not affected) - Transform crashes \u2192 Restart only transform and storage - Maintains pipeline order</p> <p>Real-World Example: ETL Pipeline <pre><code>struct Extractor { source: DataSource }\nstruct Transformer { rules: Vec&lt;Rule&gt; }\nstruct Loader { destination: Database }\n\n// Sequential dependency: Extract \u2192 Transform \u2192 Load\nlet etl_supervisor = SupervisorNode::new(\n    \"etl-pipeline\",\n    RestForOne,  // Pipeline restart semantics\n    RestartPolicy::Transient,  // Only restart on error\n);\n\netl_supervisor.spawn_child(\"extractor\", Extractor::new()).await?;\netl_supervisor.spawn_child(\"transformer\", Transformer::new()).await?;\netl_supervisor.spawn_child(\"loader\", Loader::new()).await?;\n</code></pre></p>"},{"location":"components/rt/guides/supervisor-patterns/#strategy-selection-decision-tree","title":"Strategy Selection Decision Tree","text":"<pre><code>What relationship do children have?\n\n\u251c\u2500 Independent workers?\n\u2502   \u2514\u2500 Use OneForOne\n\u2502       \u2022 Web request handlers\n\u2502       \u2022 Background jobs\n\u2502       \u2022 Worker pools\n\u2502\n\u251c\u2500 Tightly coupled/consistent state?\n\u2502   \u2514\u2500 Use OneForAll\n\u2502       \u2022 Transaction processors\n\u2502       \u2022 Coordinated caches\n\u2502       \u2022 Trading systems\n\u2502\n\u2514\u2500 Sequential pipeline?\n    \u2514\u2500 Use RestForOne\n        \u2022 Data processing stages\n        \u2022 Message queues\n        \u2022 ETL pipelines\n</code></pre>"},{"location":"components/rt/guides/supervisor-patterns/#3-supervision-tree-patterns","title":"3. Supervision Tree Patterns","text":""},{"location":"components/rt/guides/supervisor-patterns/#flat-supervision","title":"Flat Supervision","text":"<p>Pattern: Single supervisor, many workers</p> <pre><code>     Supervisor\n         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510\n    W1   W2   W3   W4   W5\n</code></pre> <p>Use When: - Simple worker pools - All workers same type - No worker dependencies</p> <p>Example: <pre><code>let supervisor = SupervisorNode::new(\n    \"worker-pool\",\n    OneForOne,\n    RestartPolicy::Permanent,\n);\n\n// Flat structure - all workers at same level\nfor i in 0..10 {\n    supervisor.spawn_child(\n        format!(\"worker-{}\", i),\n        Worker::new(i),\n    ).await?;\n}\n</code></pre></p> <p>Pros: - Simple to understand - Easy to manage - Low overhead</p> <p>Cons: - No subsystem isolation - All failures handled same way - Doesn't scale to complex systems</p>"},{"location":"components/rt/guides/supervisor-patterns/#hierarchical-supervision","title":"Hierarchical Supervision","text":"<p>Pattern: Supervisor of supervisors</p> <pre><code>        Root Supervisor\n              \u2502\n      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  SubSup-A  SubSup-B  SubSup-C\n      \u2502         \u2502         \u2502\n   \u250c\u2500\u2500\u2534\u2500\u2500\u2510   \u250c\u2500\u2534\u2500\u2510    \u250c\u2500\u2534\u2500\u2510\n   W1   W2   W3  W4   W5  W6\n</code></pre> <p>Use When: - Multiple subsystems - Different restart policies per subsystem - Need fault isolation between components</p> <p>Example: <pre><code>// Root supervisor\nlet root = SupervisorNode::new(\n    \"application\",\n    OneForAll,  // Restart all subsystems if root fails\n    RestartPolicy::Permanent,\n);\n\n// Web subsystem\nlet web_supervisor = SupervisorNode::new(\n    \"web-subsystem\",\n    OneForOne,  // Independent workers\n    RestartPolicy::Permanent,\n);\nfor i in 0..5 {\n    web_supervisor.spawn_child(\n        format!(\"http-worker-{}\", i),\n        HttpWorker::new(),\n    ).await?;\n}\n\n// Database subsystem\nlet db_supervisor = SupervisorNode::new(\n    \"db-subsystem\",\n    RestForOne,  // Connection pool dependency\n    RestartPolicy::Permanent,\n);\ndb_supervisor.spawn_child(\"conn-pool\", ConnectionPool::new()).await?;\ndb_supervisor.spawn_child(\"query-executor\", QueryExecutor::new()).await?;\n\n// Cache subsystem\nlet cache_supervisor = SupervisorNode::new(\n    \"cache-subsystem\",\n    OneForAll,  // Cache coherency\n    RestartPolicy::Transient,\n);\ncache_supervisor.spawn_child(\"read-cache\", ReadCache::new()).await?;\ncache_supervisor.spawn_child(\"write-cache\", WriteCache::new()).await?;\n\n// Add subsystems to root\nroot.add_supervisor(web_supervisor).await?;\nroot.add_supervisor(db_supervisor).await?;\nroot.add_supervisor(cache_supervisor).await?;\n</code></pre></p> <p>Pros: - Subsystem isolation - Different policies per level - Scales to large systems - Clear component boundaries</p> <p>Cons: - More complex - Higher overhead - Requires design planning</p>"},{"location":"components/rt/guides/supervisor-patterns/#mixed-strategies","title":"Mixed Strategies","text":"<p>Pattern: Different strategies at different levels</p> <pre><code>     Root (OneForAll)\n          \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2510\nAPI (OneForOne) | DB (RestForOne)\n    \u2502           \u2502\n \u250c\u2500\u2500\u2534\u2500\u2500\u2510     \u250c\u2500\u2500\u2534\u2500\u2500\u2510\n W   W       Pool Exec\n</code></pre> <p>Example: <pre><code>// Root: All subsystems must be consistent\nlet root = SupervisorNode::new(\n    \"app-root\",\n    OneForAll,  // Restart all on critical failure\n    RestartPolicy::Permanent,\n);\n\n// API layer: Independent request handlers\nlet api_supervisor = SupervisorNode::new(\n    \"api-layer\",\n    OneForOne,  // Workers independent\n    RestartPolicy::Permanent,\n);\n\n// Database layer: Sequential dependency\nlet db_supervisor = SupervisorNode::new(\n    \"db-layer\",\n    RestForOne,  // Pool \u2192 Executor dependency\n    RestartPolicy::Permanent,\n);\n\nroot.add_supervisor(api_supervisor).await?;\nroot.add_supervisor(db_supervisor).await?;\n</code></pre></p>"},{"location":"components/rt/guides/supervisor-patterns/#real-world-example-microservice","title":"Real-World Example: Microservice","text":"<pre><code>use airssys_rt::prelude::*;\n\nasync fn build_microservice() -&gt; Result&lt;SupervisorNode, Box&lt;dyn std::error::Error&gt;&gt; {\n    // Root supervisor\n    let root = SupervisorNode::new(\n        \"microservice\",\n        OneForAll,\n        RestartPolicy::Permanent,\n    );\n\n    // HTTP API layer (independent workers)\n    let http_supervisor = SupervisorNode::new(\n        \"http-api\",\n        OneForOne,\n        RestartPolicy::Permanent,\n    );\n    for i in 0..num_cpus::get() {\n        http_supervisor.spawn_child(\n            format!(\"handler-{}\", i),\n            RequestHandler::new(i),\n        ).await?;\n    }\n\n    // Business logic layer (stateful, coordinated)\n    let logic_supervisor = SupervisorNode::new(\n        \"business-logic\",\n        OneForAll,  // Must be consistent\n        RestartPolicy::Permanent,\n    );\n    logic_supervisor.spawn_child(\"order-service\", OrderService::new()).await?;\n    logic_supervisor.spawn_child(\"inventory-service\", InventoryService::new()).await?;\n\n    // Data layer (pipeline)\n    let data_supervisor = SupervisorNode::new(\n        \"data-layer\",\n        RestForOne,  // Connection \u2192 Query dependency\n        RestartPolicy::Permanent,\n    );\n    data_supervisor.spawn_child(\"connection-pool\", ConnectionPool::new()).await?;\n    data_supervisor.spawn_child(\"query-executor\", QueryExecutor::new()).await?;\n    data_supervisor.spawn_child(\"cache-manager\", CacheManager::new()).await?;\n\n    // Assemble hierarchy\n    root.add_supervisor(http_supervisor).await?;\n    root.add_supervisor(logic_supervisor).await?;\n    root.add_supervisor(data_supervisor).await?;\n\n    Ok(root)\n}\n</code></pre>"},{"location":"components/rt/guides/supervisor-patterns/#4-builder-pattern-usage-rt-task-013","title":"4. Builder Pattern Usage (RT-TASK-013)","text":"<p>The builder pattern simplifies supervisor configuration.</p>"},{"location":"components/rt/guides/supervisor-patterns/#migrating-from-manual-childspec","title":"Migrating from Manual ChildSpec","text":"<p>Old way (manual ChildSpec): <pre><code>let spec = ChildSpec {\n    id: ChildId::new(),\n    name: \"worker-1\".to_string(),\n    restart_policy: RestartPolicy::Permanent,\n    shutdown_policy: ShutdownPolicy::Graceful(Duration::from_secs(5)),\n};\nsupervisor.spawn_with_spec(spec, Worker::new()).await?;\n</code></pre></p> <p>New way (builder pattern): <pre><code>supervisor\n    .child(\"worker-1\")\n    .restart_policy(RestartPolicy::Permanent)\n    .shutdown_timeout(Duration::from_secs(5))\n    .spawn(Worker::new())\n    .await?;\n</code></pre></p>"},{"location":"components/rt/guides/supervisor-patterns/#single-child-spawning","title":"Single Child Spawning","text":"<pre><code>use airssys_rt::prelude::*;\n\nlet supervisor = SupervisorNode::new(\n    \"my-supervisor\",\n    OneForOne,\n    RestartPolicy::Permanent,\n);\n\n// Simple spawn with defaults\nsupervisor\n    .child(\"worker-1\")\n    .spawn(Worker::new())\n    .await?;\n\n// Custom configuration\nsupervisor\n    .child(\"worker-2\")\n    .restart_policy(RestartPolicy::Transient)\n    .shutdown_timeout(Duration::from_secs(10))\n    .health_check_interval(Duration::from_secs(30))\n    .spawn(Worker::new())\n    .await?;\n</code></pre>"},{"location":"components/rt/guides/supervisor-patterns/#batch-spawning","title":"Batch Spawning","text":"<pre><code>// Spawn multiple workers with same config\nsupervisor\n    .children(\"worker\", 10)  // Creates worker-0 through worker-9\n    .restart_policy(RestartPolicy::Permanent)\n    .spawn_batch(|| Worker::new())\n    .await?;\n\n// Spawn with custom initialization\nsupervisor\n    .children(\"handler\", 5)\n    .spawn_batch_with(|index| HttpHandler::new(index))\n    .await?;\n</code></pre>"},{"location":"components/rt/guides/supervisor-patterns/#common-configurations","title":"Common Configurations","text":"<p>Permanent Workers (always restart): <pre><code>supervisor\n    .child(\"critical-service\")\n    .restart_policy(RestartPolicy::Permanent)\n    .spawn(Service::new())\n    .await?;\n</code></pre></p> <p>Transient Workers (restart only on error): <pre><code>supervisor\n    .child(\"task-processor\")\n    .restart_policy(RestartPolicy::Transient)\n    .spawn(TaskProcessor::new())\n    .await?;\n</code></pre></p> <p>Temporary Workers (never restart): <pre><code>supervisor\n    .child(\"one-time-job\")\n    .restart_policy(RestartPolicy::Temporary)\n    .spawn(Job::new())\n    .await?;\n</code></pre></p>"},{"location":"components/rt/guides/supervisor-patterns/#5-health-monitoring-integration-rt-task-010","title":"5. Health Monitoring Integration (RT-TASK-010)","text":"<p>Supervisors can integrate with the monitoring system for proactive health checks.</p>"},{"location":"components/rt/guides/supervisor-patterns/#automatic-health-checks","title":"Automatic Health Checks","text":"<pre><code>use airssys_rt::prelude::*;\nuse std::time::Duration;\n\nlet supervisor = SupervisorNode::new(\n    \"monitored-workers\",\n    OneForOne,\n    RestartPolicy::Permanent,\n);\n\n// Enable automatic health monitoring\nsupervisor\n    .child(\"worker-1\")\n    .health_check_interval(Duration::from_secs(10))  // Check every 10s\n    .health_check_timeout(Duration::from_secs(2))    // Timeout after 2s\n    .unhealthy_threshold(3)                          // 3 failures \u2192 restart\n    .spawn(Worker::new())\n    .await?;\n</code></pre>"},{"location":"components/rt/guides/supervisor-patterns/#custom-health-check-logic","title":"Custom Health Check Logic","text":"<pre><code>use airssys_rt::monitoring::{HealthCheck, HealthStatus};\n\nstruct DatabaseWorker {\n    connection: Option&lt;Connection&gt;,\n}\n\n#[async_trait]\nimpl HealthCheck for DatabaseWorker {\n    async fn check_health(&amp;self) -&gt; HealthStatus {\n        match &amp;self.connection {\n            Some(conn) if conn.is_alive() =&gt; HealthStatus::Healthy,\n            Some(_) =&gt; HealthStatus::Degraded(\"Connection stale\".into()),\n            None =&gt; HealthStatus::Unhealthy(\"No connection\".into()),\n        }\n    }\n}\n\n// Supervisor will automatically restart if unhealthy\nsupervisor\n    .child(\"db-worker\")\n    .health_check_interval(Duration::from_secs(5))\n    .spawn(DatabaseWorker { connection: None })\n    .await?;\n</code></pre>"},{"location":"components/rt/guides/supervisor-patterns/#threshold-configuration","title":"Threshold Configuration","text":"<pre><code>// Conservative: Restart only after multiple failures\nsupervisor\n    .child(\"stable-service\")\n    .unhealthy_threshold(5)  // 5 consecutive failures\n    .health_check_interval(Duration::from_secs(30))\n    .spawn(Service::new())\n    .await?;\n\n// Aggressive: Restart quickly on any issue\nsupervisor\n    .child(\"critical-service\")\n    .unhealthy_threshold(1)  // Restart immediately\n    .health_check_interval(Duration::from_secs(5))\n    .spawn(CriticalService::new())\n    .await?;\n</code></pre>"},{"location":"components/rt/guides/supervisor-patterns/#proactive-vs-reactive-monitoring","title":"Proactive vs Reactive Monitoring","text":"<p>Reactive Monitoring (traditional): - Wait for errors - React to failures - Downtime during recovery</p> <p>Proactive Monitoring (health checks): <pre><code>struct ApiWorker {\n    last_request: Instant,\n    error_count: u32,\n}\n\n#[async_trait]\nimpl HealthCheck for ApiWorker {\n    async fn check_health(&amp;self) -&gt; HealthStatus {\n        // Proactive checks\n        if self.last_request.elapsed() &gt; Duration::from_secs(300) {\n            return HealthStatus::Degraded(\"No recent requests\".into());\n        }\n\n        if self.error_count &gt; 10 {\n            return HealthStatus::Degraded(\"High error rate\".into());\n        }\n\n        HealthStatus::Healthy\n    }\n}\n\n// Supervisor restarts before complete failure\nsupervisor\n    .child(\"api-worker\")\n    .health_check_interval(Duration::from_secs(10))\n    .unhealthy_threshold(2)\n    .spawn(ApiWorker::new())\n    .await?;\n</code></pre></p> <p>Benefits: - Detect degradation early - Restart before complete failure - Minimize downtime - Better user experience</p>"},{"location":"components/rt/guides/supervisor-patterns/#next-steps","title":"Next Steps","text":"<p>Congratulations! You now understand supervision patterns deeply. Continue your learning:</p>"},{"location":"components/rt/guides/supervisor-patterns/#master-message-patterns","title":"\ud83d\udce8 Master Message Patterns","text":"<ul> <li>Message Passing Guide - Communication patterns and optimization</li> </ul>"},{"location":"components/rt/guides/supervisor-patterns/#build-production-systems","title":"\ud83c\udfaf Build Production Systems","text":"<ul> <li>Monitoring Guide - Observability and metrics</li> <li>Performance Guide - Tuning for production</li> </ul>"},{"location":"components/rt/guides/supervisor-patterns/#advanced-architecture","title":"\ud83c\udfd7\ufe0f Advanced Architecture","text":"<ul> <li>Distributed Supervision - Multi-node supervision</li> <li>Fault Tolerance Patterns - Production-ready resilience</li> </ul>"},{"location":"components/rt/guides/supervisor-patterns/#summary","title":"Summary","text":"<p>\u2705 \"Let It Crash\" Philosophy: Simple code, supervisors handle recovery \u2705 Restart Strategies: OneForOne, OneForAll, RestForOne selection \u2705 Supervision Trees: Flat, hierarchical, mixed patterns \u2705 Builder Pattern: Simplified configuration (RT-TASK-013) \u2705 Health Monitoring: Proactive checks and automatic recovery (RT-TASK-010)  </p> <p>You're now ready to build resilient, self-healing systems with AirsSys-RT!</p>"},{"location":"components/rt/performance/benchmarking/","title":"Benchmarking Guide","text":""},{"location":"components/rt/performance/optimization/","title":"Optimization Strategies","text":""},{"location":"components/rt/performance/targets/","title":"Performance Targets","text":""},{"location":"components/rt/reference/api/","title":"API Reference","text":"<p>Complete API documentation for AirsSys RT - authoritative technical specifications for all public types, traits, and functions.</p>"},{"location":"components/rt/reference/api/#overview","title":"Overview","text":"<p>This section provides detailed API documentation for all AirsSys RT components. Each page follows Reference documentation principles from the Di\u00e1taxis framework: neutral, authoritative, and comprehensive.</p> <p>Organization: API documentation is organized by functional area (core, actors, messaging, supervisors, mailbox, broker, monitoring) rather than by module structure.</p>"},{"location":"components/rt/reference/api/#core-api","title":"Core API","text":"<p>Core Types</p> <p>Fundamental types and traits that form the foundation of the actor system: - <code>ActorAddress</code> - Unique actor identification - <code>ActorContext</code> - Actor execution environment and metadata - <code>Message</code> trait - Message type definition - <code>ActorState</code> - Actor lifecycle states - <code>ActorLifecycle</code> - Lifecycle state machine</p> <p>When to use: Every actor implementation requires understanding these core types.</p>"},{"location":"components/rt/reference/api/#actor-api","title":"Actor API","text":"<p>Actors</p> <p>Actor trait and actor-related functionality: - <code>Actor</code> trait - Core actor behavior - Lifecycle hooks: <code>pre_start</code>, <code>post_stop</code>, <code>post_restart</code> - Error handling: <code>on_error</code>, <code>ErrorAction</code> - Message handling: <code>handle_message</code> - State management patterns</p> <p>When to use: Implementing custom actors or understanding actor behavior.</p>"},{"location":"components/rt/reference/api/#messaging-api","title":"Messaging API","text":"<p>Messaging</p> <p>Message passing, routing, and communication: - Message types and protocols - Request-reply pattern (<code>ask</code>) - Fire-and-forget pattern (<code>send</code>) - Message routing mechanisms - Performance characteristics</p> <p>When to use: Implementing inter-actor communication or designing message protocols.</p>"},{"location":"components/rt/reference/api/#supervision-api","title":"Supervision API","text":"<p>Supervisors</p> <p>Supervision trees and fault tolerance: - <code>SupervisorBuilder</code> - Builder pattern for supervisors - <code>RestartStrategy</code> - OneForOne, OneForAll, RestForOne - <code>ChildSpec</code> - Child actor specifications - Health monitoring and supervision events - Restart rate limiting</p> <p>When to use: Building fault-tolerant systems with supervision trees.</p>"},{"location":"components/rt/reference/api/#mailbox-api","title":"Mailbox API","text":"<p>Mailbox</p> <p>Actor message queues and backpressure: - <code>Mailbox</code> trait - Message queue abstraction - Bounded mailboxes - Fixed capacity with backpressure - Unbounded mailboxes - Dynamic growth - Capacity configuration and tuning - Performance characteristics</p> <p>When to use: Configuring actor mailboxes or handling backpressure.</p>"},{"location":"components/rt/reference/api/#message-broker-api","title":"Message Broker API","text":"<p>Message Broker</p> <p>Publish-subscribe messaging infrastructure: - <code>MessageBroker</code> trait - Broker abstraction - <code>InMemoryMessageBroker</code> - In-process pub-sub - Topic-based routing - Subscription management - Broadcast performance</p> <p>When to use: Implementing event-driven architectures or pub-sub patterns.</p>"},{"location":"components/rt/reference/api/#monitoring-api","title":"Monitoring API","text":"<p>Monitoring</p> <p>Observability, metrics, and health monitoring: - Health check API - Metrics collection - Supervision events - Actor statistics - Performance monitoring</p> <p>When to use: Adding observability to actor systems or monitoring system health.</p>"},{"location":"components/rt/reference/api/#api-design-principles","title":"API Design Principles","text":"<p>All AirsSys RT APIs follow these design principles:</p>"},{"location":"components/rt/reference/api/#type-safety-first","title":"Type Safety First","text":"<pre><code>// \u2705 Strong typing - compile-time safety\nimpl Actor for MyActor {\n    type Message = MyMessage;  // Type-safe messages\n    type Error = MyError;      // Type-safe errors\n}\n</code></pre>"},{"location":"components/rt/reference/api/#zero-cost-abstractions","title":"Zero-Cost Abstractions","text":"<pre><code>// \u2705 Generic compilation - no runtime overhead\nasync fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(...) {\n    // Monomorphized at compile-time\n}\n</code></pre>"},{"location":"components/rt/reference/api/#builder-pattern-for-complex-construction","title":"Builder Pattern for Complex Construction","text":"<pre><code>// \u2705 Fluent API - self-documenting configuration\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .with_max_restarts(3)\n    .build()\n    .await?;\n</code></pre>"},{"location":"components/rt/reference/api/#trait-based-abstractions","title":"Trait-Based Abstractions","text":"<pre><code>// \u2705 Trait objects for flexibility (where needed)\npub trait Actor {\n    type Message: Message;\n    type Error: std::error::Error;\n    async fn handle_message(...) -&gt; Result&lt;Self::Message::Result, Self::Error&gt;;\n}\n</code></pre>"},{"location":"components/rt/reference/api/#common-patterns","title":"Common Patterns","text":""},{"location":"components/rt/reference/api/#actor-implementation","title":"Actor Implementation","text":"<pre><code>use airssys_rt::prelude::*;\nuse async_trait::async_trait;\n\n#[async_trait]\nimpl Actor for MyActor {\n    type Message = MyMessage;\n    type Error = MyError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;MyMessage::Result, Self::Error&gt; {\n        // Handle message\n        context.record_message();\n        Ok(result)\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/#supervisor-setup","title":"Supervisor Setup","text":"<pre><code>let supervisor = SupervisorBuilder::new()\n    .with_name(\"my_supervisor\")\n    .with_strategy(RestartStrategy::OneForOne)\n    .with_max_restarts(3)\n    .with_restart_window(Duration::from_secs(60))\n    .build()\n    .await?;\n\nlet actor_ref = supervisor.spawn_child(MyActor::new()).await?;\n</code></pre>"},{"location":"components/rt/reference/api/#message-handling","title":"Message Handling","text":"<pre><code>// Request-Reply\nlet result = actor_ref.ask(GetData { id }).await?;\n\n// Fire-and-Forget\nactor_ref.send(LogMessage { text }).await?;\n\n// Pub-Sub\nbroker.publish(\"topic\", Event::DataChanged { id }).await?;\n</code></pre>"},{"location":"components/rt/reference/api/#performance-characteristics","title":"Performance Characteristics","text":"<p>All API operations have documented performance characteristics from benchmark data (October 2025 baseline):</p> Operation Latency Throughput Actor spawn 624ns 1.6M/sec Message send (direct) 737ns 1.36M/sec Message send (broker) 917ns 1.09M/sec Supervision overhead +656ns - Mailbox enqueue 181ns - <p>See Performance Reference for complete benchmarking data.</p>"},{"location":"components/rt/reference/api/#further-reading","title":"Further Reading","text":"<ul> <li>Architecture Reference - System architecture and design</li> <li>Performance Reference - Benchmarking and performance data</li> <li>Troubleshooting Guide - Common issues and solutions</li> <li>How-To Guides - Task-oriented guidance</li> <li>Explanation - Understanding the actor model</li> </ul>"},{"location":"components/rt/reference/architecture/","title":"Architecture Reference","text":"<p>Technical specifications for AirsSys RT system architecture - authoritative documentation of architectural components, interactions, and design decisions.</p>"},{"location":"components/rt/reference/architecture/#overview","title":"Overview","text":"<p>This section provides detailed architectural documentation for the AirsSys RT actor system. Each page follows Reference documentation principles from the Di\u00e1taxis framework: neutral descriptions of system design, component interactions, and architectural patterns.</p> <p>Organization: Architecture documentation is organized by architectural concern (system overview, components, message passing, supervision, lifecycle) to provide different perspectives on the system design.</p>"},{"location":"components/rt/reference/architecture/#system-overview","title":"System Overview","text":"<p>System Overview</p> <p>High-level architectural overview of the entire actor system: - System architecture diagram - Component relationships and dependencies - Data flow through the system - Key architectural decisions and rationale - System boundaries and external integrations</p> <p>When to use: Understanding the big picture of how AirsSys RT components work together.</p>"},{"location":"components/rt/reference/architecture/#components","title":"Components","text":"<p>Components</p> <p>Detailed component architecture and interactions: - Core components: Actor, ActorContext, Mailbox, MessageBroker, Supervisor - Component responsibilities and interfaces - Inter-component communication patterns - Dependency injection architecture (ADR-006) - Component lifecycle management</p> <p>When to use: Understanding individual components and how they interact.</p>"},{"location":"components/rt/reference/architecture/#message-passing","title":"Message Passing","text":"<p>Message Passing Architecture</p> <p>Message routing and communication architecture: - Direct messaging (actor references) - Broker-based messaging (pub-sub) - Routing mechanisms and performance - Message delivery guarantees - Backpressure and flow control</p> <p>When to use: Understanding message flow and routing decisions.</p>"},{"location":"components/rt/reference/architecture/#supervision","title":"Supervision","text":"<p>Supervision Architecture</p> <p>Fault tolerance and supervision tree architecture: - Supervision tree structure and hierarchy - Restart strategy implementations - Failure detection and recovery mechanisms - Restart rate limiting and escalation - Supervisor-child communication protocols</p> <p>When to use: Understanding fault tolerance architecture and supervision mechanisms.</p>"},{"location":"components/rt/reference/architecture/#process-lifecycle","title":"Process Lifecycle","text":"<p>Process Lifecycle</p> <p>Actor lifecycle state machine and transitions: - Actor lifecycle states: Created, Starting, Running, Stopping, Stopped, Restarting, Failed - State transition rules and triggers - Lifecycle hook execution order - Resource management and cleanup - Error handling during lifecycle transitions</p> <p>When to use: Understanding actor lifecycle management and state transitions.</p>"},{"location":"components/rt/reference/architecture/#architectural-principles","title":"Architectural Principles","text":"<p>AirsSys RT architecture follows these core principles:</p>"},{"location":"components/rt/reference/architecture/#1-actor-model-foundations","title":"1. Actor Model Foundations","text":"<p>Encapsulation and Isolation: - Actors own their state (no shared mutable state) - Message passing for all communication - Location transparency (local and remote actors use same API)</p> <p>Sequential Message Processing: - One message at a time (no internal concurrency) - FIFO message ordering guaranteed - Deterministic message handling</p>"},{"location":"components/rt/reference/architecture/#2-erlangotp-inspired-supervision","title":"2. Erlang/OTP-Inspired Supervision","text":"<p>\"Let it Crash\" Philosophy: - Simple happy path logic in actors - Supervisors handle failure recovery - Clear separation: actors do work, supervisors provide fault tolerance</p> <p>Supervision Trees: - Hierarchical fault isolation - Different strategies for different failure scenarios - Automatic restart with configurable limits</p>"},{"location":"components/rt/reference/architecture/#3-zero-cost-abstractions","title":"3. Zero-Cost Abstractions","text":"<p>Performance Without Compromise: - Generic compilation (monomorphization) - No runtime type dispatch on hot paths - Direct memory access (no unnecessary indirection) - Inline message processing</p> <p>Benchmarked Performance: - Actor spawn: 624ns (1.6M actors/sec) - Message passing: 737ns roundtrip (1.36M msgs/sec) - Supervision overhead: ~2x base actor (acceptable for fault tolerance)</p>"},{"location":"components/rt/reference/architecture/#4-type-safety","title":"4. Type Safety","text":"<p>Compile-Time Guarantees: - Associated types for messages and errors - Generic constraints for trait bounds - Type-state pattern (future) for lifecycle validation</p> <p>No Runtime Surprises: - Explicit error types (<code>Result&lt;T, E&gt;</code>) - No <code>Any</code> or type erasure on hot paths - Clear message protocols with associated <code>Result</code> types</p>"},{"location":"components/rt/reference/architecture/#5-dependency-injection","title":"5. Dependency Injection","text":"<p>Testability and Flexibility (ADR-006): - <code>MessageBroker</code> trait injected into <code>ActorContext</code> - Swap implementations (in-memory, distributed, test doubles) - No global state or singletons</p> <p>Benefits: - Unit test actors in isolation - Different brokers for different deployment scenarios - Clear component boundaries</p>"},{"location":"components/rt/reference/architecture/#architectural-layers","title":"Architectural Layers","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Application Layer                      \u2502\n\u2502  (User Actors, Supervisor Trees, Business Logic)        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Actor Framework Layer                  \u2502\n\u2502  (Actor Trait, Supervision, Lifecycle Management)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Messaging Layer                        \u2502\n\u2502  (MessageBroker, Mailbox, Routing)                      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                          \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                   Runtime Layer                          \u2502\n\u2502  (Tokio Runtime, Async Execution)                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"components/rt/reference/architecture/#layer-responsibilities","title":"Layer Responsibilities","text":"<p>Application Layer: - Business logic implementation - Actor and supervisor instantiation - Message protocol definition - Application-specific error handling</p> <p>Actor Framework Layer: - Actor lifecycle management - Supervision tree construction - Restart strategy implementation - Actor context and metadata</p> <p>Messaging Layer: - Message routing (direct and broker-based) - Mailbox management and backpressure - Pub-sub topic management - Message delivery guarantees</p> <p>Runtime Layer: - Async task scheduling (Tokio) - Concurrency primitives (channels, tasks) - I/O event loop - System resource management</p>"},{"location":"components/rt/reference/architecture/#cross-cutting-concerns","title":"Cross-Cutting Concerns","text":""},{"location":"components/rt/reference/architecture/#monitoring-and-observability","title":"Monitoring and Observability","text":"<p>Built-in Metrics: - Actor message counts - Supervisor restart counts - Mailbox depth tracking - Health check API</p> <p>Integration Points: - Custom metrics via <code>ActorContext</code> - Supervision events for monitoring - Health check endpoints</p>"},{"location":"components/rt/reference/architecture/#error-handling","title":"Error Handling","text":"<p>Layered Error Strategy: - Actor-level: <code>Result&lt;T, Self::Error&gt;</code> - Supervisor-level: <code>ErrorAction</code> (Resume, Restart, Stop, Escalate) - System-level: Supervisor escalation and shutdown</p> <p>Error Propagation: <pre><code>Actor Error \u2192 on_error() \u2192 ErrorAction \u2192 Supervisor \u2192 Restart Strategy\n</code></pre></p>"},{"location":"components/rt/reference/architecture/#performance-optimization","title":"Performance Optimization","text":"<p>Hot Path Optimizations: - Inline message processing (31.55ns) - Direct mailbox access (no indirection) - Monomorphized generics (no dynamic dispatch) - Bounded mailboxes for predictable performance</p> <p>Cold Path Acceptable Costs: - Actor spawn: 624ns (infrequent) - Supervision overhead: +656ns (fault tolerance worth it) - Broker routing: +180ns (flexibility worth it)</p>"},{"location":"components/rt/reference/architecture/#deployment-patterns","title":"Deployment Patterns","text":""},{"location":"components/rt/reference/architecture/#single-process","title":"Single Process","text":"<p>Architecture: - All actors in one process - In-memory message passing - Shared Tokio runtime</p> <p>Use Cases: - Development and testing - Single-machine deployments - Embedded systems</p>"},{"location":"components/rt/reference/architecture/#distributed-future","title":"Distributed (Future)","text":"<p>Architecture: - Actors across multiple processes/machines - Network-based message passing - Location transparency maintained</p> <p>Use Cases: - Horizontal scaling - Geographic distribution - High availability</p>"},{"location":"components/rt/reference/architecture/#design-tradeoffs","title":"Design Tradeoffs","text":""},{"location":"components/rt/reference/architecture/#type-safety-vs-flexibility","title":"Type Safety vs. Flexibility","text":"<p>Decision: Favor type safety - Associated types for messages/errors - Generic constraints over trait objects - Tradeoff: Less runtime flexibility, more compile-time safety</p>"},{"location":"components/rt/reference/architecture/#performance-vs-features","title":"Performance vs. Features","text":"<p>Decision: Measure first, optimize hot paths - Benchmarked all core operations - Zero-cost abstractions on hot paths - Tradeoff: Complexity in implementation, predictable performance</p>"},{"location":"components/rt/reference/architecture/#simplicity-vs-power","title":"Simplicity vs. Power","text":"<p>Decision: Start simple, add complexity when needed (YAGNI) - Basic actor model first - Supervision added incrementally - Tradeoff: May miss some features initially, cleaner codebase</p>"},{"location":"components/rt/reference/architecture/#architectural-evolution","title":"Architectural Evolution","text":""},{"location":"components/rt/reference/architecture/#current-state-v01","title":"Current State (v0.1)","text":"<ul> <li>\u2705 Core actor model</li> <li>\u2705 Supervision trees</li> <li>\u2705 In-memory messaging</li> <li>\u2705 Basic monitoring</li> </ul>"},{"location":"components/rt/reference/architecture/#planned-v02","title":"Planned (v0.2+)","text":"<ul> <li>\ud83d\udd04 Distributed actors</li> <li>\ud83d\udd04 Persistence</li> <li>\ud83d\udd04 Advanced routing</li> <li>\ud83d\udd04 Cluster management</li> </ul>"},{"location":"components/rt/reference/architecture/#further-reading","title":"Further Reading","text":"<ul> <li>System Overview - Detailed system architecture</li> <li>Components - Component interactions</li> <li>API Reference - API specifications</li> <li>Performance Reference - Benchmarking data</li> <li>Explanation: Actor Model - Understanding the actor model</li> <li>Explanation: Supervision - Understanding supervision philosophy</li> </ul>"},{"location":"components/rt/reference/performance/","title":"Performance Reference","text":"<p>This reference provides measured performance characteristics and capacity planning guidance for the AirsSys Runtime system.</p> <p>Last Updated: October 16, 2025 Measurement Environment: macOS (development machine), Release build, Criterion 0.7.0 Sample Size: 30 iterations per benchmark, 5 seconds measurement time, 95% confidence intervals</p>"},{"location":"components/rt/reference/performance/#quick-reference","title":"Quick Reference","text":""},{"location":"components/rt/reference/performance/#core-performance-metrics","title":"Core Performance Metrics","text":"Operation Latency Throughput Performance Class Actor spawn (single) 624.74 ns 1.6M/sec \u26a1 Sub-microsecond Actor spawn (batch) 681.40 ns/actor 1.47M/sec \u26a1 Sub-microsecond Message send/receive 737.16 ns 1.36M roundtrips/sec \u26a1 Sub-microsecond Message throughput (broker) 211.88 ns/msg 4.7M msgs/sec \u26a1 Sub-microsecond Direct message processing 31.55 ns/msg 31.7M msgs/sec \ud83d\ude80 Extremely fast Mailbox operations 181.60 ns/op 5.5M ops/sec \u26a1 Sub-microsecond Supervisor child spawn 1.28 \u00b5s 779K/sec \u2705 1-2 microseconds Supervision tree (3 children) 3.01 \u00b5s 997K/sec (total) \u2705 2-5 microseconds <p>Performance Legend: - \ud83d\ude80 Extremely fast: &lt;100 ns (10M+ ops/sec) - \u26a1 Sub-microsecond: 100ns - 1\u00b5s (1-10M ops/sec) - \u2705 Microseconds: 1-10\u00b5s (100K-1M ops/sec) - \ud83d\udcca Acceptable: 10-100\u00b5s (10K-100K ops/sec)</p>"},{"location":"components/rt/reference/performance/#actor-system-performance","title":"Actor System Performance","text":""},{"location":"components/rt/reference/performance/#actor-lifecycle","title":"Actor Lifecycle","text":""},{"location":"components/rt/reference/performance/#spawn-latency","title":"Spawn Latency","text":"<p>Single Actor Spawn:</p> Metric Value Notes Mean 624.74 ns Median performance Lower Bound 613.59 ns 95% confidence Upper Bound 646.24 ns 95% confidence Variance \u00b12.6% Tight bounds Outliers 6.67% 2 of 30 samples <p>Theoretical Capacity: - 1.6 million actors/second spawn rate - 10,000 actors: 6.25 ms to spawn all - Constant time: O(1) - independent of existing actor count</p> <p>Batch Actor Spawn (10 actors):</p> Metric Value Notes Total Time 6.814 \u00b5s For all 10 actors Per Actor 681.40 ns Average cost vs Single +9% overhead Batch marginally slower <p>Key Insight: Single actor spawn is actually faster than batch per-actor (625 ns vs 681 ns). Batch spawn primarily for API ergonomics, not performance optimization.</p>"},{"location":"components/rt/reference/performance/#message-processing","title":"Message Processing","text":"<p>Direct Actor Processing (No Broker):</p> Metric Value Notes Mean 31.55 ns/msg 100-message sustained load Throughput 31.7M msgs/sec Theoretical maximum Outliers 16.67% 5 of 30 (async scheduler variance) <p>Use Case: Hot-path actor logic with minimal async overhead.</p> <p>Memory Allocation Scaling:</p> Actor Count Time per Actor Overhead vs Single Outliers 1 718.43 ns Baseline 13.33% 10 742.76 ns +3.4% 20% 50 762.68 ns +6.2% 36.67% <p>Scaling Characteristics: - \u2705 Linear scaling: Only 6.2% overhead at 50 actors - \u26a0\ufe0f Higher variance at scale: OS allocator variance increases with count - \u2705 Predictable: Memory allocation is NOT a scaling bottleneck</p> <p>Capacity Estimates:</p> Actor Count Spawn Time (Total) Memory Footprint (Est.) 10 ~7.4 \u00b5s &lt;5 KB 100 ~76 \u00b5s &lt;50 KB 1,000 ~800 \u00b5s &lt;500 KB 10,000 ~8 ms &lt;5 MB"},{"location":"components/rt/reference/performance/#message-passing-performance","title":"Message Passing Performance","text":""},{"location":"components/rt/reference/performance/#point-to-point-messaging","title":"Point-to-Point Messaging","text":"<p>Send/Receive Roundtrip (via Broker):</p> Metric Value Notes Mean 737.16 ns Full cycle through broker Lower Bound 732.80 ns 95% confidence Upper Bound 743.39 ns 95% confidence Variance \u00b10.7% Very tight bounds Throughput 1.36M roundtrips/sec Sustained rate <p>Latency Breakdown (Estimated): - Topic lookup/routing: ~50 ns (6.8%) - Subscription management: ~60 ns (8.1%) - Channel send/receive: ~70 ns (9.5%) - Actor processing: ~400 ns (54.3%) - Result return: ~106 ns (14.4%) - Broker overhead: ~180 ns (24.4%)</p>"},{"location":"components/rt/reference/performance/#sustained-throughput","title":"Sustained Throughput","text":"<p>Message Throughput (100 messages via Broker):</p> Metric Value Notes Total Time 21.188 \u00b5s For 100 messages Per Message 211.88 ns Average cost Throughput 4.7M msgs/sec Broker routing vs Direct 6.7x slower vs 31.55 ns direct <p>Broker Overhead Analysis: - Direct processing: 31.55 ns/msg (no broker) - Broker routing: 211.88 ns/msg (with broker) - Overhead: 180.33 ns (6.7x slower)</p> <p>When Broker Overhead is Acceptable: - \u2705 Pub-sub patterns (1-to-many, dynamic subscriptions) - \u2705 Decoupling (publishers don't know subscribers) - \u2705 Still fast (4.7M msgs/sec is excellent for most workloads)</p> <p>When to Avoid Broker: - \u26a0\ufe0f Ultra-hot paths requiring 31M msgs/sec - \u26a0\ufe0f Known fixed topology (use direct <code>ActorRef</code>) - \u26a0\ufe0f Latency-critical microsecond budgets</p>"},{"location":"components/rt/reference/performance/#broadcast-performance","title":"Broadcast Performance","text":"<p>Broadcast to 10 Subscribers:</p> Metric Value Notes Mean 3.9511 \u00b5s For 10 actors Per Subscriber 395.11 ns Average cost Overhead ~40 ns/subscriber vs point-to-point <p>Scaling: O(n) with subscriber count (parallel delivery).</p>"},{"location":"components/rt/reference/performance/#mailbox-efficiency","title":"Mailbox Efficiency","text":"<p>Mailbox Operations (100 enqueue/dequeue cycles):</p> Metric Value Notes Total Time 18.160 \u00b5s For 100 operations Per Operation 181.60 ns Enqueue + dequeue pair Throughput 5.5M ops/sec Sustained rate <p>Mailbox Creation Comparison:</p> Mailbox Type Creation Time Overhead Use Case Unbounded 188.55 ns Baseline Default choice, low latency Bounded (100) 244.18 ns +29.5% Backpressure, resource limits <p>Key Insight: Unbounded mailboxes 23% faster to create, but 29% creation overhead is one-time cost. Operational performance identical.</p> <p>Recommendations:</p> <p>Use Unbounded: - \u2705 Default choice (23% faster creation, simpler semantics) - \u2705 Trusted internal actors - \u2705 Low message rate (&lt;1000 msgs/sec)</p> <p>Use Bounded: - \u2705 Backpressure needed (slow consumers, prevent memory bloat) - \u2705 Untrusted sources (external inputs, rate limiting) - \u2705 Known capacity constraints</p>"},{"location":"components/rt/reference/performance/#supervision-performance","title":"Supervision Performance","text":""},{"location":"components/rt/reference/performance/#child-spawn-operations","title":"Child Spawn Operations","text":"<p>Single Child Spawn (via Builder):</p> Metric Value Notes Mean 1.2834 \u00b5s Single child Throughput 779K children/sec Spawn rate Outliers 3.33% 1 of 30 samples <p>Batch Child Spawn (3 children):</p> Metric Value Notes Total Time 3.0073 \u00b5s For 3 children Per Child 1.002 \u00b5s Average cost vs Single -21.6% faster! Batch efficiency <p>Key Insight: Batch spawn 21.6% faster per-child than single spawn.</p>"},{"location":"components/rt/reference/performance/#restart-strategy-performance","title":"Restart Strategy Performance","text":"<p>Strategy Comparison (3 children):</p> Strategy Total Time Per Child vs Baseline Outliers OneForOne (single) 1.2731 \u00b5s 1.2731 \u00b5s Baseline 6.67% OneForAll (batch) 2.9959 \u00b5s 998.63 ns -21.6% faster 3.33% RestForOne (batch) 3.0012 \u00b5s 1000.4 ns -21.4% faster 10% Tree (small) 3.0073 \u00b5s 1002.4 ns -21.3% faster 0% <p>Critical Insight: - \u2705 Strategy choice is semantic, not performance-based: &lt;1% difference between strategies - \u2705 Perfect stability: Tree construction has 0% outliers (most stable benchmark) - \u2705 Batch efficiency: All batch strategies ~21% faster per-child</p> <p>Restart Latency Estimate: - Stop existing child: ~500 ns (cleanup, deregistration) - Spawn new child: ~1,283 ns (measured baseline) - Total restart: ~1.8 \u00b5s (estimated)</p> <p>Restart Capacity: - Single child restarts: ~556,000 restarts/second - Batch restarts (3 children): ~1 million restarts/second total</p>"},{"location":"components/rt/reference/performance/#supervision-tree-scaling","title":"Supervision Tree Scaling","text":"<p>Small Tree (3 children, 1 level): - Construction: 3.0073 \u00b5s - Per Child: 1.002 \u00b5s - Outliers: 0% (perfect stability)</p> <p>Projected Scaling (extrapolated): - 2 levels (9 children): ~9 \u00b5s construction (linear) - 3 levels (27 children): ~27 \u00b5s construction (linear) - Pattern: \u2705 Linear scaling O(n) with tree size, no depth penalty</p>"},{"location":"components/rt/reference/performance/#scaling-characteristics","title":"Scaling Characteristics","text":""},{"location":"components/rt/reference/performance/#linear-scaling-confirmed","title":"Linear Scaling Confirmed","text":"<p>Actor Memory Allocation: - 1 actor: 718.43 ns - 10 actors: 742.76 ns/actor (+3.4%) - 50 actors: 762.68 ns/actor (+6.2%) - Conclusion: Linear scaling with minimal overhead</p> <p>Message Processing: - Direct: 31.55 ns/msg (constant) - Broker: 211.88 ns/msg (constant) - Conclusion: O(1) per-message cost</p> <p>Supervision: - Single child: 1.28 \u00b5s - 3 children: 1.00 \u00b5s/child (batch efficiency) - Conclusion: Batch spawn more efficient than single</p>"},{"location":"components/rt/reference/performance/#batch-efficiency","title":"Batch Efficiency","text":"<p>Batch Operations Summary:</p> Operation Single Batch (per-unit) Efficiency Gain Actor Spawn 624.74 ns 681.40 ns -9% slower Supervisor Spawn 1.2834 \u00b5s 1.002 \u00b5s +21.6% faster Message Broadcast N/A 395.11 ns/sub Parallel delivery <p>Insight: Supervisor batch spawn shows significant efficiency gain, actor spawn does not benefit from batching.</p>"},{"location":"components/rt/reference/performance/#broker-overhead","title":"Broker Overhead","text":"<p>Overhead Breakdown: - Direct actor processing: 31.55 ns/msg - Broker routing: 211.88 ns/msg - Overhead: 180.33 ns (6.7x slower)</p> <p>Acceptable Trade-offs: - \u2705 180 ns overhead is still sub-microsecond - \u2705 4.7M msgs/sec sufficient for most workloads - \u2705 Pub-sub flexibility worth the cost</p>"},{"location":"components/rt/reference/performance/#capacity-planning","title":"Capacity Planning","text":""},{"location":"components/rt/reference/performance/#theoretical-limits","title":"Theoretical Limits","text":"<p>Actor Capacity: - Spawn rate: 1.6M actors/second - 10,000 actors: ~6.25 ms to spawn all - Memory: Limited by available RAM, not framework</p> <p>Message Capacity: - Direct processing: 31.7M msgs/sec theoretical - Broker routing: 4.7M msgs/sec theoretical - Realistic: 1-5M msgs/sec (accounting for business logic)</p> <p>Supervision Capacity: - Child spawns: 779K/sec (single), 997K/sec (batch) - Restarts: ~556K/sec estimated - Overhead: &lt;1% in normal operation</p>"},{"location":"components/rt/reference/performance/#real-world-guidelines","title":"Real-World Guidelines","text":"<p>Capacity Planning Formula:</p> <pre><code>System Capacity = min(\n    CPU cores \u00d7 msgs_per_core_per_sec,\n    Network bandwidth \u00f7 message_size,\n    Memory \u00f7 (actors \u00d7 memory_per_actor)\n)\n</code></pre> <p>Typically Bounded By: 1. Business logic CPU (not framework overhead) 2. I/O operations (database queries, network calls) 3. Memory for actor state (not actor framework)</p>"},{"location":"components/rt/reference/performance/#recommended-limits","title":"Recommended Limits","text":"<p>Actor Count Guidelines:</p> Actor Count Spawn Time Memory (Est.) Use Case 1-10 &lt;10 \u00b5s &lt;5 KB Small services 10-100 &lt;100 \u00b5s &lt;50 KB Standard services 100-1,000 &lt;1 ms &lt;500 KB Medium systems 1,000-10,000 &lt;10 ms &lt;5 MB Large systems 10,000+ &lt;100 ms &lt;50 MB Massive scale <p>Message Rate Guidelines:</p> Messages/sec Broker Overhead Use Case &lt;1,000 Negligible Low-volume services 1K-10K &lt;1% CPU Standard services 10K-100K ~1-5% CPU High-throughput services 100K-1M ~5-20% CPU Very high throughput 1M+ Consider sharding Distributed systems"},{"location":"components/rt/reference/performance/#performance-optimization","title":"Performance Optimization","text":""},{"location":"components/rt/reference/performance/#hot-path-optimization","title":"Hot Path Optimization","text":"<p>Direct Actor References:</p> <pre><code>// \u2705 FASTEST: Direct actor-to-actor (31.55 ns/msg)\nactor_ref.send(msg).await?;\n\n// \ud83d\udcca ACCEPTABLE: Via broker (211.88 ns/msg, +180 ns overhead)\nbroker.publish(\"topic\", msg).await?;\n</code></pre> <p>When to Optimize: - \u26a0\ufe0f Proven bottleneck via profiling - \u26a0\ufe0f &gt;1M msgs/sec on hot path - \u26a0\ufe0f Sub-millisecond latency budget</p> <p>When NOT to Optimize: - \u2705 4.7M msgs/sec is sufficient for workload - \u2705 Pub-sub flexibility needed - \u2705 No profiler evidence of bottleneck</p>"},{"location":"components/rt/reference/performance/#mailbox-sizing","title":"Mailbox Sizing","text":"<p>Small Mailboxes (10-50): - Use for: Latency-sensitive, fast turnaround - Trade-off: Higher blocking probability</p> <p>Medium Mailboxes (100-500): - Use for: Standard workloads - Trade-off: Balanced memory/throughput</p> <p>Large Mailboxes (1000+): - Use for: Batch processing, high variance - Trade-off: Higher memory footprint</p>"},{"location":"components/rt/reference/performance/#supervision-strategy","title":"Supervision Strategy","text":"<p>Strategy Selection (Performance Neutral): - \u2705 All strategies have &lt;1% variance - \u2705 Choose based on semantics, not performance:   - OneForOne: Independent child failures   - OneForAll: Coupled state/resources   - RestForOne: Startup dependencies</p>"},{"location":"components/rt/reference/performance/#performance-verification","title":"Performance Verification","text":""},{"location":"components/rt/reference/performance/#running-benchmarks","title":"Running Benchmarks","text":"<pre><code># Full benchmark suite (~3-5 minutes)\ncargo bench\n\n# Specific categories\ncargo bench actor_       # Actor system\ncargo bench message_     # Message passing\ncargo bench supervisor_  # Supervision\ncargo bench resource_    # Resource usage\n\n# View HTML reports\nopen target/criterion/report/index.html\n</code></pre>"},{"location":"components/rt/reference/performance/#baseline-comparison","title":"Baseline Comparison","text":"<p>Verify Against Baselines: - Actor spawn: Should be ~625 ns - Message roundtrip: Should be ~737 ns - Supervisor spawn: Should be ~1.28 \u00b5s - Message throughput: Should be ~211 ns/msg</p> <p>Significant Regression: &gt;20% degradation from baseline.</p>"},{"location":"components/rt/reference/performance/#performance-faq","title":"Performance FAQ","text":""},{"location":"components/rt/reference/performance/#q-why-is-batch-actor-spawn-slower-per-actor-than-single-spawn","title":"Q: Why is batch actor spawn slower per-actor than single spawn?","text":"<p>A: Memory allocator batch overhead (+9%). Batch spawn is for API ergonomics, not performance optimization. Use single spawn for lowest latency (625 ns vs 681 ns).</p>"},{"location":"components/rt/reference/performance/#q-is-broker-overhead-acceptable-for-production","title":"Q: Is broker overhead acceptable for production?","text":"<p>A: Yes. 180 ns overhead is sub-microsecond, and 4.7M msgs/sec is excellent for most workloads. Use broker for pub-sub patterns, direct <code>ActorRef</code> for proven hot paths.</p>"},{"location":"components/rt/reference/performance/#q-should-i-use-bounded-or-unbounded-mailboxes","title":"Q: Should I use bounded or unbounded mailboxes?","text":"<p>A: Default to unbounded (23% faster creation, simpler). Use bounded for: - Backpressure (slow consumers) - Untrusted sources (rate limiting) - Known capacity constraints</p> <p>29% creation overhead is one-time cost; operational performance identical.</p>"},{"location":"components/rt/reference/performance/#q-which-supervision-strategy-is-fastest","title":"Q: Which supervision strategy is fastest?","text":"<p>A: All strategies have &lt;1% performance difference. Choose based on semantics: - OneForOne: Independent failures (simplest) - OneForAll: Coupled state (restart all) - RestForOne: Ordered dependencies (restart affected)</p>"},{"location":"components/rt/reference/performance/#q-how-many-actors-can-the-system-handle","title":"Q: How many actors can the system handle?","text":"<p>A: Tens of thousands on a single machine. Spawn time is negligible (~625 ns/actor). Typical limits: - CPU: Business logic processing - Memory: Actor state (not framework overhead) - I/O: Database/network operations</p> <p>Framework overhead is NOT a scaling bottleneck.</p>"},{"location":"components/rt/reference/performance/#q-whats-the-maximum-message-throughput","title":"Q: What's the maximum message throughput?","text":"<p>A: Theoretical: 31.7M msgs/sec (direct), 4.7M msgs/sec (broker). Realistic: 1-5M msgs/sec accounting for business logic, I/O, and other overhead. Framework overhead is NOT a throughput bottleneck.</p>"},{"location":"components/rt/reference/performance/#see-also","title":"See Also","text":"<ul> <li>BENCHMARKING.md - Complete benchmark suite documentation</li> <li>Architecture: System Overview - Performance characteristics section</li> <li>Architecture: Components - Per-component performance data</li> <li>API Reference: Core - Performance notes in method documentation</li> <li>API Reference: Messaging - Message passing performance details</li> <li>API Reference: Supervisors - Supervision performance characteristics</li> </ul>"},{"location":"components/rt/reference/troubleshooting/","title":"Troubleshooting","text":"<p>This guide covers common issues, error messages, and their solutions when working with AirsSys RT.</p>"},{"location":"components/rt/reference/troubleshooting/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Compilation Issues</li> <li>Runtime Errors</li> <li>Performance Issues</li> <li>Supervisor Problems</li> <li>Message Passing Issues</li> <li>Actor Lifecycle Issues</li> <li>Mailbox Problems</li> <li>System Configuration Issues</li> </ul>"},{"location":"components/rt/reference/troubleshooting/#compilation-issues","title":"Compilation Issues","text":""},{"location":"components/rt/reference/troubleshooting/#issue-1-actor-trait-not-in-scope","title":"Issue 1: <code>Actor</code> trait not in scope","text":"<p>Error Message: <pre><code>error[E0405]: cannot find trait `Actor` in this scope\n --&gt; src/main.rs:5:6\n  |\n5 | impl Actor for MyActor {\n  |      ^^^^^ not found in this scope\n</code></pre></p> <p>Cause: The <code>Actor</code> trait has not been imported into the current module scope.</p> <p>Solution: Add the necessary import:</p> <pre><code>use airssys_rt::actor::Actor;\n\n// Or use the prelude for common traits\nuse airssys_rt::prelude::*;\n</code></pre> <p>Prevention: Use <code>airssys_rt::prelude::*</code> to import all commonly used traits and types.</p>"},{"location":"components/rt/reference/troubleshooting/#issue-2-handlerm-trait-not-implemented","title":"Issue 2: <code>Handler&lt;M&gt;</code> trait not implemented","text":"<p>Error Message: <pre><code>error[E0277]: the trait bound `MyActor: Handler&lt;MyMessage&gt;` is not satisfied\n  --&gt; src/main.rs:42:18\n   |\n42 |     actor_ref.send(msg).await;\n   |               ^^^^ the trait `Handler&lt;MyMessage&gt;` is not implemented for `MyActor`\n</code></pre></p> <p>Cause: The actor has not implemented <code>Handler&lt;M&gt;</code> for the message type being sent.</p> <p>Solution: Implement the <code>Handler&lt;M&gt;</code> trait for your actor:</p> <pre><code>use airssys_rt::prelude::*;\nuse async_trait::async_trait;\n\n#[derive(Clone)]\nstruct MyMessage;\n\nimpl Message for MyMessage {\n    type Result = ();\n}\n\nstruct MyActor;\n\nimpl Actor for MyActor {}\n\n#[async_trait]\nimpl Handler&lt;MyMessage&gt; for MyActor {\n    async fn handle(&amp;mut self, _msg: MyMessage, _ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; () {\n        println!(\"Message handled!\");\n    }\n}\n</code></pre> <p>Prevention: Ensure every message type your actor receives has a corresponding <code>Handler&lt;M&gt;</code> implementation.</p>"},{"location":"components/rt/reference/troubleshooting/#issue-3-missing-async_trait-macro","title":"Issue 3: Missing <code>async_trait</code> macro","text":"<p>Error Message: <pre><code>error: async trait functions cannot be used in traits without `#[async_trait]`\n  --&gt; src/main.rs:15:5\n   |\n15 |     async fn handle(&amp;mut self, msg: M, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; M::Result;\n   |     ^^^^^\n</code></pre></p> <p>Cause: The <code>#[async_trait]</code> attribute is required for async trait methods but was not applied.</p> <p>Solution: Add <code>#[async_trait]</code> to both trait and implementation:</p> <pre><code>use async_trait::async_trait;\nuse airssys_rt::prelude::*;\n\n#[async_trait]\nimpl Handler&lt;MyMessage&gt; for MyActor {\n    async fn handle(&amp;mut self, msg: MyMessage, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; () {\n        // Handler implementation\n    }\n}\n</code></pre> <p>Prevention: Always use <code>#[async_trait]</code> when implementing <code>Handler&lt;M&gt;</code> or other async traits.</p>"},{"location":"components/rt/reference/troubleshooting/#issue-4-messageresult-type-mismatch","title":"Issue 4: <code>Message::Result</code> type mismatch","text":"<p>Error Message: <pre><code>error[E0308]: mismatched types\n  --&gt; src/main.rs:28:9\n   |\n28 |         \"OK\".to_string()\n   |         ^^^^^^^^^^^^^^^^ expected `()`, found `String`\n</code></pre></p> <p>Cause: The return type in the <code>Handler&lt;M&gt;</code> implementation does not match the <code>Message::Result</code> associated type.</p> <p>Solution: Ensure the <code>Message::Result</code> type matches the handler's return type:</p> <pre><code>#[derive(Clone)]\nstruct MyMessage;\n\nimpl Message for MyMessage {\n    type Result = String;  // Match handler return type\n}\n\n#[async_trait]\nimpl Handler&lt;MyMessage&gt; for MyActor {\n    async fn handle(&amp;mut self, _msg: MyMessage, _ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; String {\n        \"OK\".to_string()  // Now matches Message::Result\n    }\n}\n</code></pre> <p>Prevention: Always declare the correct <code>Message::Result</code> type when implementing <code>Message</code> trait.</p>"},{"location":"components/rt/reference/troubleshooting/#runtime-errors","title":"Runtime Errors","text":""},{"location":"components/rt/reference/troubleshooting/#issue-5-actor-panics-without-restart","title":"Issue 5: Actor panics without restart","text":"<p>Symptom: Actor encounters a panic and stops processing messages permanently, with no restart attempt.</p> <p>Cause: Actor is not supervised, or supervisor's restart strategy is set to <code>Abort</code>.</p> <p>Solution: Ensure actor is supervised with an appropriate restart strategy:</p> <pre><code>use airssys_rt::supervisor::{Supervisor, ChildSpec, RestartStrategy};\nuse airssys_rt::prelude::*;\n\n// Create supervisor with OneForOne restart strategy\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .with_child(\n        ChildSpec::new(\"my-actor\")\n            .with_actor::&lt;MyActor&gt;()\n            .with_max_restarts(5)\n            .with_restart_window(Duration::from_secs(60))\n    )\n    .build()\n    .await?;\n</code></pre> <p>Prevention: Always supervise critical actors and choose appropriate restart strategies.</p>"},{"location":"components/rt/reference/troubleshooting/#issue-6-deadlock-in-actor-system","title":"Issue 6: Deadlock in actor system","text":"<p>Symptom: System hangs indefinitely with no progress in message processing.</p> <p>Cause: Circular message dependencies or synchronous blocking operations within actors.</p> <p>Cause Analysis:</p> <ol> <li> <p>Circular Dependencies: <pre><code>// Actor A sends to Actor B and waits\nlet result = actor_b_ref.send(msg).await;\n\n// Actor B sends to Actor A and waits (DEADLOCK!)\nlet result = actor_a_ref.send(msg).await;\n</code></pre></p> </li> <li> <p>Blocking Operations: <pre><code>// Blocking I/O in handler (BLOCKS EXECUTOR!)\nasync fn handle(&amp;mut self, _msg: M, _ctx: &amp;mut ActorContext&lt;Self&gt;) {\n    std::fs::read_to_string(\"file.txt\"); // Synchronous blocking!\n}\n</code></pre></p> </li> </ol> <p>Solution:</p> <ol> <li> <p>Avoid Circular Dependencies: <pre><code>// Use fire-and-forget instead of request-reply\nactor_b_ref.send(msg).await?;\n// Don't wait for response if it creates cycle\n</code></pre></p> </li> <li> <p>Use Async I/O: <pre><code>async fn handle(&amp;mut self, _msg: M, _ctx: &amp;mut ActorContext&lt;Self&gt;) {\n    // Use async I/O instead\n    tokio::fs::read_to_string(\"file.txt\").await?;\n}\n</code></pre></p> </li> <li> <p>Use <code>spawn_blocking</code> for Unavoidable Blocking: <pre><code>use tokio::task;\n\nasync fn handle(&amp;mut self, _msg: M, _ctx: &amp;mut ActorContext&lt;Self&gt;) {\n    let result = task::spawn_blocking(|| {\n        // Synchronous blocking operation\n        std::fs::read_to_string(\"file.txt\")\n    }).await??;\n}\n</code></pre></p> </li> </ol> <p>Prevention: - Design message flow as directed acyclic graph (DAG) - Use async I/O operations exclusively - Reserve <code>spawn_blocking</code> for unavoidable synchronous code</p>"},{"location":"components/rt/reference/troubleshooting/#issue-7-messages-not-being-received","title":"Issue 7: Messages not being received","text":"<p>Symptom: Messages sent to actor are not processed, no errors reported.</p> <p>Cause: Multiple possible causes:</p> <ol> <li>Mailbox closed prematurely</li> <li>Actor stopped before processing</li> <li>Incorrect actor reference</li> <li>Bounded mailbox full with Drop strategy</li> </ol> <p>Diagnostic Steps:</p> <p>Step 1: Check send result: <pre><code>match actor_ref.send(msg).await {\n    Ok(_) =&gt; println!(\"Message sent successfully\"),\n    Err(e) =&gt; eprintln!(\"Send failed: {:?}\", e),\n}\n</code></pre></p> <p>Step 2: Verify actor is running: <pre><code>// Check actor lifecycle state\nif ctx.is_stopped() {\n    eprintln!(\"Actor is stopped!\");\n}\n</code></pre></p> <p>Step 3: Check mailbox configuration: <pre><code>// Verify mailbox capacity if bounded\nlet mailbox = Mailbox::bounded(100);  // May drop or block if full\n</code></pre></p> <p>Solution:</p> <p>If mailbox closed: <pre><code>// Check actor hasn't stopped\nif !actor_ref.is_stopped() {\n    actor_ref.send(msg).await?;\n}\n</code></pre></p> <p>If bounded mailbox full: <pre><code>// Use larger capacity or unbounded mailbox\nlet mailbox = Mailbox::unbounded();\n\n// Or use blocking backpressure\nlet mailbox = Mailbox::bounded_with_backpressure(\n    100,\n    BackpressureStrategy::Block\n);\n</code></pre></p> <p>If wrong reference: <pre><code>// Use correct actor reference from spawn\nlet actor_ref = system.spawn(actor).await?;\n// Use this exact reference, not cloned outdated references\n</code></pre></p> <p>Prevention: - Always check send results - Monitor actor lifecycle state - Use appropriate mailbox configuration - Keep track of valid actor references</p>"},{"location":"components/rt/reference/troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"components/rt/reference/troubleshooting/#issue-8-high-message-latency","title":"Issue 8: High message latency","text":"<p>Symptom: Message processing takes significantly longer than expected (&gt;10ms for simple operations).</p> <p>Diagnostic:</p> <p>Check baseline performance: <pre><code># Run benchmarks to establish baseline\ncargo bench --bench message_benchmarks\n</code></pre></p> <p>Expected baselines: - Point-to-point messaging: ~737ns - Message broker routing: ~181ns overhead - Actor spawn: ~625ns</p> <p>Causes and Solutions:</p> <p>Cause 1: Message broker overhead</p> <p>Diagnosis: <pre><code>// Measure with and without broker\nlet start = Instant::now();\nactor_ref.send(msg).await?;  // Via broker\nlet duration = start.elapsed();\n// If &gt;10\u00b5s, broker may be bottleneck\n</code></pre></p> <p>Solution: <pre><code>// Use direct actor references for hot paths\nlet actor_ref = system.spawn(actor).await?;\nactor_ref.send(msg).await?;  // Direct send, no broker routing\n</code></pre></p> <p>Cause 2: Bounded mailbox backpressure</p> <p>Diagnosis: <pre><code>// Check if blocking on send\n// If mailbox is bounded with Block strategy, may wait for capacity\n</code></pre></p> <p>Solution: <pre><code>// Use larger capacity or unbounded mailbox for high-throughput actors\nlet actor = MyActor::builder()\n    .with_mailbox(Mailbox::unbounded())\n    .build();\n</code></pre></p> <p>Cause 3: Inefficient message serialization</p> <p>Diagnosis: <pre><code>// Large message types may cause allocation overhead\n#[derive(Clone)]  // Clone overhead for large structs\nstruct HugeMessage {\n    data: Vec&lt;u8&gt;,  // Large allocation\n}\n</code></pre></p> <p>Solution: <pre><code>// Use Arc for shared data\nuse std::sync::Arc;\n\n#[derive(Clone)]\nstruct EfficientMessage {\n    data: Arc&lt;Vec&lt;u8&gt;&gt;,  // Cheap clone via Arc\n}\n</code></pre></p> <p>Cause 4: Contention on message broker</p> <p>Diagnosis: <pre><code>// Many actors publishing to broker simultaneously\n// Check if broker registration lock is hot path\n</code></pre></p> <p>Solution: <pre><code>// Use direct actor references instead of broker for high-frequency messaging\n// Reserve broker for discovery and pub-sub patterns\n</code></pre></p> <p>Prevention: - Benchmark message paths regularly - Use direct actor references for hot paths - Profile with <code>cargo flamegraph</code> to identify bottlenecks - Monitor mailbox queue depth</p>"},{"location":"components/rt/reference/troubleshooting/#issue-9-memory-usage-growing-unbounded","title":"Issue 9: Memory usage growing unbounded","text":"<p>Symptom: Process memory continuously grows, never stabilizes.</p> <p>Diagnostic:</p> <p>Check mailbox growth: <pre><code>// Monitor mailbox queue depth\n// If continuously growing, producer faster than consumer\n</code></pre></p> <p>Run memory profiling: <pre><code># Use heaptrack or valgrind\nheaptrack target/release/my_app\nheaptrack --analyze heaptrack.my_app.*.gz\n</code></pre></p> <p>Causes and Solutions:</p> <p>Cause 1: Unbounded mailbox with slow consumer</p> <p>Diagnosis: <pre><code>// Messages accumulating faster than processing\n// Unbounded mailbox allows unlimited growth\n</code></pre></p> <p>Solution: <pre><code>// Use bounded mailbox with backpressure\nlet mailbox = Mailbox::bounded_with_backpressure(\n    1000,\n    BackpressureStrategy::Block  // Apply backpressure to producer\n);\n</code></pre></p> <p>Cause 2: Actors not being cleaned up</p> <p>Diagnosis: <pre><code>// Actor references held indefinitely\n// Stopped actors not garbage collected\n</code></pre></p> <p>Solution: <pre><code>// Explicitly stop and drop actors\nctx.stop();\ndrop(actor_ref);  // Release reference\n</code></pre></p> <p>Cause 3: Message retention in broker</p> <p>Diagnosis: <pre><code>// Broker retains actor registrations after actors stop\n</code></pre></p> <p>Solution: <pre><code>// Deregister actors on stop\nbroker.deregister(actor_id).await?;\n</code></pre></p> <p>Cause 4: Leaked actor references</p> <p>Diagnosis: <pre><code>// ActorRef stored in long-lived collections\nstatic ACTORS: Mutex&lt;Vec&lt;ActorRef&lt;MyActor&gt;&gt;&gt; = Mutex::new(Vec::new());\n</code></pre></p> <p>Solution: <pre><code>// Use weak references or clear collections\nuse std::sync::Weak;\n\n// Or periodically clean up stopped actors\nactors.retain(|actor_ref| !actor_ref.is_stopped());\n</code></pre></p> <p>Prevention: - Use bounded mailboxes for all non-critical actors - Implement proper actor lifecycle management - Monitor memory metrics continuously - Profile memory regularly during development</p>"},{"location":"components/rt/reference/troubleshooting/#supervisor-problems","title":"Supervisor Problems","text":""},{"location":"components/rt/reference/troubleshooting/#issue-10-supervisor-not-restarting-children","title":"Issue 10: Supervisor not restarting children","text":"<p>Symptom: Child actor crashes but supervisor does not restart it.</p> <p>Diagnostic:</p> <p>Check restart limits: <pre><code>// Verify max_restarts and restart_window configuration\nlet spec = ChildSpec::new(\"my-actor\")\n    .with_max_restarts(5)  // May have exceeded limit\n    .with_restart_window(Duration::from_secs(60));\n</code></pre></p> <p>Check supervisor strategy: <pre><code>// Verify strategy is not Abort\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)  // Should restart\n    .build()\n    .await?;\n</code></pre></p> <p>Causes and Solutions:</p> <p>Cause 1: Restart limit exceeded</p> <p>Diagnosis: <pre><code>// Child has crashed more than max_restarts within restart_window\n// Supervisor gives up restarting\n</code></pre></p> <p>Solution: <pre><code>// Increase restart limits if crashes are transient\nlet spec = ChildSpec::new(\"my-actor\")\n    .with_max_restarts(10)  // Higher limit\n    .with_restart_window(Duration::from_secs(300));  // Longer window\n\n// Or fix underlying issue causing repeated crashes\n</code></pre></p> <p>Cause 2: Strategy set to Abort</p> <p>Diagnosis: <pre><code>// Supervisor configured to abort on child failure\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::Abort)  // No restart!\n    .build()\n    .await?;\n</code></pre></p> <p>Solution: <pre><code>// Use appropriate restart strategy\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)  // Restart individual child\n    .build()\n    .await?;\n</code></pre></p> <p>Cause 3: Child not properly registered</p> <p>Diagnosis: <pre><code>// Child spawned outside supervisor\nlet actor_ref = system.spawn(actor).await?;  // Not supervised!\n</code></pre></p> <p>Solution: <pre><code>// Register child with supervisor\nlet supervisor = SupervisorBuilder::new()\n    .with_child(\n        ChildSpec::new(\"my-actor\")\n            .with_actor::&lt;MyActor&gt;()\n    )\n    .build()\n    .await?;\n</code></pre></p> <p>Prevention: - Configure appropriate restart limits for expected failure rates - Choose restart strategy matching fault tolerance requirements - Always register critical actors with supervisor - Monitor supervisor restart metrics</p>"},{"location":"components/rt/reference/troubleshooting/#issue-11-oneforall-strategy-causing-cascading-restarts","title":"Issue 11: OneForAll strategy causing cascading restarts","text":"<p>Symptom: One child failure triggers restart of all children, causing service disruption.</p> <p>Diagnostic:</p> <p>Check restart strategy: <pre><code>// Verify if OneForAll is actually needed\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForAll)  // Restarts all children\n    .build()\n    .await?;\n</code></pre></p> <p>Cause: OneForAll strategy restarts all children when any child fails, which may be unnecessary overhead.</p> <p>Solution:</p> <p>Use OneForOne if children are independent: <pre><code>// If children can fail independently without affecting others\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)  // Only restart failed child\n    .build()\n    .await?;\n</code></pre></p> <p>Use RestForOne if there's dependency order: <pre><code>// If later children depend on earlier children\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::RestForOne)  // Restart failed + later children\n    .build()\n    .await?;\n</code></pre></p> <p>Keep OneForAll only if truly needed: <pre><code>// Only if all children must restart together\n// Example: distributed transaction coordinators, state machines\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForAll)\n    .build()\n    .await?;\n</code></pre></p> <p>Prevention: - Choose minimal restart strategy meeting fault tolerance needs - Document why OneForAll or RestForOne is required - Monitor restart metrics to detect excessive restarts</p>"},{"location":"components/rt/reference/troubleshooting/#message-passing-issues","title":"Message Passing Issues","text":""},{"location":"components/rt/reference/troubleshooting/#issue-12-request-reply-timeout","title":"Issue 12: Request-reply timeout","text":"<p>Symptom: Request to actor times out without response.</p> <p>Diagnostic:</p> <p>Check timeout configuration: <pre><code>// Verify timeout is reasonable for operation\nlet result = actor_ref.send(msg)\n    .timeout(Duration::from_millis(100))  // May be too short\n    .await?;\n</code></pre></p> <p>Causes and Solutions:</p> <p>Cause 1: Timeout too short</p> <p>Diagnosis: <pre><code>// Operation legitimately takes longer than timeout\nasync fn handle(&amp;mut self, _msg: M, _ctx: &amp;mut ActorContext&lt;Self&gt;) {\n    // Complex operation takes 500ms\n    tokio::time::sleep(Duration::from_millis(500)).await;\n}\n</code></pre></p> <p>Solution: <pre><code>// Increase timeout to match operation duration\nlet result = actor_ref.send(msg)\n    .timeout(Duration::from_secs(1))  // Adequate timeout\n    .await?;\n</code></pre></p> <p>Cause 2: Actor mailbox full (with Block strategy)</p> <p>Diagnosis: <pre><code>// Message stuck in backpressure queue\n// Bounded mailbox with Block strategy\n</code></pre></p> <p>Solution: <pre><code>// Use larger mailbox capacity\nlet actor = MyActor::builder()\n    .with_mailbox(Mailbox::bounded(1000))  // Larger capacity\n    .build();\n\n// Or use Error strategy to fail fast\nlet actor = MyActor::builder()\n    .with_mailbox(Mailbox::bounded_with_backpressure(\n        100,\n        BackpressureStrategy::Error  // Immediate error if full\n    ))\n    .build();\n</code></pre></p> <p>Cause 3: Handler not sending response</p> <p>Diagnosis: <pre><code>// Handler doesn't return result properly\n#[async_trait]\nimpl Handler&lt;MyRequest&gt; for MyActor {\n    async fn handle(&amp;mut self, _msg: MyRequest, _ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; String {\n        // Forgot to return result!\n    }\n}\n</code></pre></p> <p>Solution: <pre><code>// Ensure handler returns result\n#[async_trait]\nimpl Handler&lt;MyRequest&gt; for MyActor {\n    async fn handle(&amp;mut self, _msg: MyRequest, _ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; String {\n        \"response\".to_string()  // Return result\n    }\n}\n</code></pre></p> <p>Prevention: - Set timeouts appropriate for operation latency - Monitor mailbox queue depth - Ensure all request handlers return results - Use fire-and-forget for operations not needing responses</p>"},{"location":"components/rt/reference/troubleshooting/#actor-lifecycle-issues","title":"Actor Lifecycle Issues","text":""},{"location":"components/rt/reference/troubleshooting/#issue-13-actor-stops-unexpectedly","title":"Issue 13: Actor stops unexpectedly","text":"<p>Symptom: Actor stops processing messages without explicit stop call.</p> <p>Diagnostic:</p> <p>Check lifecycle hooks: <pre><code>#[async_trait]\nimpl ActorLifecycle for MyActor {\n    async fn pre_start(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; Result&lt;(), ActorError&gt; {\n        // May return error causing immediate stop\n        Ok(())\n    }\n}\n</code></pre></p> <p>Causes and Solutions:</p> <p>Cause 1: <code>pre_start</code> returns error</p> <p>Diagnosis: <pre><code>async fn pre_start(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; Result&lt;(), ActorError&gt; {\n    // Initialization fails\n    self.initialize()?;  // Error causes actor to stop\n    Ok(())\n}\n</code></pre></p> <p>Solution: <pre><code>// Handle initialization errors gracefully\nasync fn pre_start(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; Result&lt;(), ActorError&gt; {\n    match self.initialize() {\n        Ok(_) =&gt; Ok(()),\n        Err(e) =&gt; {\n            eprintln!(\"Initialization failed: {:?}\", e);\n            // Return Ok with degraded state, or Err to stop\n            Err(ActorError::InitializationFailed(e))\n        }\n    }\n}\n</code></pre></p> <p>Cause 2: Unhandled panic in handler</p> <p>Diagnosis: <pre><code>async fn handle(&amp;mut self, msg: M, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; M::Result {\n    // Panic causes actor to stop if not supervised\n    panic!(\"Unexpected error!\");\n}\n</code></pre></p> <p>Solution: <pre><code>// Handle errors gracefully without panicking\nasync fn handle(&amp;mut self, msg: M, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; M::Result {\n    match self.process(msg) {\n        Ok(result) =&gt; result,\n        Err(e) =&gt; {\n            eprintln!(\"Handler error: {:?}\", e);\n            // Return error result instead of panicking\n            Default::default()\n        }\n    }\n}\n\n// Or supervise actor to restart on panic\nlet supervisor = SupervisorBuilder::new()\n    .with_child(\n        ChildSpec::new(\"my-actor\")\n            .with_actor::&lt;MyActor&gt;()\n            .with_max_restarts(5)\n    )\n    .build()\n    .await?;\n</code></pre></p> <p>Prevention: - Validate initialization conditions in <code>pre_start</code> - Use supervisor for critical actors - Avoid panics in handlers, use error results - Log lifecycle events for debugging</p>"},{"location":"components/rt/reference/troubleshooting/#mailbox-problems","title":"Mailbox Problems","text":""},{"location":"components/rt/reference/troubleshooting/#issue-14-bounded-mailbox-rejecting-messages","title":"Issue 14: Bounded mailbox rejecting messages","text":"<p>Symptom: Send operations fail with mailbox full error.</p> <p>Diagnostic:</p> <p>Check backpressure strategy: <pre><code>let mailbox = Mailbox::bounded_with_backpressure(\n    100,\n    BackpressureStrategy::Error  // Immediate error if full\n);\n</code></pre></p> <p>Causes and Solutions:</p> <p>Cause 1: Consumer slower than producer</p> <p>Diagnosis: <pre><code>// Messages arriving faster than actor processes them\n// Mailbox capacity exceeded\n</code></pre></p> <p>Solution:</p> <p>Option 1: Increase capacity: <pre><code>let mailbox = Mailbox::bounded(1000);  // Larger buffer\n</code></pre></p> <p>Option 2: Use Block strategy: <pre><code>// Apply backpressure to producer\nlet mailbox = Mailbox::bounded_with_backpressure(\n    100,\n    BackpressureStrategy::Block\n);\n</code></pre></p> <p>Option 3: Optimize consumer: <pre><code>// Make handler more efficient\nasync fn handle(&amp;mut self, msg: M, ctx: &amp;mut ActorContext&lt;Self&gt;) {\n    // Optimize processing logic\n    self.process_efficiently(msg).await;\n}\n</code></pre></p> <p>Option 4: Add more consumers: <pre><code>// Use actor pool pattern\nfor i in 0..10 {\n    let actor = MyActor::new();\n    system.spawn(actor).await?;\n}\n</code></pre></p> <p>Cause 2: Bursty traffic patterns</p> <p>Diagnosis: <pre><code>// Traffic comes in bursts exceeding mailbox capacity\n// But average rate is sustainable\n</code></pre></p> <p>Solution: <pre><code>// Size mailbox for burst capacity\nlet peak_rate = 1000;  // messages per second\nlet burst_duration = 5;  // seconds\nlet capacity = peak_rate * burst_duration;\n\nlet mailbox = Mailbox::bounded(capacity);\n</code></pre></p> <p>Prevention: - Profile message rates during peak traffic - Size mailbox capacity for burst handling - Monitor mailbox queue depth metrics - Use appropriate backpressure strategy</p>"},{"location":"components/rt/reference/troubleshooting/#system-configuration-issues","title":"System Configuration Issues","text":""},{"location":"components/rt/reference/troubleshooting/#issue-15-actorsystem-initialization-fails","title":"Issue 15: ActorSystem initialization fails","text":"<p>Symptom: System creation returns error or panics during initialization.</p> <p>Diagnostic:</p> <p>Check configuration: <pre><code>let config = SystemConfig::builder()\n    .with_name(\"my-system\")\n    .with_max_actors(10_000)\n    .build()?;\n</code></pre></p> <p>Causes and Solutions:</p> <p>Cause 1: Invalid configuration values</p> <p>Diagnosis: <pre><code>// Configuration values out of valid range\nlet config = SystemConfig::builder()\n    .with_max_actors(0)  // Invalid: must be &gt; 0\n    .build()?;  // Returns error\n</code></pre></p> <p>Solution: <pre><code>// Use valid configuration values\nlet config = SystemConfig::builder()\n    .with_name(\"my-system\")\n    .with_max_actors(10_000)  // Valid: &gt; 0\n    .build()?;\n</code></pre></p> <p>Cause 2: Insufficient resources</p> <p>Diagnosis: <pre><code>// System configuration exceeds available resources\nlet config = SystemConfig::builder()\n    .with_max_actors(1_000_000)  // May exceed memory limits\n    .build()?;\n</code></pre></p> <p>Solution: <pre><code>// Configure based on available resources\nlet available_memory = 4_000_000_000;  // 4GB in bytes\nlet actor_overhead = 1024;  // Approximate bytes per actor\nlet safe_max_actors = (available_memory / actor_overhead) / 2;  // 50% margin\n\nlet config = SystemConfig::builder()\n    .with_max_actors(safe_max_actors)\n    .build()?;\n</code></pre></p> <p>Cause 3: Runtime not initialized</p> <p>Diagnosis: <pre><code>// Tokio runtime not available\n#[tokio::main]  // Missing!\nasync fn main() {\n    let system = ActorSystem::new(config).await?;\n}\n</code></pre></p> <p>Solution: <pre><code>// Ensure Tokio runtime is initialized\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let config = SystemConfig::default();\n    let system = ActorSystem::new(config).await?;\n    Ok(())\n}\n</code></pre></p> <p>Prevention: - Validate configuration values before system creation - Size system based on available resources - Ensure async runtime is properly initialized - Use SystemConfig::default() as starting point</p>"},{"location":"components/rt/reference/troubleshooting/#additional-resources","title":"Additional Resources","text":""},{"location":"components/rt/reference/troubleshooting/#debug-tools","title":"Debug Tools","text":"<p>Enable debug logging: <pre><code>use tracing_subscriber;\n\ntracing_subscriber::fmt()\n    .with_max_level(tracing::Level::DEBUG)\n    .init();\n</code></pre></p> <p>Monitor actor health: <pre><code>use airssys_rt::monitoring::{HealthMonitor, HealthCheck};\n\nlet monitor = HealthMonitor::new();\nmonitor.register(actor_ref, PingHealthCheck::new()).await?;\n\nlet status = monitor.check_health(actor_ref).await?;\n</code></pre></p> <p>Profile performance: <pre><code># CPU profiling\ncargo flamegraph --bin my_app\n\n# Memory profiling\nheaptrack target/release/my_app\n\n# Benchmark comparisons\ncargo bench --bench actor_benchmarks\n</code></pre></p>"},{"location":"components/rt/reference/troubleshooting/#common-patterns","title":"Common Patterns","text":"<p>Graceful shutdown: <pre><code>// Shutdown signal handling\ntokio::select! {\n    _ = tokio::signal::ctrl_c() =&gt; {\n        println!(\"Shutdown signal received\");\n        system.shutdown().await?;\n    }\n}\n</code></pre></p> <p>Error recovery: <pre><code>// Retry with exponential backoff\nuse tokio::time::sleep;\n\nfor attempt in 0..5 {\n    match operation().await {\n        Ok(result) =&gt; return Ok(result),\n        Err(e) if attempt &lt; 4 =&gt; {\n            let delay = Duration::from_millis(100 * 2_u64.pow(attempt));\n            sleep(delay).await;\n            continue;\n        }\n        Err(e) =&gt; return Err(e),\n    }\n}\n</code></pre></p>"},{"location":"components/rt/reference/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you encounter issues not covered in this guide:</p> <ol> <li>Check API Reference: Detailed API documentation available in API Reference</li> <li>Review Examples: Working code examples in the <code>examples/</code> directory</li> <li>Run Benchmarks: Verify baseline performance with <code>cargo bench</code></li> <li>Enable Debug Logging: Use <code>tracing</code> for detailed runtime information</li> <li>Report Issues: GitHub issues for bugs and feature requests</li> </ol>"},{"location":"components/rt/reference/troubleshooting/#performance-baselines","title":"Performance Baselines","text":"<p>Reference Performance (October 16, 2025 baseline):</p> Operation P50 Latency P95 Latency P99 Latency Actor Spawn 624.74 ns 675.14 ns 762.47 ns Message Send (Direct) 737.16 ns 798.93 ns 876.44 ns Child Spawn (Supervised) 1.28 \u00b5s 1.39 \u00b5s 1.52 \u00b5s Broker Routing 181 ns - - <p>See Performance Reference for complete baseline metrics.</p> <p>Last Updated: 2025-01-18 (RT-TASK-011 Phase 4 Day 7)</p>"},{"location":"components/rt/reference/api/actors/","title":"Actors API Reference","text":"<p>This reference documents actor-specific types, lifecycle management, and handler patterns.</p>"},{"location":"components/rt/reference/api/actors/#module-actor","title":"Module: <code>actor</code>","text":"<p>Actor implementation and lifecycle types.</p>"},{"location":"components/rt/reference/api/actors/#trait-handlerm","title":"Trait: <code>Handler&lt;M&gt;</code>","text":"<pre><code>pub trait Handler&lt;M&gt;: Actor\nwhere\n    M: Message,\n{\n    async fn handle(&amp;mut self, msg: M, ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; M::Result;\n}\n</code></pre> <p>Trait for actors that can handle specific message types.</p> <p>Type Parameters: - <code>M</code>: The message type this handler processes</p> <p>Required Methods:</p> <ul> <li><code>handle()</code>: Processes a message and returns its result</li> </ul> <p>Trait Bounds: - Must implement <code>Actor</code> - <code>M</code> must implement <code>Message</code></p> <p>Example:</p> <pre><code>use airssys_rt::{Actor, ActorContext, Handler, Message};\n\nstruct Counter {\n    count: i32,\n}\n\nstruct GetCount;\nimpl Message for GetCount {\n    type Result = i32;\n}\n\nstruct Increment {\n    amount: i32,\n}\nimpl Message for Increment {\n    type Result = ();\n}\n\nimpl Actor for Counter {\n    async fn receive(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;, msg: Box&lt;dyn Message&gt;) {\n        // Generic receive implementation\n    }\n}\n\nimpl Handler&lt;GetCount&gt; for Counter {\n    async fn handle(&amp;mut self, _msg: GetCount, _ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; i32 {\n        self.count\n    }\n}\n\nimpl Handler&lt;Increment&gt; for Counter {\n    async fn handle(&amp;mut self, msg: Increment, _ctx: &amp;mut ActorContext&lt;Self&gt;) {\n        self.count += msg.amount;\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/actors/#lifecycle-management","title":"Lifecycle Management","text":""},{"location":"components/rt/reference/api/actors/#struct-actorlifecycle","title":"Struct: <code>ActorLifecycle</code>","text":"<pre><code>pub struct ActorLifecycle {\n    pub state: LifecycleState,\n    pub restart_count: u32,\n    pub last_error: Option&lt;String&gt;,\n}\n</code></pre> <p>Tracks actor lifecycle state and restart history.</p> <p>Fields:</p> <ul> <li><code>state</code>: Current lifecycle state</li> <li><code>restart_count</code>: Number of times actor has been restarted</li> <li><code>last_error</code>: Most recent error message, if any</li> </ul> <p>See Also: - Architecture: Process Lifecycle</p>"},{"location":"components/rt/reference/api/actors/#enum-lifecyclestate","title":"Enum: <code>LifecycleState</code>","text":"<pre><code>pub enum LifecycleState {\n    Starting,\n    Running,\n    Stopping,\n    Stopped,\n    Failed,\n}\n</code></pre> <p>Represents the current state of an actor.</p> <p>Variants:</p> <ul> <li><code>Starting</code>: Actor is initializing (in <code>pre_start()</code>)</li> <li><code>Running</code>: Actor is actively processing messages</li> <li><code>Stopping</code>: Actor is shutting down (in <code>post_stop()</code>)</li> <li><code>Stopped</code>: Actor has completed shutdown</li> <li><code>Failed</code>: Actor encountered fatal error</li> </ul> <p>State Transitions:</p> <pre><code>Starting -&gt; Running       (pre_start() succeeded)\nStarting -&gt; Failed        (pre_start() failed)\nRunning -&gt; Stopping       (stop() called or system shutdown)\nRunning -&gt; Failed         (unrecoverable error)\nStopping -&gt; Stopped       (post_stop() completed)\nFailed -&gt; Starting        (supervisor restart)\n</code></pre> <p>Example:</p> <pre><code>use airssys_rt::actor::{ActorLifecycle, LifecycleState};\n\nfn check_actor_state(lifecycle: &amp;ActorLifecycle) {\n    match lifecycle.state {\n        LifecycleState::Running =&gt; println!(\"Actor is healthy\"),\n        LifecycleState::Failed =&gt; {\n            println!(\"Actor failed: {:?}\", lifecycle.last_error);\n            println!(\"Restart count: {}\", lifecycle.restart_count);\n        }\n        _ =&gt; println!(\"Actor in transition: {:?}\", lifecycle.state),\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/actors/#enum-erroraction","title":"Enum: <code>ErrorAction</code>","text":"<pre><code>pub enum ErrorAction {\n    Resume,\n    Restart,\n    Stop,\n    Escalate,\n}\n</code></pre> <p>Action to take when an actor encounters an error.</p> <p>Variants:</p> <ul> <li><code>Resume</code>: Continue processing messages (error was handled)</li> <li><code>Restart</code>: Restart the actor (preserves supervision)</li> <li><code>Stop</code>: Stop the actor permanently</li> <li><code>Escalate</code>: Escalate error to supervisor</li> </ul> <p>Decision Guide:</p> Error Type Recommended Action Rationale Transient failure <code>Resume</code> Error handled, can continue Corrupted state <code>Restart</code> Fresh start needed Invalid configuration <code>Stop</code> Cannot proceed Unknown/critical <code>Escalate</code> Let supervisor decide <p>Example:</p> <pre><code>use airssys_rt::actor::ErrorAction;\n\nasync fn handle_error(error: &amp;ActorError) -&gt; ErrorAction {\n    match error {\n        ActorError::Timeout =&gt; ErrorAction::Resume,\n        ActorError::InvalidState =&gt; ErrorAction::Restart,\n        ActorError::ConfigError(_) =&gt; ErrorAction::Stop,\n        _ =&gt; ErrorAction::Escalate,\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/actors/#actor-configuration","title":"Actor Configuration","text":""},{"location":"components/rt/reference/api/actors/#struct-actorconfig","title":"Struct: <code>ActorConfig</code>","text":"<pre><code>pub struct ActorConfig {\n    pub mailbox_capacity: usize,\n    pub max_restarts: u32,\n    pub restart_window: Duration,\n}\n</code></pre> <p>Configuration options for actor behavior.</p> <p>Fields:</p> <ul> <li><code>mailbox_capacity</code>: Maximum number of messages in mailbox (0 = unbounded)</li> <li><code>max_restarts</code>: Maximum restart attempts within restart window</li> <li><code>restart_window</code>: Time window for counting restarts</li> </ul> <p>Default Values:</p> <pre><code>impl Default for ActorConfig {\n    fn default() -&gt; Self {\n        Self {\n            mailbox_capacity: 1000,\n            max_restarts: 3,\n            restart_window: Duration::from_secs(10),\n        }\n    }\n}\n</code></pre> <p>Example:</p> <pre><code>use airssys_rt::actor::ActorConfig;\nuse std::time::Duration;\n\nlet config = ActorConfig {\n    mailbox_capacity: 5000,  // Larger buffer for high-throughput\n    max_restarts: 5,         // More lenient restart policy\n    restart_window: Duration::from_secs(30),\n};\n</code></pre>"},{"location":"components/rt/reference/api/actors/#actor-patterns","title":"Actor Patterns","text":""},{"location":"components/rt/reference/api/actors/#builder-pattern-rt-task-013","title":"Builder Pattern (RT-TASK-013)","text":"<p>The recommended pattern for creating actors with configuration.</p> <p>Example:</p> <pre><code>use airssys_rt::{Actor, ActorContext};\n\nstruct DatabaseActor {\n    connection_string: String,\n    pool_size: usize,\n    timeout: Duration,\n}\n\nimpl DatabaseActor {\n    pub fn builder() -&gt; DatabaseActorBuilder {\n        DatabaseActorBuilder::default()\n    }\n}\n\npub struct DatabaseActorBuilder {\n    connection_string: Option&lt;String&gt;,\n    pool_size: usize,\n    timeout: Duration,\n}\n\nimpl Default for DatabaseActorBuilder {\n    fn default() -&gt; Self {\n        Self {\n            connection_string: None,\n            pool_size: 10,\n            timeout: Duration::from_secs(5),\n        }\n    }\n}\n\nimpl DatabaseActorBuilder {\n    pub fn connection_string(mut self, conn: String) -&gt; Self {\n        self.connection_string = Some(conn);\n        self\n    }\n\n    pub fn pool_size(mut self, size: usize) -&gt; Self {\n        self.pool_size = size;\n        self\n    }\n\n    pub fn timeout(mut self, timeout: Duration) -&gt; Self {\n        self.timeout = timeout;\n        self\n    }\n\n    pub fn build(self) -&gt; Result&lt;DatabaseActor, BuildError&gt; {\n        let connection_string = self.connection_string\n            .ok_or(BuildError::MissingField(\"connection_string\"))?;\n\n        Ok(DatabaseActor {\n            connection_string,\n            pool_size: self.pool_size,\n            timeout: self.timeout,\n        })\n    }\n}\n\n// Usage\nlet actor = DatabaseActor::builder()\n    .connection_string(\"postgres://localhost\".to_string())\n    .pool_size(20)\n    .timeout(Duration::from_secs(10))\n    .build()?;\n</code></pre>"},{"location":"components/rt/reference/api/actors/#request-reply-pattern","title":"Request-Reply Pattern","text":"<p>Pattern for synchronous-style communication between actors.</p> <p>Example:</p> <pre><code>use airssys_rt::{Actor, ActorContext, ActorRef, Handler, Message};\n\n// Request message with reply channel\nstruct ComputeSum {\n    numbers: Vec&lt;i32&gt;,\n}\n\nimpl Message for ComputeSum {\n    type Result = i32;\n}\n\nstruct Calculator;\n\nimpl Actor for Calculator {\n    async fn receive(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;, msg: Box&lt;dyn Message&gt;) {\n        // Handle messages\n    }\n}\n\nimpl Handler&lt;ComputeSum&gt; for Calculator {\n    async fn handle(&amp;mut self, msg: ComputeSum, _ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; i32 {\n        msg.numbers.iter().sum()\n    }\n}\n\n// Usage\nasync fn compute(calculator: &amp;ActorRef&lt;Calculator&gt;) -&gt; i32 {\n    calculator.send(ComputeSum {\n        numbers: vec![1, 2, 3, 4, 5],\n    }).await.unwrap()\n}\n</code></pre>"},{"location":"components/rt/reference/api/actors/#actor-pool-pattern","title":"Actor Pool Pattern","text":"<p>Pattern for load balancing across multiple worker actors.</p> <p>Example:</p> <pre><code>use airssys_rt::{Actor, ActorContext, ActorRef};\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse std::sync::Arc;\n\nstruct WorkerPool&lt;W: Actor&gt; {\n    workers: Vec&lt;ActorRef&lt;W&gt;&gt;,\n    next: Arc&lt;AtomicUsize&gt;,\n}\n\nimpl&lt;W: Actor&gt; WorkerPool&lt;W&gt; {\n    pub fn new(workers: Vec&lt;ActorRef&lt;W&gt;&gt;) -&gt; Self {\n        Self {\n            workers,\n            next: Arc::new(AtomicUsize::new(0)),\n        }\n    }\n\n    pub fn get_worker(&amp;self) -&gt; &amp;ActorRef&lt;W&gt; {\n        let index = self.next.fetch_add(1, Ordering::Relaxed) % self.workers.len();\n        &amp;self.workers[index]\n    }\n}\n\n// Usage\nasync fn create_pool(system: &amp;ActorSystem) -&gt; WorkerPool&lt;Worker&gt; {\n    let mut workers = Vec::new();\n    for _ in 0..4 {\n        workers.push(system.spawn(Worker::new()).await.unwrap());\n    }\n    WorkerPool::new(workers)\n}\n</code></pre>"},{"location":"components/rt/reference/api/actors/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"components/rt/reference/api/actors/#actor-operations","title":"Actor Operations","text":"Operation Latency Throughput Notes Actor spawn ~624ns 1.6M/sec Includes mailbox setup Message send ~181ns 5.5M/sec Mailbox enqueue only Message roundtrip ~737ns 4.7M/sec Send + process + reply Actor stop ~2-5\u00b5s - Includes cleanup"},{"location":"components/rt/reference/api/actors/#memory-usage","title":"Memory Usage","text":"Component Base Size Per-Message Notes Actor struct Varies - User-defined state ActorRef 16 bytes - Arc + ID ActorContext ~256 bytes - Per actor instance Mailbox (bounded) 8KB 64 bytes Capacity 1000 Mailbox (unbounded) 128 bytes 64 bytes Grows dynamically <p>See Also: - Performance Reference - Detailed benchmarks - BENCHMARKING.md - Raw benchmark data</p>"},{"location":"components/rt/reference/api/actors/#error-handling","title":"Error Handling","text":""},{"location":"components/rt/reference/api/actors/#enum-actorerror","title":"Enum: <code>ActorError</code>","text":"<pre><code>pub enum ActorError {\n    Timeout,\n    InvalidState,\n    ConfigError(String),\n    MessageError(String),\n    Custom(Box&lt;dyn Error + Send + Sync&gt;),\n}\n</code></pre> <p>Errors specific to actor operations.</p> <p>Variants:</p> <ul> <li><code>Timeout</code>: Operation timed out</li> <li><code>InvalidState</code>: Actor in invalid state for operation</li> <li><code>ConfigError(String)</code>: Configuration error with description</li> <li><code>MessageError(String)</code>: Message processing error</li> <li><code>Custom(Box&lt;dyn Error&gt;)</code>: User-defined error</li> </ul> <p>Example:</p> <pre><code>use airssys_rt::actor::ActorError;\n\nimpl Actor for MyActor {\n    async fn receive(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;, msg: Box&lt;dyn Message&gt;) {\n        // Handle message\n        if invalid_state {\n            return Err(ActorError::InvalidState);\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/actors/#testing-utilities","title":"Testing Utilities","text":""},{"location":"components/rt/reference/api/actors/#struct-testprobea","title":"Struct: <code>TestProbe&lt;A&gt;</code>","text":"<pre><code>pub struct TestProbe&lt;A: Actor&gt; {\n    // fields omitted\n}\n</code></pre> <p>Testing utility for observing actor behavior.</p> <p>Available in: Test builds only (<code>#[cfg(test)]</code>)</p>"},{"location":"components/rt/reference/api/actors/#methods","title":"Methods","text":""},{"location":"components/rt/reference/api/actors/#expect_msg","title":"<code>expect_msg()</code>","text":"<pre><code>pub async fn expect_msg&lt;M&gt;(&amp;mut self, timeout: Duration) -&gt; Option&lt;M&gt;\nwhere\n    M: Message,\n</code></pre> <p>Waits for a specific message type.</p> <p>Example:</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use airssys_rt::actor::TestProbe;\n\n    #[tokio::test]\n    async fn test_actor_sends_response() {\n        let mut probe = TestProbe::&lt;MyActor&gt;::new();\n        // ... send message to actor ...\n        let response = probe.expect_msg::&lt;ResponseMsg&gt;(Duration::from_secs(1))\n            .await\n            .expect(\"Expected response\");\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/actors/#see-also","title":"See Also","text":"<ul> <li>Core API Reference - Core types and system API</li> <li>Messaging API Reference - Message broker and delivery</li> <li>Supervisors API Reference - Supervision patterns</li> <li>How-To: Actor Development - Actor development guide</li> <li>Architecture: Actor Model - Conceptual overview</li> </ul>"},{"location":"components/rt/reference/api/broker/","title":"Message Broker API Reference","text":"<p>This reference documents the message broker system for routing messages between actors.</p>"},{"location":"components/rt/reference/api/broker/#module-broker","title":"Module: <code>broker</code>","text":"<p>Message routing and delivery infrastructure.</p>"},{"location":"components/rt/reference/api/broker/#trait-messagebroker","title":"Trait: <code>MessageBroker</code>","text":"<pre><code>pub trait MessageBroker: Send + Sync {\n    async fn send&lt;M&gt;(&amp;self, actor_id: ActorId, msg: M) -&gt; Result&lt;M::Result, SendError&gt;\n    where\n        M: Message;\n\n    async fn broadcast&lt;M&gt;(&amp;self, msg: M) -&gt; Vec&lt;Result&lt;M::Result, SendError&gt;&gt;\n    where\n        M: Message + Clone;\n\n    fn register&lt;A&gt;(&amp;self, actor_id: ActorId, mailbox: Mailbox&lt;A&gt;) -&gt; Result&lt;(), BrokerError&gt;\n    where\n        A: Actor;\n\n    fn unregister(&amp;self, actor_id: ActorId) -&gt; Result&lt;(), BrokerError&gt;;\n}\n</code></pre> <p>Core trait for message routing and delivery.</p> <p>Required Methods:</p> <ul> <li><code>send()</code>: Sends message to specific actor and awaits result</li> <li><code>broadcast()</code>: Sends message to all registered actors</li> <li><code>register()</code>: Registers an actor's mailbox for message delivery</li> <li><code>unregister()</code>: Removes an actor from the broker</li> </ul> <p>Trait Bounds: - <code>Send + Sync</code>: Can be safely shared across threads</p> <p>Implementations: - <code>InMemoryMessageBroker</code>: Default in-memory broker (production-ready) - <code>DistributedMessageBroker</code>: Future distributed broker implementation</p>"},{"location":"components/rt/reference/api/broker/#struct-inmemorymessagebroker","title":"Struct: <code>InMemoryMessageBroker</code>","text":"<pre><code>pub struct InMemoryMessageBroker {\n    // fields omitted\n}\n</code></pre> <p>High-performance in-memory message broker.</p> <p>Architecture: - Lock-free routing using <code>DashMap&lt;ActorId, Mailbox&gt;</code> - Per-actor mailbox isolation (no shared state) - Zero-copy message passing where possible - Concurrent send/receive operations</p> <p>Performance Characteristics: - Send latency: ~737ns (includes actor processing) - Routing overhead: ~50ns - Broadcast (10 actors): ~12M msgs/sec - Memory: ~48 bytes per registered actor</p>"},{"location":"components/rt/reference/api/broker/#constructors","title":"Constructors","text":""},{"location":"components/rt/reference/api/broker/#new","title":"<code>new()</code>","text":"<pre><code>pub fn new() -&gt; Self\n</code></pre> <p>Creates a new in-memory message broker.</p> <p>Returns: - <code>InMemoryMessageBroker</code>: New broker instance ready for use</p> <p>Example:</p> <pre><code>use airssys_rt::broker::InMemoryMessageBroker;\n\nlet broker = InMemoryMessageBroker::new();\n</code></pre>"},{"location":"components/rt/reference/api/broker/#with_capacity","title":"<code>with_capacity()</code>","text":"<pre><code>pub fn with_capacity(capacity: usize) -&gt; Self\n</code></pre> <p>Creates a broker with pre-allocated capacity.</p> <p>Parameters: - <code>capacity</code>: Expected number of actors to register</p> <p>Performance: - Reduces allocations during actor registration - Useful for systems with known actor counts</p> <p>Example:</p> <pre><code>// System with ~1000 actors\nlet broker = InMemoryMessageBroker::with_capacity(1000);\n</code></pre>"},{"location":"components/rt/reference/api/broker/#registration-methods","title":"Registration Methods","text":""},{"location":"components/rt/reference/api/broker/#register","title":"<code>register()</code>","text":"<pre><code>pub fn register&lt;A&gt;(&amp;self, actor_id: ActorId, mailbox: Mailbox&lt;A&gt;) -&gt; Result&lt;(), BrokerError&gt;\nwhere\n    A: Actor,\n</code></pre> <p>Registers an actor's mailbox with the broker.</p> <p>Type Parameters: - <code>A</code>: The actor type</p> <p>Parameters: - <code>actor_id</code>: Unique identifier for the actor - <code>mailbox</code>: The actor's mailbox for receiving messages</p> <p>Returns: - <code>Ok(())</code>: Registration successful - <code>Err(BrokerError::AlreadyRegistered)</code>: Actor ID already in use</p> <p>Thread Safety: - Safe to call from multiple threads concurrently - Atomic registration operation</p> <p>Example:</p> <pre><code>use airssys_rt::mailbox::Mailbox;\nuse airssys_rt::util::ActorId;\n\nlet actor_id = ActorId::new();\nlet mailbox = Mailbox::&lt;MyActor&gt;::bounded(1000);\n\nbroker.register(actor_id, mailbox)?;\n</code></pre>"},{"location":"components/rt/reference/api/broker/#unregister","title":"<code>unregister()</code>","text":"<pre><code>pub fn unregister(&amp;self, actor_id: ActorId) -&gt; Result&lt;(), BrokerError&gt;\n</code></pre> <p>Unregisters an actor from the broker.</p> <p>Parameters: - <code>actor_id</code>: The actor to unregister</p> <p>Returns: - <code>Ok(())</code>: Unregistration successful - <code>Err(BrokerError::NotFound)</code>: Actor not registered</p> <p>Behavior: - Removes actor from routing table - Remaining messages in mailbox are dropped - In-flight sends will fail with <code>SendError::ActorNotFound</code> - Safe to call multiple times (idempotent after first success)</p> <p>Example:</p> <pre><code>broker.unregister(actor_id)?;\n</code></pre>"},{"location":"components/rt/reference/api/broker/#message-delivery-methods","title":"Message Delivery Methods","text":""},{"location":"components/rt/reference/api/broker/#send","title":"<code>send()</code>","text":"<pre><code>pub async fn send&lt;M&gt;(&amp;self, actor_id: ActorId, msg: M) -&gt; Result&lt;M::Result, SendError&gt;\nwhere\n    M: Message,\n</code></pre> <p>Sends a message to a specific actor and awaits the result.</p> <p>Type Parameters: - <code>M</code>: The message type</p> <p>Parameters: - <code>actor_id</code>: Target actor identifier - <code>msg</code>: The message to send</p> <p>Returns: - <code>Ok(M::Result)</code>: Message processed successfully, contains result - <code>Err(SendError::ActorNotFound)</code>: Actor not registered - <code>Err(SendError::ActorStopped)</code>: Actor has stopped - <code>Err(SendError::MailboxFull)</code>: Actor's mailbox at capacity - <code>Err(SendError::Timeout)</code>: Operation timed out</p> <p>Performance: - Average latency: ~737ns (routing + delivery + processing) - Routing overhead: ~50ns - Throughput: ~4.7M messages/second (single actor)</p> <p>Example:</p> <pre><code>use airssys_rt::Message;\n\nstruct GetBalance { account_id: u64 }\nimpl Message for GetBalance {\n    type Result = f64;\n}\n\nlet balance = broker.send(actor_id, GetBalance { account_id: 123 }).await?;\nprintln!(\"Account balance: ${:.2}\", balance);\n</code></pre>"},{"location":"components/rt/reference/api/broker/#try_send","title":"<code>try_send()</code>","text":"<pre><code>pub fn try_send&lt;M&gt;(&amp;self, actor_id: ActorId, msg: M) -&gt; Result&lt;(), SendError&gt;\nwhere\n    M: Message&lt;Result = ()&gt;,\n</code></pre> <p>Attempts to send a fire-and-forget message without blocking.</p> <p>Type Parameters: - <code>M</code>: The message type (must have <code>Result = ()</code>)</p> <p>Parameters: - <code>actor_id</code>: Target actor - <code>msg</code>: Message to send</p> <p>Returns: - <code>Ok(())</code>: Message enqueued successfully - <code>Err(SendError)</code>: Delivery failed</p> <p>Performance: - Non-blocking operation - Lower latency than <code>send()</code> (~181ns) - No result returned</p> <p>Example:</p> <pre><code>struct LogEvent { message: String }\nimpl Message for LogEvent {\n    type Result = ();\n}\n\nbroker.try_send(logger_id, LogEvent {\n    message: \"User logged in\".to_string(),\n})?;\n</code></pre>"},{"location":"components/rt/reference/api/broker/#broadcast","title":"<code>broadcast()</code>","text":"<pre><code>pub async fn broadcast&lt;M&gt;(&amp;self, msg: M) -&gt; Vec&lt;Result&lt;M::Result, SendError&gt;&gt;\nwhere\n    M: Message + Clone,\n</code></pre> <p>Broadcasts a message to all registered actors.</p> <p>Type Parameters: - <code>M</code>: The message type (must implement <code>Clone</code>)</p> <p>Parameters: - <code>msg</code>: The message to broadcast (will be cloned for each actor)</p> <p>Returns: - <code>Vec&lt;Result&lt;M::Result, SendError&gt;&gt;</code>: Results from all actors (one per registered actor)</p> <p>Behavior: - Parallel delivery to all actors - Individual failures don't affect other deliveries - Order of results matches registration order</p> <p>Performance: - Parallel delivery via <code>tokio::join_all</code> - Throughput: ~12M msgs/sec (10 actors) - Scales with actor count</p> <p>Example:</p> <pre><code>struct Shutdown;\nimpl Message for Shutdown {\n    type Result = ();\n}\n\nlet results = broker.broadcast(Shutdown).await;\n\nlet mut failed = 0;\nfor result in results {\n    if let Err(e) = result {\n        eprintln!(\"Shutdown failed: {:?}\", e);\n        failed += 1;\n    }\n}\n\nprintln!(\"Shutdown complete: {} failures\", failed);\n</code></pre>"},{"location":"components/rt/reference/api/broker/#broadcast_filter","title":"<code>broadcast_filter()</code>","text":"<pre><code>pub async fn broadcast_filter&lt;M, F&gt;(&amp;self, msg: M, filter: F) -&gt; Vec&lt;Result&lt;M::Result, SendError&gt;&gt;\nwhere\n    M: Message + Clone,\n    F: Fn(ActorId) -&gt; bool,\n</code></pre> <p>Broadcasts a message to actors matching a filter predicate.</p> <p>Type Parameters: - <code>M</code>: The message type - <code>F</code>: Filter function type</p> <p>Parameters: - <code>msg</code>: Message to broadcast - <code>filter</code>: Predicate to select target actors</p> <p>Returns: - <code>Vec&lt;Result&lt;M::Result, SendError&gt;&gt;</code>: Results from matching actors</p> <p>Example:</p> <pre><code>// Send only to worker actors (IDs 100-199)\nlet results = broker.broadcast_filter(\n    WorkItem { data: vec![] },\n    |id| {\n        let id_num = id.as_u64();\n        id_num &gt;= 100 &amp;&amp; id_num &lt; 200\n    }\n).await;\n</code></pre>"},{"location":"components/rt/reference/api/broker/#query-methods","title":"Query Methods","text":""},{"location":"components/rt/reference/api/broker/#is_registered","title":"<code>is_registered()</code>","text":"<pre><code>pub fn is_registered(&amp;self, actor_id: ActorId) -&gt; bool\n</code></pre> <p>Checks if an actor is registered with the broker.</p> <p>Parameters: - <code>actor_id</code>: Actor to check</p> <p>Returns: - <code>true</code>: Actor is registered - <code>false</code>: Actor not found</p> <p>Example:</p> <pre><code>if broker.is_registered(actor_id) {\n    broker.send(actor_id, msg).await?;\n} else {\n    eprintln!(\"Actor {} not found\", actor_id);\n}\n</code></pre>"},{"location":"components/rt/reference/api/broker/#registered_count","title":"<code>registered_count()</code>","text":"<pre><code>pub fn registered_count(&amp;self) -&gt; usize\n</code></pre> <p>Returns the number of registered actors.</p> <p>Returns: - <code>usize</code>: Count of registered actors</p> <p>Use Cases: - Monitoring system health - Capacity planning - Load balancing decisions</p> <p>Example:</p> <pre><code>let count = broker.registered_count();\nprintln!(\"Active actors: {}\", count);\n</code></pre>"},{"location":"components/rt/reference/api/broker/#actor_ids","title":"<code>actor_ids()</code>","text":"<pre><code>pub fn actor_ids(&amp;self) -&gt; Vec&lt;ActorId&gt;\n</code></pre> <p>Returns a snapshot of all registered actor IDs.</p> <p>Returns: - <code>Vec&lt;ActorId&gt;</code>: List of registered actors</p> <p>Note: - Snapshot at time of call - May become stale immediately - Use for monitoring/debugging, not synchronization</p> <p>Example:</p> <pre><code>let actors = broker.actor_ids();\nfor actor_id in actors {\n    println!(\"Registered: {}\", actor_id);\n}\n</code></pre>"},{"location":"components/rt/reference/api/broker/#routing-patterns","title":"Routing Patterns","text":""},{"location":"components/rt/reference/api/broker/#point-to-point","title":"Point-to-Point","text":"<p>Direct message delivery to specific actor.</p> <pre><code>// One sender, one receiver\nlet result = broker.send(worker_id, ProcessTask { id: 42 }).await?;\n</code></pre>"},{"location":"components/rt/reference/api/broker/#publish-subscribe","title":"Publish-Subscribe","text":"<p>Broadcast message to all interested actors.</p> <pre><code>// Publish event to all subscribers\nstruct UserCreated { user_id: u64 }\nimpl Message for UserCreated {\n    type Result = ();\n}\n\nbroker.broadcast(UserCreated { user_id: 123 }).await;\n</code></pre>"},{"location":"components/rt/reference/api/broker/#request-response","title":"Request-Response","text":"<p>Synchronous-style communication.</p> <pre><code>struct GetUserName { user_id: u64 }\nimpl Message for GetUserName {\n    type Result = String;\n}\n\nlet name = broker.send(db_actor_id, GetUserName { user_id: 42 }).await?;\n</code></pre>"},{"location":"components/rt/reference/api/broker/#fire-and-forget","title":"Fire-and-Forget","text":"<p>Asynchronous notification without response.</p> <pre><code>broker.try_send(logger_id, LogMessage {\n    level: Level::Info,\n    message: \"Task completed\".to_string(),\n})?;\n</code></pre>"},{"location":"components/rt/reference/api/broker/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"components/rt/reference/api/broker/#latency-breakdown","title":"Latency Breakdown","text":"Component Latency Percentage Routing lookup ~50ns 6.8% Mailbox enqueue ~181ns 24.6% Actor processing ~400ns 54.3% Result return ~106ns 14.4% Total roundtrip ~737ns 100%"},{"location":"components/rt/reference/api/broker/#throughput","title":"Throughput","text":"Scenario Messages/sec Notes Single actor 4.7M Baseline 4 actors (independent) 18M Linear scaling 16 actors (independent) 45M Sublinear scaling Broadcast (10 actors) 12M Parallel delivery Broadcast (100 actors) 8M Overhead increases"},{"location":"components/rt/reference/api/broker/#scalability","title":"Scalability","text":"Actor Count Send Latency Memory Overhead 10 737ns 480 bytes 100 745ns 4.8 KB 1,000 780ns 48 KB 10,000 850ns 480 KB 100,000 1.2\u00b5s 4.8 MB"},{"location":"components/rt/reference/api/broker/#memory-usage","title":"Memory Usage","text":"Component Size Per Actor Notes Broker base ~256 bytes - DashMap structure Routing entry ~48 bytes Yes ActorId + Mailbox ref Mailbox ref ~16 bytes Yes Arc pointer"},{"location":"components/rt/reference/api/broker/#error-types","title":"Error Types","text":""},{"location":"components/rt/reference/api/broker/#enum-brokererror","title":"Enum: <code>BrokerError</code>","text":"<pre><code>pub enum BrokerError {\n    AlreadyRegistered,\n    NotFound,\n    RoutingFailed(String),\n}\n</code></pre> <p>Errors specific to broker operations.</p> <p>Variants:</p> <ul> <li><code>AlreadyRegistered</code>: Attempted to register duplicate actor ID</li> <li><code>NotFound</code>: Actor ID not registered in broker</li> <li><code>RoutingFailed(String)</code>: Message routing failed with reason</li> </ul> <p>Example:</p> <pre><code>use airssys_rt::broker::BrokerError;\n\nmatch broker.register(actor_id, mailbox) {\n    Ok(()) =&gt; println!(\"Actor registered\"),\n    Err(BrokerError::AlreadyRegistered) =&gt; {\n        eprintln!(\"Actor ID {} already in use\", actor_id);\n        // Generate new ID or handle conflict\n    }\n    Err(e) =&gt; eprintln!(\"Registration failed: {:?}\", e),\n}\n</code></pre>"},{"location":"components/rt/reference/api/broker/#enum-senderror","title":"Enum: <code>SendError</code>","text":"<pre><code>pub enum SendError {\n    ActorNotFound,\n    ActorStopped,\n    MailboxFull,\n    Timeout,\n}\n</code></pre> <p>Errors that occur during message delivery.</p> <p>Variants:</p> <ul> <li><code>ActorNotFound</code>: Target actor not registered</li> <li><code>ActorStopped</code>: Actor has stopped (mailbox closed)</li> <li><code>MailboxFull</code>: Actor's mailbox at capacity (bounded mailbox with Fail strategy)</li> <li><code>Timeout</code>: Send operation timed out</li> </ul> <p>Example:</p> <pre><code>use airssys_rt::broker::SendError;\n\nmatch broker.send(actor_id, msg).await {\n    Ok(result) =&gt; println!(\"Success: {:?}\", result),\n    Err(SendError::ActorNotFound) =&gt; {\n        eprintln!(\"Actor {} not found\", actor_id);\n    }\n    Err(SendError::MailboxFull) =&gt; {\n        eprintln!(\"Actor {} mailbox full, retry later\", actor_id);\n        // Implement retry logic\n    }\n    Err(e) =&gt; eprintln!(\"Send failed: {:?}\", e),\n}\n</code></pre>"},{"location":"components/rt/reference/api/broker/#monitoring-and-metrics","title":"Monitoring and Metrics","text":""},{"location":"components/rt/reference/api/broker/#broker-metrics","title":"Broker Metrics","text":"<pre><code>pub struct BrokerMetrics {\n    pub registered_actors: usize,\n    pub total_sent: u64,\n    pub total_delivered: u64,\n    pub total_failed: u64,\n    pub avg_routing_latency_ns: u64,\n}\n\nimpl InMemoryMessageBroker {\n    pub fn metrics(&amp;self) -&gt; BrokerMetrics {\n        // Implementation\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>let metrics = broker.metrics();\nprintln!(\"Active actors: {}\", metrics.registered_actors);\nprintln!(\"Success rate: {:.2}%\", \n    (metrics.total_delivered as f64 / metrics.total_sent as f64) * 100.0);\nprintln!(\"Avg routing latency: {}ns\", metrics.avg_routing_latency_ns);\n</code></pre>"},{"location":"components/rt/reference/api/broker/#testing-utilities","title":"Testing Utilities","text":""},{"location":"components/rt/reference/api/broker/#struct-brokertestprobe","title":"Struct: <code>BrokerTestProbe</code>","text":"<pre><code>pub struct BrokerTestProbe {\n    // fields omitted\n}\n</code></pre> <p>Testing utility for broker behavior.</p> <p>Available in: Test builds only (<code>#[cfg(test)]</code>)</p>"},{"location":"components/rt/reference/api/broker/#methods","title":"Methods","text":""},{"location":"components/rt/reference/api/broker/#new_1","title":"<code>new()</code>","text":"<pre><code>pub fn new(broker: InMemoryMessageBroker) -&gt; Self\n</code></pre> <p>Creates a test probe for a broker.</p>"},{"location":"components/rt/reference/api/broker/#assert_sent","title":"<code>assert_sent()</code>","text":"<pre><code>pub fn assert_sent(&amp;self, actor_id: ActorId, count: usize) -&gt; bool\n</code></pre> <p>Asserts that expected number of messages were sent to an actor.</p> <p>Example:</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use airssys_rt::broker::BrokerTestProbe;\n\n    #[tokio::test]\n    async fn test_message_routing() {\n        let broker = InMemoryMessageBroker::new();\n        let probe = BrokerTestProbe::new(broker.clone());\n\n        let actor_id = ActorId::new();\n        let mailbox = Mailbox::&lt;MyActor&gt;::bounded(10);\n        broker.register(actor_id, mailbox)?;\n\n        // Send messages\n        for i in 0..5 {\n            broker.try_send(actor_id, TestMsg { id: i })?;\n        }\n\n        assert!(probe.assert_sent(actor_id, 5));\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/broker/#assert_broadcast","title":"<code>assert_broadcast()</code>","text":"<pre><code>pub fn assert_broadcast(&amp;self, expected_actors: usize) -&gt; bool\n</code></pre> <p>Asserts that a broadcast reached expected number of actors.</p>"},{"location":"components/rt/reference/api/broker/#advanced-features","title":"Advanced Features","text":""},{"location":"components/rt/reference/api/broker/#custom-routing","title":"Custom Routing","text":"<pre><code>pub struct RoutingKey {\n    pub topic: String,\n    pub priority: u8,\n}\n\nimpl InMemoryMessageBroker {\n    pub fn send_with_routing&lt;M&gt;(\n        &amp;self,\n        routing_key: RoutingKey,\n        msg: M,\n    ) -&gt; Result&lt;M::Result, SendError&gt;\n    where\n        M: Message,\n    {\n        // Custom routing logic\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/broker/#message-priorities","title":"Message Priorities","text":"<pre><code>pub enum Priority {\n    Low,\n    Normal,\n    High,\n    Critical,\n}\n\nbroker.send_with_priority(actor_id, msg, Priority::High).await?;\n</code></pre>"},{"location":"components/rt/reference/api/broker/#dead-letter-queue","title":"Dead Letter Queue","text":"<pre><code>pub struct DeadLetterQueue {\n    // Stores messages that couldn't be delivered\n}\n\nimpl InMemoryMessageBroker {\n    pub fn with_dead_letter_queue(self, dlq: DeadLetterQueue) -&gt; Self {\n        // Enable DLQ for failed deliveries\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/broker/#see-also","title":"See Also","text":"<ul> <li>Core API Reference - Core types and system</li> <li>Messaging API Reference - Message trait and patterns</li> <li>Mailbox API Reference - Message queuing</li> <li>Architecture: Message Passing - System design</li> <li>BENCHMARKING.md - Performance data</li> </ul>"},{"location":"components/rt/reference/api/core/","title":"Core API Reference","text":"<p>This reference documents the core types, traits, and utilities that form the foundation of the AirsSys Runtime system.</p>"},{"location":"components/rt/reference/api/core/#module-airssys_rt","title":"Module: <code>airssys_rt</code>","text":"<p>The root module provides the primary API surface.</p>"},{"location":"components/rt/reference/api/core/#re-exports","title":"Re-exports","text":"<pre><code>pub use actor::{Actor, ActorContext, ActorRef, ActorSystem};\npub use message::{Message, MessageBroker};\npub use supervisor::{Child, ChildSpec, RestartStrategy, Supervisor};\n</code></pre>"},{"location":"components/rt/reference/api/core/#module-message","title":"Module: <code>message</code>","text":"<p>Core message passing abstractions.</p>"},{"location":"components/rt/reference/api/core/#trait-message","title":"Trait: <code>Message</code>","text":"<pre><code>pub trait Message: Send + 'static {\n    type Result: Send + 'static;\n}\n</code></pre> <p>Marker trait for messages that can be sent between actors.</p> <p>Type Parameters: - <code>Result</code>: The type returned when processing this message</p> <p>Trait Bounds: - <code>Send</code>: Messages must be sendable across thread boundaries - <code>'static</code>: Messages must not contain non-static references</p> <p>Example:</p> <pre><code>use airssys_rt::Message;\n\nstruct GetStatus;\n\nimpl Message for GetStatus {\n    type Result = String;\n}\n\nstruct Increment {\n    amount: i32,\n}\n\nimpl Message for Increment {\n    type Result = ();\n}\n</code></pre>"},{"location":"components/rt/reference/api/core/#module-actor","title":"Module: <code>actor</code>","text":"<p>Actor system types and traits.</p>"},{"location":"components/rt/reference/api/core/#struct-actorsystem","title":"Struct: <code>ActorSystem</code>","text":"<pre><code>pub struct ActorSystem {\n    // fields omitted\n}\n</code></pre> <p>The actor system runtime that manages actor lifecycle and execution.</p>"},{"location":"components/rt/reference/api/core/#methods","title":"Methods","text":""},{"location":"components/rt/reference/api/core/#new","title":"<code>new()</code>","text":"<pre><code>pub fn new(name: &amp;str) -&gt; Result&lt;Self, SystemError&gt;\n</code></pre> <p>Creates a new actor system with the given name.</p> <p>Parameters: - <code>name</code>: A unique identifier for this actor system</p> <p>Returns: - <code>Ok(ActorSystem)</code>: Successfully created actor system - <code>Err(SystemError)</code>: System initialization failed</p> <p>Example:</p> <pre><code>use airssys_rt::ActorSystem;\n\nlet system = ActorSystem::new(\"my-system\")\n    .expect(\"Failed to create actor system\");\n</code></pre>"},{"location":"components/rt/reference/api/core/#spawn","title":"<code>spawn()</code>","text":"<pre><code>pub async fn spawn&lt;A&gt;(&amp;self, actor: A) -&gt; Result&lt;ActorRef&lt;A&gt;, SpawnError&gt;\nwhere\n    A: Actor,\n</code></pre> <p>Spawns a new actor in the system.</p> <p>Type Parameters: - <code>A</code>: The actor type implementing the <code>Actor</code> trait</p> <p>Parameters: - <code>actor</code>: The actor instance to spawn</p> <p>Returns: - <code>Ok(ActorRef&lt;A&gt;)</code>: Reference to the spawned actor - <code>Err(SpawnError)</code>: Actor spawn failed</p> <p>Performance: - Average spawn time: ~624ns (see Performance Reference) - Memory per actor: ~512 bytes base + mailbox</p> <p>Example:</p> <pre><code>use airssys_rt::{Actor, ActorContext, ActorSystem, Message};\n\nstruct MyActor {\n    count: i32,\n}\n\nimpl Actor for MyActor {\n    async fn receive(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;, msg: Box&lt;dyn Message&gt;) {\n        // Handle messages\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let system = ActorSystem::new(\"example\").unwrap();\n    let actor_ref = system.spawn(MyActor { count: 0 }).await.unwrap();\n}\n</code></pre>"},{"location":"components/rt/reference/api/core/#shutdown","title":"<code>shutdown()</code>","text":"<pre><code>pub async fn shutdown(self) -&gt; Result&lt;(), SystemError&gt;\n</code></pre> <p>Gracefully shuts down the actor system.</p> <p>Returns: - <code>Ok(())</code>: System shut down successfully - <code>Err(SystemError)</code>: Shutdown encountered errors</p> <p>Behavior: - Stops all running actors in reverse spawn order - Waits for actors to complete shutdown hooks - Releases all system resources</p> <p>Example:</p> <pre><code>let system = ActorSystem::new(\"example\").unwrap();\n// ... use system ...\nsystem.shutdown().await.unwrap();\n</code></pre>"},{"location":"components/rt/reference/api/core/#trait-actor","title":"Trait: <code>Actor</code>","text":"<pre><code>pub trait Actor: Send + 'static {\n    async fn receive(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;, msg: Box&lt;dyn Message&gt;);\n\n    async fn pre_start(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;) {\n        // Default: no-op\n    }\n\n    async fn post_stop(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;) {\n        // Default: no-op\n    }\n}\n</code></pre> <p>Core trait that all actors must implement.</p> <p>Required Methods:</p> <ul> <li><code>receive()</code>: Handles incoming messages</li> </ul> <p>Provided Methods:</p> <ul> <li><code>pre_start()</code>: Called before actor begins receiving messages (default: no-op)</li> <li><code>post_stop()</code>: Called after actor stops (default: no-op)</li> </ul> <p>Trait Bounds: - <code>Send</code>: Actors must be sendable across threads - <code>'static</code>: Actors must not contain non-static references</p> <p>Example:</p> <pre><code>use airssys_rt::{Actor, ActorContext, Message};\n\nstruct Counter {\n    count: i32,\n}\n\nimpl Actor for Counter {\n    async fn receive(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;, msg: Box&lt;dyn Message&gt;) {\n        // Message handling logic\n    }\n\n    async fn pre_start(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;) {\n        println!(\"Counter actor starting with count: {}\", self.count);\n    }\n\n    async fn post_stop(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;) {\n        println!(\"Counter actor stopped at count: {}\", self.count);\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/core/#struct-actorcontexta","title":"Struct: <code>ActorContext&lt;A&gt;</code>","text":"<pre><code>pub struct ActorContext&lt;A: Actor&gt; {\n    // fields omitted\n}\n</code></pre> <p>Context provided to actors for interaction with the actor system.</p> <p>Type Parameters: - <code>A</code>: The actor type this context belongs to</p>"},{"location":"components/rt/reference/api/core/#methods_1","title":"Methods","text":""},{"location":"components/rt/reference/api/core/#actor_ref","title":"<code>actor_ref()</code>","text":"<pre><code>pub fn actor_ref(&amp;self) -&gt; &amp;ActorRef&lt;A&gt;\n</code></pre> <p>Returns a reference to this actor's <code>ActorRef</code>.</p> <p>Returns: - <code>&amp;ActorRef&lt;A&gt;</code>: Reference to this actor</p> <p>Use Cases: - Passing self-reference to spawned children - Registering with services - Setting up request-reply patterns</p> <p>Example:</p> <pre><code>impl Actor for MyActor {\n    async fn receive(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;, msg: Box&lt;dyn Message&gt;) {\n        let self_ref = ctx.actor_ref().clone();\n        // Use self_ref for communication\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/core/#stop","title":"<code>stop()</code>","text":"<pre><code>pub fn stop(&amp;mut self)\n</code></pre> <p>Stops this actor.</p> <p>Behavior: - Actor will finish processing current message - No new messages will be processed - <code>post_stop()</code> hook will be called - Actor will be removed from system</p> <p>Example:</p> <pre><code>impl Actor for MyActor {\n    async fn receive(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;, msg: Box&lt;dyn Message&gt;) {\n        if should_stop {\n            ctx.stop();\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/core/#spawn_child","title":"<code>spawn_child()</code>","text":"<pre><code>pub async fn spawn_child&lt;C&gt;(&amp;mut self, child: C) -&gt; Result&lt;ActorRef&lt;C&gt;, SpawnError&gt;\nwhere\n    C: Actor,\n</code></pre> <p>Spawns a child actor supervised by this actor.</p> <p>Type Parameters: - <code>C</code>: The child actor type</p> <p>Parameters: - <code>child</code>: The child actor instance</p> <p>Returns: - <code>Ok(ActorRef&lt;C&gt;)</code>: Reference to spawned child - <code>Err(SpawnError)</code>: Child spawn failed</p> <p>Example:</p> <pre><code>impl Actor for ParentActor {\n    async fn pre_start(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;) {\n        let child = ctx.spawn_child(ChildActor::new())\n            .await\n            .expect(\"Failed to spawn child\");\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/core/#struct-actorrefa","title":"Struct: <code>ActorRef&lt;A&gt;</code>","text":"<pre><code>pub struct ActorRef&lt;A: Actor&gt; {\n    // fields omitted\n}\n</code></pre> <p>Reference to an actor that can be used to send messages.</p> <p>Type Parameters: - <code>A</code>: The actor type this reference points to</p> <p>Traits Implemented: - <code>Clone</code>: Cheap to clone (uses <code>Arc</code> internally) - <code>Send</code>: Can be sent across threads - <code>Sync</code>: Can be shared across threads</p>"},{"location":"components/rt/reference/api/core/#methods_2","title":"Methods","text":""},{"location":"components/rt/reference/api/core/#send","title":"<code>send()</code>","text":"<pre><code>pub async fn send&lt;M&gt;(&amp;self, msg: M) -&gt; Result&lt;M::Result, SendError&gt;\nwhere\n    M: Message,\n    A: Handler&lt;M&gt;,\n</code></pre> <p>Sends a message to the actor and waits for the result.</p> <p>Type Parameters: - <code>M</code>: The message type</p> <p>Parameters: - <code>msg</code>: The message to send</p> <p>Returns: - <code>Ok(M::Result)</code>: The result from processing the message - <code>Err(SendError)</code>: Message delivery or processing failed</p> <p>Performance: - Average roundtrip: ~737ns (send + process + respond) - Throughput: ~4.7M messages/second</p> <p>Example:</p> <pre><code>use airssys_rt::{ActorRef, Message};\n\nstruct GetCount;\nimpl Message for GetCount {\n    type Result = i32;\n}\n\nasync fn example(actor: &amp;ActorRef&lt;Counter&gt;) {\n    let count = actor.send(GetCount)\n        .await\n        .expect(\"Failed to get count\");\n    println!(\"Count: {}\", count);\n}\n</code></pre>"},{"location":"components/rt/reference/api/core/#tell","title":"<code>tell()</code>","text":"<pre><code>pub fn tell&lt;M&gt;(&amp;self, msg: M) -&gt; Result&lt;(), SendError&gt;\nwhere\n    M: Message&lt;Result = ()&gt;,\n    A: Handler&lt;M&gt;,\n</code></pre> <p>Sends a fire-and-forget message (no response expected).</p> <p>Type Parameters: - <code>M</code>: The message type (must have <code>Result = ()</code>)</p> <p>Parameters: - <code>msg</code>: The message to send</p> <p>Returns: - <code>Ok(())</code>: Message queued successfully - <code>Err(SendError)</code>: Message delivery failed</p> <p>Performance: - Non-blocking send operation - Lower latency than <code>send()</code> (no wait for response)</p> <p>Example:</p> <pre><code>struct Increment { amount: i32 }\nimpl Message for Increment {\n    type Result = ();\n}\n\nactor_ref.tell(Increment { amount: 5 })\n    .expect(\"Failed to send increment\");\n</code></pre>"},{"location":"components/rt/reference/api/core/#module-util","title":"Module: <code>util</code>","text":"<p>Utility types and functions.</p>"},{"location":"components/rt/reference/api/core/#struct-actorid","title":"Struct: <code>ActorId</code>","text":"<pre><code>pub struct ActorId(/* private fields */);\n</code></pre> <p>Unique identifier for an actor.</p> <p>Traits Implemented: - <code>Copy</code>, <code>Clone</code>: Lightweight value type - <code>Eq</code>, <code>PartialEq</code>: Equality comparison - <code>Hash</code>: Can be used in hash maps - <code>Display</code>: Human-readable format</p>"},{"location":"components/rt/reference/api/core/#methods_3","title":"Methods","text":""},{"location":"components/rt/reference/api/core/#new_1","title":"<code>new()</code>","text":"<pre><code>pub fn new() -&gt; Self\n</code></pre> <p>Creates a new unique actor ID.</p> <p>Returns: - <code>ActorId</code>: Globally unique identifier</p> <p>Thread Safety: - Uses atomic counter for uniqueness - Safe to call from multiple threads concurrently</p> <p>Example:</p> <pre><code>use airssys_rt::util::ActorId;\n\nlet id = ActorId::new();\nprintln!(\"Actor ID: {}\", id);\n</code></pre>"},{"location":"components/rt/reference/api/core/#error-types","title":"Error Types","text":""},{"location":"components/rt/reference/api/core/#enum-systemerror","title":"Enum: <code>SystemError</code>","text":"<pre><code>pub enum SystemError {\n    AlreadyRunning,\n    InitializationFailed(String),\n    ShutdownFailed(String),\n}\n</code></pre> <p>Errors that can occur during system operations.</p> <p>Variants:</p> <ul> <li><code>AlreadyRunning</code>: Attempted to start a system that's already running</li> <li><code>InitializationFailed(String)</code>: System initialization failed with reason</li> <li><code>ShutdownFailed(String)</code>: System shutdown encountered errors</li> </ul> <p>Traits Implemented: - <code>Error</code>, <code>Display</code>, <code>Debug</code>: Standard error traits - <code>Send</code>, <code>Sync</code>: Thread-safe error type</p>"},{"location":"components/rt/reference/api/core/#enum-spawnerror","title":"Enum: <code>SpawnError</code>","text":"<pre><code>pub enum SpawnError {\n    SystemNotRunning,\n    ActorInitFailed(String),\n    ResourceExhausted,\n}\n</code></pre> <p>Errors that can occur when spawning actors.</p> <p>Variants:</p> <ul> <li><code>SystemNotRunning</code>: System is not active</li> <li><code>ActorInitFailed(String)</code>: Actor initialization failed</li> <li><code>ResourceExhausted</code>: Insufficient resources to spawn actor</li> </ul>"},{"location":"components/rt/reference/api/core/#enum-senderror","title":"Enum: <code>SendError</code>","text":"<pre><code>pub enum SendError {\n    ActorNotFound,\n    ActorStopped,\n    MailboxFull,\n    Timeout,\n}\n</code></pre> <p>Errors that can occur when sending messages.</p> <p>Variants:</p> <ul> <li><code>ActorNotFound</code>: Target actor doesn't exist</li> <li><code>ActorStopped</code>: Target actor has stopped</li> <li><code>MailboxFull</code>: Actor's mailbox is at capacity</li> <li><code>Timeout</code>: Message send/receive timed out</li> </ul>"},{"location":"components/rt/reference/api/core/#type-aliases","title":"Type Aliases","text":""},{"location":"components/rt/reference/api/core/#actorresultt","title":"<code>ActorResult&lt;T&gt;</code>","text":"<pre><code>pub type ActorResult&lt;T&gt; = Result&lt;T, ActorError&gt;;\n</code></pre> <p>Convenience alias for actor operation results.</p>"},{"location":"components/rt/reference/api/core/#systemresultt","title":"<code>SystemResult&lt;T&gt;</code>","text":"<pre><code>pub type SystemResult&lt;T&gt; = Result&lt;T, SystemError&gt;;\n</code></pre> <p>Convenience alias for system operation results.</p>"},{"location":"components/rt/reference/api/core/#see-also","title":"See Also","text":"<ul> <li>Actors API Reference - Actor-specific types and patterns</li> <li>Messaging API Reference - Message broker and delivery</li> <li>Supervisors API Reference - Supervision and fault tolerance</li> <li>Architecture: Actor Model - Conceptual overview</li> </ul>"},{"location":"components/rt/reference/api/mailbox/","title":"Mailbox API Reference","text":"<p>This reference documents the mailbox system for actor message queuing and delivery.</p>"},{"location":"components/rt/reference/api/mailbox/#module-mailbox","title":"Module: <code>mailbox</code>","text":"<p>Mailbox implementations and configuration.</p>"},{"location":"components/rt/reference/api/mailbox/#enum-mailboxa","title":"Enum: <code>Mailbox&lt;A&gt;</code>","text":"<pre><code>pub enum Mailbox&lt;A: Actor&gt; {\n    Bounded(BoundedMailbox&lt;A&gt;),\n    Unbounded(UnboundedMailbox&lt;A&gt;),\n}\n</code></pre> <p>Actor mailbox abstraction supporting bounded and unbounded message queues.</p> <p>Type Parameters: - <code>A</code>: The actor type that owns this mailbox</p> <p>Variants:</p> <ul> <li><code>Bounded(BoundedMailbox&lt;A&gt;)</code>: Fixed-capacity mailbox with backpressure</li> <li><code>Unbounded(UnboundedMailbox&lt;A&gt;)</code>: Unlimited capacity mailbox</li> </ul> <p>Choosing a Mailbox Type:</p> Criteria Bounded Unbounded Memory safety \u2705 Guaranteed \u26a0\ufe0f Can grow unbounded Backpressure \u2705 Supported \u274c None Latency predictability \u2705 High \u26a0\ufe0f Variable Throughput Medium \u2705 High Configuration complexity Higher \u2705 Simple <p>Recommendation: - Production systems: Use <code>Bounded</code> with appropriate capacity - Development/prototyping: <code>Unbounded</code> for simplicity - Critical path: <code>Bounded</code> with <code>BackpressureStrategy::Block</code> - Best-effort delivery: <code>Bounded</code> with <code>BackpressureStrategy::DropOldest</code></p>"},{"location":"components/rt/reference/api/mailbox/#constructors","title":"Constructors","text":""},{"location":"components/rt/reference/api/mailbox/#bounded","title":"<code>bounded()</code>","text":"<pre><code>pub fn bounded(capacity: usize) -&gt; Self\n</code></pre> <p>Creates a bounded mailbox with specified capacity.</p> <p>Parameters: - <code>capacity</code>: Maximum number of messages (must be &gt; 0)</p> <p>Default Configuration: - Backpressure: <code>BackpressureStrategy::Block</code> - Overflow behavior: Sender blocks until space available</p> <p>Example:</p> <pre><code>use airssys_rt::mailbox::Mailbox;\n\n// Standard capacity for most actors\nlet mailbox = Mailbox::&lt;MyActor&gt;::bounded(1000);\n\n// High-throughput actor\nlet high_capacity = Mailbox::&lt;Worker&gt;::bounded(10000);\n\n// Low-latency actor\nlet low_capacity = Mailbox::&lt;Controller&gt;::bounded(100);\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#unbounded","title":"<code>unbounded()</code>","text":"<pre><code>pub fn unbounded() -&gt; Self\n</code></pre> <p>Creates an unbounded mailbox with unlimited capacity.</p> <p>Returns: - <code>Mailbox&lt;A&gt;</code>: Unbounded mailbox instance</p> <p>Memory Characteristics: - Initial allocation: ~128 bytes - Growth: Dynamic based on message count - No upper limit (can exhaust memory)</p> <p>Example:</p> <pre><code>let mailbox = Mailbox::&lt;MyActor&gt;::unbounded();\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#methods","title":"Methods","text":""},{"location":"components/rt/reference/api/mailbox/#enqueue","title":"<code>enqueue()</code>","text":"<pre><code>pub async fn enqueue(&amp;self, msg: Box&lt;dyn Message&gt;) -&gt; Result&lt;(), MailboxError&gt;\n</code></pre> <p>Adds a message to the mailbox.</p> <p>Parameters: - <code>msg</code>: Boxed message to enqueue</p> <p>Returns: - <code>Ok(())</code>: Message enqueued successfully - <code>Err(MailboxError::Full)</code>: Bounded mailbox at capacity (strategy-dependent) - <code>Err(MailboxError::Closed)</code>: Mailbox has been closed</p> <p>Behavior by Mailbox Type:</p> Type Behavior Latency Bounded (Block) Waits for space Variable Bounded (Drop) Drops message per strategy Constant (~181ns) Unbounded Always succeeds Constant (~150ns) <p>Performance: - Bounded mailbox: ~181ns average - Unbounded mailbox: ~150ns average - Cross-thread overhead: +50-100ns</p> <p>Example:</p> <pre><code>use airssys_rt::Message;\n\nstruct WorkItem {\n    data: Vec&lt;u8&gt;,\n}\nimpl Message for WorkItem {\n    type Result = ();\n}\n\nlet msg = Box::new(WorkItem { data: vec![1, 2, 3] });\nmailbox.enqueue(msg).await?;\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#dequeue","title":"<code>dequeue()</code>","text":"<pre><code>pub async fn dequeue(&amp;self) -&gt; Option&lt;Box&lt;dyn Message&gt;&gt;\n</code></pre> <p>Removes and returns the next message from the mailbox.</p> <p>Returns: - <code>Some(msg)</code>: Next message available - <code>None</code>: Mailbox is empty and closed</p> <p>Behavior: - Blocks until message available or mailbox closed - FIFO ordering (first-in, first-out) - Atomic operation (no lost messages)</p> <p>Performance: - Average latency: ~150ns - No allocation (returns existing Box)</p> <p>Example:</p> <pre><code>while let Some(msg) = mailbox.dequeue().await {\n    // Process message\n    println!(\"Received message\");\n}\n// Mailbox closed and empty\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#try_dequeue","title":"<code>try_dequeue()</code>","text":"<pre><code>pub fn try_dequeue(&amp;self) -&gt; Option&lt;Box&lt;dyn Message&gt;&gt;\n</code></pre> <p>Attempts to dequeue a message without blocking.</p> <p>Returns: - <code>Some(msg)</code>: Message available - <code>None</code>: Mailbox is empty (or closed)</p> <p>Use Cases: - Non-blocking message processing loops - Polling-based designs - Integration with custom event loops</p> <p>Example:</p> <pre><code>// Process available messages, don't wait\nwhile let Some(msg) = mailbox.try_dequeue() {\n    // Process immediately available messages\n}\n// No messages available, continue with other work\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#close","title":"<code>close()</code>","text":"<pre><code>pub fn close(&amp;self)\n</code></pre> <p>Closes the mailbox, preventing new messages.</p> <p>Behavior: - Pending messages can still be dequeued - New <code>enqueue()</code> calls will return <code>Err(MailboxError::Closed)</code> - <code>dequeue()</code> returns <code>None</code> when empty - Idempotent (safe to call multiple times)</p> <p>Example:</p> <pre><code>// Actor shutdown\nmailbox.close();\n\n// Process remaining messages\nwhile let Some(msg) = mailbox.dequeue().await {\n    // Handle final messages\n}\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#is_closed","title":"<code>is_closed()</code>","text":"<pre><code>pub fn is_closed(&amp;self) -&gt; bool\n</code></pre> <p>Checks if the mailbox is closed.</p> <p>Returns: - <code>true</code>: Mailbox is closed - <code>false</code>: Mailbox is open</p> <p>Example:</p> <pre><code>if mailbox.is_closed() {\n    println!(\"Mailbox has been shut down\");\n}\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#bounded-mailbox","title":"Bounded Mailbox","text":""},{"location":"components/rt/reference/api/mailbox/#struct-boundedmailboxa","title":"Struct: <code>BoundedMailbox&lt;A&gt;</code>","text":"<pre><code>pub struct BoundedMailbox&lt;A: Actor&gt; {\n    // fields omitted\n}\n</code></pre> <p>Fixed-capacity mailbox with configurable backpressure.</p> <p>Implementation Details: - Uses <code>tokio::sync::mpsc::channel</code> internally - Lock-free send/receive operations - Memory-bounded operation</p> <p>Type Parameters: - <code>A</code>: The actor type</p>"},{"location":"components/rt/reference/api/mailbox/#constructors_1","title":"Constructors","text":""},{"location":"components/rt/reference/api/mailbox/#new","title":"<code>new()</code>","text":"<pre><code>pub fn new(capacity: usize) -&gt; Self\n</code></pre> <p>Creates a bounded mailbox with default backpressure (Block).</p> <p>Parameters: - <code>capacity</code>: Maximum messages (must be &gt; 0)</p> <p>Example:</p> <pre><code>use airssys_rt::mailbox::BoundedMailbox;\n\nlet mailbox = BoundedMailbox::&lt;MyActor&gt;::new(1000);\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#with_backpressure","title":"<code>with_backpressure()</code>","text":"<pre><code>pub fn with_backpressure(capacity: usize, strategy: BackpressureStrategy) -&gt; Self\n</code></pre> <p>Creates a bounded mailbox with custom backpressure strategy.</p> <p>Parameters: - <code>capacity</code>: Maximum messages - <code>strategy</code>: Backpressure behavior on overflow</p> <p>Example:</p> <pre><code>use airssys_rt::mailbox::{BoundedMailbox, BackpressureStrategy};\n\n// Drop oldest messages when full (ring buffer behavior)\nlet mailbox = BoundedMailbox::with_backpressure(\n    100,\n    BackpressureStrategy::DropOldest,\n);\n\n// Fail fast when full\nlet mailbox = BoundedMailbox::with_backpressure(\n    1000,\n    BackpressureStrategy::Fail,\n);\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#methods_1","title":"Methods","text":""},{"location":"components/rt/reference/api/mailbox/#capacity","title":"<code>capacity()</code>","text":"<pre><code>pub fn capacity(&amp;self) -&gt; usize\n</code></pre> <p>Returns the maximum capacity of the mailbox.</p> <p>Returns: - <code>usize</code>: Maximum message count</p> <p>Example:</p> <pre><code>let cap = mailbox.capacity();\nprintln!(\"Mailbox can hold {} messages\", cap);\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#len","title":"<code>len()</code>","text":"<pre><code>pub fn len(&amp;self) -&gt; usize\n</code></pre> <p>Returns the current number of messages in the mailbox.</p> <p>Returns: - <code>usize</code>: Current message count</p> <p>Use Cases: - Monitoring mailbox pressure - Load balancing decisions - Health checks and metrics</p> <p>Example:</p> <pre><code>let current = mailbox.len();\nlet capacity = mailbox.capacity();\nlet utilization = (current as f64 / capacity as f64) * 100.0;\nprintln!(\"Mailbox utilization: {:.1}%\", utilization);\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#is_empty","title":"<code>is_empty()</code>","text":"<pre><code>pub fn is_empty(&amp;self) -&gt; bool\n</code></pre> <p>Checks if the mailbox contains no messages.</p> <p>Returns: - <code>true</code>: No messages - <code>false</code>: Has messages</p>"},{"location":"components/rt/reference/api/mailbox/#is_full","title":"<code>is_full()</code>","text":"<pre><code>pub fn is_full(&amp;self) -&gt; bool\n</code></pre> <p>Checks if the mailbox is at capacity.</p> <p>Returns: - <code>true</code>: At maximum capacity - <code>false</code>: Has available space</p> <p>Example:</p> <pre><code>if mailbox.is_full() {\n    println!(\"Warning: Mailbox at capacity, backpressure active\");\n}\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#available_capacity","title":"<code>available_capacity()</code>","text":"<pre><code>pub fn available_capacity(&amp;self) -&gt; usize\n</code></pre> <p>Returns the number of messages that can be enqueued without blocking.</p> <p>Returns: - <code>usize</code>: Available slots</p> <p>Example:</p> <pre><code>let available = mailbox.available_capacity();\nprintln!(\"Can send {} more messages without blocking\", available);\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#unbounded-mailbox","title":"Unbounded Mailbox","text":""},{"location":"components/rt/reference/api/mailbox/#struct-unboundedmailboxa","title":"Struct: <code>UnboundedMailbox&lt;A&gt;</code>","text":"<pre><code>pub struct UnboundedMailbox&lt;A: Actor&gt; {\n    // fields omitted\n}\n</code></pre> <p>Unlimited-capacity mailbox.</p> <p>Implementation Details: - Uses <code>tokio::sync::mpsc::unbounded_channel</code> internally - No capacity checks (faster enqueue) - Can grow to system memory limits</p> <p>Warning: - No backpressure protection - Can consume unbounded memory under sustained load - Monitor <code>len()</code> in production systems</p> <p>Type Parameters: - <code>A</code>: The actor type</p>"},{"location":"components/rt/reference/api/mailbox/#constructors_2","title":"Constructors","text":""},{"location":"components/rt/reference/api/mailbox/#new_1","title":"<code>new()</code>","text":"<pre><code>pub fn new() -&gt; Self\n</code></pre> <p>Creates a new unbounded mailbox.</p> <p>Example:</p> <pre><code>use airssys_rt::mailbox::UnboundedMailbox;\n\nlet mailbox = UnboundedMailbox::&lt;MyActor&gt;::new();\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#methods_2","title":"Methods","text":""},{"location":"components/rt/reference/api/mailbox/#len_1","title":"<code>len()</code>","text":"<pre><code>pub fn len(&amp;self) -&gt; usize\n</code></pre> <p>Returns the current number of messages in the mailbox.</p> <p>Returns: - <code>usize</code>: Current message count</p> <p>Monitoring:</p> <pre><code>let len = mailbox.len();\nif len &gt; 10000 {\n    eprintln!(\"Warning: Unbounded mailbox has {} messages\", len);\n}\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#is_empty_1","title":"<code>is_empty()</code>","text":"<pre><code>pub fn is_empty(&amp;self) -&gt; bool\n</code></pre> <p>Checks if the mailbox contains no messages.</p>"},{"location":"components/rt/reference/api/mailbox/#backpressure-strategies","title":"Backpressure Strategies","text":""},{"location":"components/rt/reference/api/mailbox/#enum-backpressurestrategy","title":"Enum: <code>BackpressureStrategy</code>","text":"<pre><code>pub enum BackpressureStrategy {\n    Block,\n    DropOldest,\n    DropNewest,\n    Fail,\n}\n</code></pre> <p>Strategy for handling mailbox overflow in bounded mailboxes.</p> <p>Variants:</p> <ul> <li><code>Block</code>: Block sender until space available (default)</li> <li><code>DropOldest</code>: Remove oldest message to make room for new message</li> <li><code>DropNewest</code>: Drop the incoming message, keep existing messages</li> <li><code>Fail</code>: Return error to sender without enqueueing</li> </ul> <p>Detailed Comparison:</p> Strategy Sender Latency Message Loss Use Case <code>Block</code> Variable (0-\u221e) None Critical messages, ordered processing <code>DropOldest</code> Constant (~181ns) Oldest messages Latest-value semantics (sensors, status) <code>DropNewest</code> Constant (~181ns) Newest messages Preserve history (audit logs) <code>Fail</code> Constant (~181ns) Newest messages Explicit error handling required <p>Examples:</p> <pre><code>use airssys_rt::mailbox::{BoundedMailbox, BackpressureStrategy};\n\n// Financial transactions - never drop, wait for processing\nlet ledger = BoundedMailbox::with_backpressure(\n    1000,\n    BackpressureStrategy::Block,\n);\n\n// Temperature sensor - only latest reading matters\nlet sensor = BoundedMailbox::with_backpressure(\n    10,\n    BackpressureStrategy::DropOldest,\n);\n\n// Audit log - preserve oldest entries\nlet audit = BoundedMailbox::with_backpressure(\n    5000,\n    BackpressureStrategy::DropNewest,\n);\n\n// Best-effort notifications\nlet notifications = BoundedMailbox::with_backpressure(\n    100,\n    BackpressureStrategy::Fail,\n);\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"components/rt/reference/api/mailbox/#operation-latency","title":"Operation Latency","text":"Operation Bounded Unbounded Notes <code>enqueue()</code> 181ns 150ns Average, no contention <code>dequeue()</code> 150ns 150ns Average, no contention <code>try_dequeue()</code> 50ns 50ns Non-blocking check <code>len()</code> 10ns 10ns Atomic read <code>is_empty()</code> 10ns 10ns Atomic read"},{"location":"components/rt/reference/api/mailbox/#throughput","title":"Throughput","text":"Scenario Messages/sec Notes Single sender, single receiver 5.5M Optimal case 4 senders, single receiver 4.2M Contention overhead Single sender, 4 receivers (broadcast) 4.8M Parallel dequeue"},{"location":"components/rt/reference/api/mailbox/#memory-usage","title":"Memory Usage","text":"Component Bounded (cap=1000) Unbounded Notes Empty mailbox ~8KB ~128 bytes Pre-allocated vs dynamic Per message overhead 64 bytes 64 bytes Box + metadata Full mailbox (1000 msgs) ~72KB ~64KB Plus message data"},{"location":"components/rt/reference/api/mailbox/#backpressure-strategy-performance","title":"Backpressure Strategy Performance","text":"Strategy Latency (empty) Latency (full) Message Loss Block 181ns Variable 0% DropOldest 181ns 181ns Bounded DropNewest 181ns 181ns Bounded Fail 181ns 181ns Bounded"},{"location":"components/rt/reference/api/mailbox/#error-types","title":"Error Types","text":""},{"location":"components/rt/reference/api/mailbox/#enum-mailboxerror","title":"Enum: <code>MailboxError</code>","text":"<pre><code>pub enum MailboxError {\n    Full,\n    Closed,\n    Timeout,\n}\n</code></pre> <p>Errors specific to mailbox operations.</p> <p>Variants:</p> <ul> <li><code>Full</code>: Bounded mailbox at capacity (only with <code>BackpressureStrategy::Fail</code>)</li> <li><code>Closed</code>: Mailbox has been closed</li> <li><code>Timeout</code>: Operation timed out (when timeout specified)</li> </ul> <p>Example:</p> <pre><code>use airssys_rt::mailbox::MailboxError;\n\nmatch mailbox.enqueue(msg).await {\n    Ok(()) =&gt; println!(\"Message sent\"),\n    Err(MailboxError::Full) =&gt; {\n        eprintln!(\"Mailbox full, message rejected\");\n        // Handle rejection (retry, log, etc.)\n    }\n    Err(MailboxError::Closed) =&gt; {\n        eprintln!(\"Actor has shut down\");\n        // Clean up sender\n    }\n    Err(MailboxError::Timeout) =&gt; {\n        eprintln!(\"Send timed out\");\n        // Handle timeout\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#monitoring-and-metrics","title":"Monitoring and Metrics","text":""},{"location":"components/rt/reference/api/mailbox/#mailbox-health-metrics","title":"Mailbox Health Metrics","text":"<pre><code>pub struct MailboxMetrics {\n    pub capacity: usize,\n    pub current_size: usize,\n    pub total_enqueued: u64,\n    pub total_dequeued: u64,\n    pub messages_dropped: u64,\n}\n\nimpl BoundedMailbox&lt;A&gt; {\n    pub fn metrics(&amp;self) -&gt; MailboxMetrics {\n        // Implementation\n    }\n}\n</code></pre> <p>Usage:</p> <pre><code>let metrics = mailbox.metrics();\nprintln!(\"Mailbox utilization: {}/{}\", metrics.current_size, metrics.capacity);\nprintln!(\"Throughput: {} msgs/sec\", \n    (metrics.total_dequeued as f64 / uptime.as_secs() as f64));\nprintln!(\"Drop rate: {:.2}%\", \n    (metrics.messages_dropped as f64 / metrics.total_enqueued as f64) * 100.0);\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#testing-utilities","title":"Testing Utilities","text":""},{"location":"components/rt/reference/api/mailbox/#struct-mailboxtestprobe","title":"Struct: <code>MailboxTestProbe</code>","text":"<pre><code>pub struct MailboxTestProbe&lt;A: Actor&gt; {\n    // fields omitted\n}\n</code></pre> <p>Testing utility for mailbox behavior.</p> <p>Available in: Test builds only (<code>#[cfg(test)]</code>)</p>"},{"location":"components/rt/reference/api/mailbox/#methods_3","title":"Methods","text":""},{"location":"components/rt/reference/api/mailbox/#new_2","title":"<code>new()</code>","text":"<pre><code>pub fn new(mailbox: Mailbox&lt;A&gt;) -&gt; Self\n</code></pre> <p>Creates a test probe for a mailbox.</p>"},{"location":"components/rt/reference/api/mailbox/#assert_enqueued","title":"<code>assert_enqueued()</code>","text":"<pre><code>pub fn assert_enqueued(&amp;self, expected: usize) -&gt; bool\n</code></pre> <p>Asserts that expected number of messages were enqueued.</p> <p>Example:</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use airssys_rt::mailbox::MailboxTestProbe;\n\n    #[tokio::test]\n    async fn test_mailbox_capacity() {\n        let mailbox = Mailbox::&lt;MyActor&gt;::bounded(10);\n        let probe = MailboxTestProbe::new(mailbox.clone());\n\n        // Enqueue messages\n        for i in 0..10 {\n            mailbox.enqueue(Box::new(TestMsg { id: i })).await.unwrap();\n        }\n\n        assert!(probe.assert_enqueued(10));\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/mailbox/#see-also","title":"See Also","text":"<ul> <li>Core API Reference - Core types and system</li> <li>Messaging API Reference - Message broker and patterns</li> <li>Broker API Reference - Message routing</li> <li>Architecture: Message Passing - System design</li> <li>BENCHMARKING.md - Performance data</li> </ul>"},{"location":"components/rt/reference/api/messaging/","title":"Messaging API Reference","text":"<p>This reference documents the message broker, mailbox system, and message delivery infrastructure.</p>"},{"location":"components/rt/reference/api/messaging/#module-message","title":"Module: <code>message</code>","text":"<p>Message trait and broker types.</p>"},{"location":"components/rt/reference/api/messaging/#trait-message","title":"Trait: <code>Message</code>","text":"<pre><code>pub trait Message: Send + 'static {\n    type Result: Send + 'static;\n}\n</code></pre> <p>Marker trait for types that can be sent as messages between actors.</p> <p>Type Parameters: - <code>Result</code>: The type returned when this message is processed</p> <p>Trait Bounds: - <code>Send</code>: Must be safe to send across thread boundaries - <code>'static</code>: Must not contain non-static references</p> <p>Design Rationale:</p> <p>The <code>Message</code> trait is intentionally minimal to allow maximum flexibility. Any type that is <code>Send + 'static</code> can be a message by simply declaring its result type.</p> <p>Example:</p> <pre><code>use airssys_rt::Message;\n\n// Simple notification (no result)\nstruct Ping;\nimpl Message for Ping {\n    type Result = ();\n}\n\n// Query message (returns data)\nstruct GetUser {\n    user_id: u64,\n}\nimpl Message for GetUser {\n    type Result = Option&lt;User&gt;;\n}\n\n// Command message (returns success/error)\nstruct UpdateUser {\n    user_id: u64,\n    name: String,\n}\nimpl Message for UpdateUser {\n    type Result = Result&lt;(), UpdateError&gt;;\n}\n</code></pre>"},{"location":"components/rt/reference/api/messaging/#module-broker","title":"Module: <code>broker</code>","text":"<p>Message broker implementations.</p>"},{"location":"components/rt/reference/api/messaging/#trait-messagebroker","title":"Trait: <code>MessageBroker</code>","text":"<pre><code>pub trait MessageBroker: Send + Sync {\n    async fn send&lt;M&gt;(&amp;self, actor_id: ActorId, msg: M) -&gt; Result&lt;M::Result, SendError&gt;\n    where\n        M: Message;\n\n    async fn broadcast&lt;M&gt;(&amp;self, msg: M) -&gt; Vec&lt;Result&lt;M::Result, SendError&gt;&gt;\n    where\n        M: Message + Clone;\n}\n</code></pre> <p>Trait for message routing and delivery.</p> <p>Required Methods:</p> <ul> <li><code>send()</code>: Sends a message to a specific actor</li> <li><code>broadcast()</code>: Sends a message to all registered actors</li> </ul> <p>Trait Bounds: - <code>Send + Sync</code>: Can be safely shared across threads</p> <p>Implementations: - <code>InMemoryMessageBroker</code>: Default in-memory broker</p>"},{"location":"components/rt/reference/api/messaging/#struct-inmemorymessagebroker","title":"Struct: <code>InMemoryMessageBroker</code>","text":"<pre><code>pub struct InMemoryMessageBroker {\n    // fields omitted\n}\n</code></pre> <p>In-memory message broker using channels for delivery.</p> <p>Characteristics:</p> <ul> <li>Lock-free message routing using <code>DashMap</code></li> <li>Per-actor mailbox isolation</li> <li>Configurable backpressure strategies</li> <li>Zero-copy message passing (where possible)</li> </ul>"},{"location":"components/rt/reference/api/messaging/#methods","title":"Methods","text":""},{"location":"components/rt/reference/api/messaging/#new","title":"<code>new()</code>","text":"<pre><code>pub fn new() -&gt; Self\n</code></pre> <p>Creates a new in-memory message broker.</p> <p>Returns: - <code>InMemoryMessageBroker</code>: New broker instance</p> <p>Example:</p> <pre><code>use airssys_rt::broker::InMemoryMessageBroker;\n\nlet broker = InMemoryMessageBroker::new();\n</code></pre>"},{"location":"components/rt/reference/api/messaging/#register","title":"<code>register()</code>","text":"<pre><code>pub fn register&lt;A&gt;(&amp;self, actor_id: ActorId, mailbox: Mailbox&lt;A&gt;) -&gt; Result&lt;(), BrokerError&gt;\nwhere\n    A: Actor,\n</code></pre> <p>Registers an actor's mailbox with the broker.</p> <p>Type Parameters: - <code>A</code>: The actor type</p> <p>Parameters: - <code>actor_id</code>: Unique identifier for the actor - <code>mailbox</code>: The actor's mailbox for receiving messages</p> <p>Returns: - <code>Ok(())</code>: Registration successful - <code>Err(BrokerError::AlreadyRegistered)</code>: Actor ID already in use</p> <p>Example:</p> <pre><code>let mailbox = Mailbox::bounded(1000);\nbroker.register(actor_id, mailbox)?;\n</code></pre>"},{"location":"components/rt/reference/api/messaging/#unregister","title":"<code>unregister()</code>","text":"<pre><code>pub fn unregister(&amp;self, actor_id: ActorId) -&gt; Result&lt;(), BrokerError&gt;\n</code></pre> <p>Unregisters an actor from the broker.</p> <p>Parameters: - <code>actor_id</code>: The actor to unregister</p> <p>Returns: - <code>Ok(())</code>: Unregistration successful - <code>Err(BrokerError::NotFound)</code>: Actor not registered</p> <p>Behavior: - Remaining messages in mailbox are dropped - In-flight sends will fail with <code>SendError::ActorNotFound</code></p>"},{"location":"components/rt/reference/api/messaging/#send","title":"<code>send()</code>","text":"<pre><code>pub async fn send&lt;M&gt;(&amp;self, actor_id: ActorId, msg: M) -&gt; Result&lt;M::Result, SendError&gt;\nwhere\n    M: Message,\n</code></pre> <p>Sends a message to an actor and waits for the result.</p> <p>Type Parameters: - <code>M</code>: The message type</p> <p>Parameters: - <code>actor_id</code>: Target actor identifier - <code>msg</code>: The message to send</p> <p>Returns: - <code>Ok(M::Result)</code>: Message processed successfully - <code>Err(SendError)</code>: Delivery or processing failed</p> <p>Performance: - Average latency: ~737ns (including actor processing) - Throughput: ~4.7M messages/second</p> <p>Example:</p> <pre><code>use airssys_rt::Message;\n\nstruct GetStatus;\nimpl Message for GetStatus {\n    type Result = String;\n}\n\nlet status = broker.send(actor_id, GetStatus).await?;\n</code></pre>"},{"location":"components/rt/reference/api/messaging/#broadcast","title":"<code>broadcast()</code>","text":"<pre><code>pub async fn broadcast&lt;M&gt;(&amp;self, msg: M) -&gt; Vec&lt;Result&lt;M::Result, SendError&gt;&gt;\nwhere\n    M: Message + Clone,\n</code></pre> <p>Broadcasts a message to all registered actors.</p> <p>Type Parameters: - <code>M</code>: The message type (must implement <code>Clone</code>)</p> <p>Parameters: - <code>msg</code>: The message to broadcast</p> <p>Returns: - <code>Vec&lt;Result&lt;M::Result, SendError&gt;&gt;</code>: Results from all actors</p> <p>Performance: - Parallel delivery to all actors - Individual failures don't affect other deliveries</p> <p>Example:</p> <pre><code>struct Shutdown;\nimpl Message for Shutdown {\n    type Result = ();\n}\n\nlet results = broker.broadcast(Shutdown).await;\nfor result in results {\n    if let Err(e) = result {\n        eprintln!(\"Shutdown failed: {:?}\", e);\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/messaging/#module-mailbox","title":"Module: <code>mailbox</code>","text":"<p>Mailbox implementations for actor message queues.</p>"},{"location":"components/rt/reference/api/messaging/#enum-mailboxa","title":"Enum: <code>Mailbox&lt;A&gt;</code>","text":"<pre><code>pub enum Mailbox&lt;A: Actor&gt; {\n    Bounded(BoundedMailbox&lt;A&gt;),\n    Unbounded(UnboundedMailbox&lt;A&gt;),\n}\n</code></pre> <p>Actor mailbox abstraction supporting bounded and unbounded queues.</p> <p>Type Parameters: - <code>A</code>: The actor type</p> <p>Variants:</p> <ul> <li><code>Bounded(BoundedMailbox&lt;A&gt;)</code>: Fixed-capacity mailbox with backpressure</li> <li><code>Unbounded(UnboundedMailbox&lt;A&gt;)</code>: Unlimited capacity mailbox</li> </ul> <p>Choosing a Mailbox:</p> Use Case Recommended Rationale High-throughput actors Bounded Prevents memory exhaustion Low-volume actors Unbounded Simpler, no backpressure Critical path Bounded Predictable latency Background tasks Unbounded Flexibility over control"},{"location":"components/rt/reference/api/messaging/#constructors","title":"Constructors","text":""},{"location":"components/rt/reference/api/messaging/#bounded","title":"<code>bounded()</code>","text":"<pre><code>pub fn bounded(capacity: usize) -&gt; Self\n</code></pre> <p>Creates a bounded mailbox with specified capacity.</p> <p>Parameters: - <code>capacity</code>: Maximum number of messages</p> <p>Default Backpressure: - Strategy: <code>BackpressureStrategy::Block</code> - Behavior: Senders block when mailbox is full</p> <p>Example:</p> <pre><code>use airssys_rt::mailbox::Mailbox;\n\nlet mailbox = Mailbox::&lt;MyActor&gt;::bounded(1000);\n</code></pre>"},{"location":"components/rt/reference/api/messaging/#unbounded","title":"<code>unbounded()</code>","text":"<pre><code>pub fn unbounded() -&gt; Self\n</code></pre> <p>Creates an unbounded mailbox with unlimited capacity.</p> <p>Returns: - <code>Mailbox&lt;A&gt;</code>: Unbounded mailbox instance</p> <p>Example:</p> <pre><code>let mailbox = Mailbox::&lt;MyActor&gt;::unbounded();\n</code></pre>"},{"location":"components/rt/reference/api/messaging/#methods_1","title":"Methods","text":""},{"location":"components/rt/reference/api/messaging/#enqueue","title":"<code>enqueue()</code>","text":"<pre><code>pub async fn enqueue(&amp;self, msg: Box&lt;dyn Message&gt;) -&gt; Result&lt;(), MailboxError&gt;\n</code></pre> <p>Adds a message to the mailbox.</p> <p>Parameters: - <code>msg</code>: Boxed message to enqueue</p> <p>Returns: - <code>Ok(())</code>: Message enqueued successfully - <code>Err(MailboxError::Full)</code>: Bounded mailbox at capacity - <code>Err(MailboxError::Closed)</code>: Mailbox has been closed</p> <p>Performance: - Bounded mailbox: ~181ns average - Unbounded mailbox: ~150ns average</p>"},{"location":"components/rt/reference/api/messaging/#dequeue","title":"<code>dequeue()</code>","text":"<pre><code>pub async fn dequeue(&amp;self) -&gt; Option&lt;Box&lt;dyn Message&gt;&gt;\n</code></pre> <p>Removes and returns the next message from the mailbox.</p> <p>Returns: - <code>Some(msg)</code>: Next message available - <code>None</code>: Mailbox is empty and closed</p> <p>Behavior: - Blocks until message available or mailbox closed - FIFO ordering (first-in, first-out)</p>"},{"location":"components/rt/reference/api/messaging/#close","title":"<code>close()</code>","text":"<pre><code>pub fn close(&amp;self)\n</code></pre> <p>Closes the mailbox, preventing new messages.</p> <p>Behavior: - Pending messages can still be dequeued - New <code>enqueue()</code> calls will fail - Dequeue returns <code>None</code> when empty</p>"},{"location":"components/rt/reference/api/messaging/#struct-boundedmailboxa","title":"Struct: <code>BoundedMailbox&lt;A&gt;</code>","text":"<pre><code>pub struct BoundedMailbox&lt;A: Actor&gt; {\n    // fields omitted\n}\n</code></pre> <p>Fixed-capacity mailbox with backpressure support.</p> <p>Implementation: - Uses <code>tokio::sync::mpsc::channel</code> internally - Configurable backpressure strategies - Memory-bounded operation</p>"},{"location":"components/rt/reference/api/messaging/#methods_2","title":"Methods","text":""},{"location":"components/rt/reference/api/messaging/#with_backpressure","title":"<code>with_backpressure()</code>","text":"<pre><code>pub fn with_backpressure(capacity: usize, strategy: BackpressureStrategy) -&gt; Self\n</code></pre> <p>Creates a bounded mailbox with custom backpressure strategy.</p> <p>Parameters: - <code>capacity</code>: Maximum messages - <code>strategy</code>: Backpressure behavior</p> <p>Example:</p> <pre><code>use airssys_rt::mailbox::{BoundedMailbox, BackpressureStrategy};\n\nlet mailbox = BoundedMailbox::with_backpressure(\n    1000,\n    BackpressureStrategy::DropOldest,\n);\n</code></pre>"},{"location":"components/rt/reference/api/messaging/#len","title":"<code>len()</code>","text":"<pre><code>pub fn len(&amp;self) -&gt; usize\n</code></pre> <p>Returns the current number of messages in the mailbox.</p> <p>Returns: - <code>usize</code>: Message count</p> <p>Use Cases: - Monitoring mailbox pressure - Load balancing decisions - Health checks</p>"},{"location":"components/rt/reference/api/messaging/#is_full","title":"<code>is_full()</code>","text":"<pre><code>pub fn is_full(&amp;self) -&gt; bool\n</code></pre> <p>Checks if the mailbox is at capacity.</p> <p>Returns: - <code>true</code>: Mailbox is full - <code>false</code>: Mailbox has available capacity</p>"},{"location":"components/rt/reference/api/messaging/#struct-unboundedmailboxa","title":"Struct: <code>UnboundedMailbox&lt;A&gt;</code>","text":"<pre><code>pub struct UnboundedMailbox&lt;A: Actor&gt; {\n    // fields omitted\n}\n</code></pre> <p>Unlimited-capacity mailbox.</p> <p>Implementation: - Uses <code>tokio::sync::mpsc::unbounded_channel</code> internally - No backpressure (will grow unbounded) - Faster enqueue than bounded (no capacity check)</p> <p>Warning: - Can consume unbounded memory under load - Recommend monitoring message queue length - Consider bounded mailbox for production systems</p>"},{"location":"components/rt/reference/api/messaging/#enum-backpressurestrategy","title":"Enum: <code>BackpressureStrategy</code>","text":"<pre><code>pub enum BackpressureStrategy {\n    Block,\n    DropOldest,\n    DropNewest,\n    Fail,\n}\n</code></pre> <p>Strategy for handling mailbox overflow.</p> <p>Variants:</p> <ul> <li><code>Block</code>: Block sender until space available (default)</li> <li><code>DropOldest</code>: Remove oldest message to make room</li> <li><code>DropNewest</code>: Drop the incoming message</li> <li><code>Fail</code>: Return error to sender</li> </ul> <p>Tradeoffs:</p> Strategy Latency Throughput Data Loss Use Case Block Variable Lower None Critical messages DropOldest Constant Higher Oldest Latest-value semantics DropNewest Constant Highest Newest Best-effort delivery Fail Constant Highest Newest Explicit error handling <p>Example:</p> <pre><code>use airssys_rt::mailbox::{BoundedMailbox, BackpressureStrategy};\n\n// Critical financial transactions - never drop\nlet ledger_mailbox = BoundedMailbox::with_backpressure(\n    1000,\n    BackpressureStrategy::Block,\n);\n\n// Sensor readings - only care about latest\nlet sensor_mailbox = BoundedMailbox::with_backpressure(\n    100,\n    BackpressureStrategy::DropOldest,\n);\n\n// Best-effort notifications\nlet notification_mailbox = BoundedMailbox::with_backpressure(\n    500,\n    BackpressureStrategy::Fail,\n);\n</code></pre>"},{"location":"components/rt/reference/api/messaging/#communication-patterns","title":"Communication Patterns","text":""},{"location":"components/rt/reference/api/messaging/#fire-and-forget","title":"Fire-and-Forget","text":"<p>Send a message without waiting for response.</p> <pre><code>// Message with no result\nstruct Notify {\n    event: String,\n}\nimpl Message for Notify {\n    type Result = ();\n}\n\n// Send without waiting\nactor_ref.tell(Notify {\n    event: \"user_logged_in\".to_string(),\n})?;\n</code></pre>"},{"location":"components/rt/reference/api/messaging/#request-reply","title":"Request-Reply","text":"<p>Synchronous-style communication.</p> <pre><code>struct GetBalance {\n    account_id: u64,\n}\nimpl Message for GetBalance {\n    type Result = f64;\n}\n\nlet balance = actor_ref.send(GetBalance { account_id: 123 }).await?;\n</code></pre>"},{"location":"components/rt/reference/api/messaging/#broadcast_1","title":"Broadcast","text":"<p>Send to multiple actors.</p> <pre><code>struct HealthCheck;\nimpl Message for HealthCheck {\n    type Result = bool;\n}\n\nlet results = broker.broadcast(HealthCheck).await;\n</code></pre>"},{"location":"components/rt/reference/api/messaging/#actor-pool","title":"Actor Pool","text":"<p>Load balance across workers.</p> <pre><code>struct WorkItem {\n    data: Vec&lt;u8&gt;,\n}\nimpl Message for WorkItem {\n    type Result = Vec&lt;u8&gt;;\n}\n\n// Round-robin distribution\nlet worker = pool.get_worker();\nlet result = worker.send(WorkItem { data }).await?;\n</code></pre>"},{"location":"components/rt/reference/api/messaging/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"components/rt/reference/api/messaging/#message-passing-latency","title":"Message Passing Latency","text":"Metric Latency Measurement Message enqueue 181ns Mailbox send operation Message dequeue 150ns Mailbox receive operation Roundtrip (send+receive) 737ns Full message cycle Cross-thread message 850ns With thread context switch"},{"location":"components/rt/reference/api/messaging/#throughput","title":"Throughput","text":"Configuration Messages/sec Notes Single actor 4.7M Single-threaded 4 actors (no contention) 18M Linear scaling 16 actors (high contention) 45M Sublinear scaling Broadcast (10 actors) 12M Parallel delivery"},{"location":"components/rt/reference/api/messaging/#memory-usage","title":"Memory Usage","text":"Component Size Notes Message (avg) 64 bytes Varies by type BoundedMailbox 8KB Capacity 1000 UnboundedMailbox 128 bytes Plus message storage Broker entry 48 bytes Per registered actor"},{"location":"components/rt/reference/api/messaging/#error-types","title":"Error Types","text":""},{"location":"components/rt/reference/api/messaging/#enum-mailboxerror","title":"Enum: <code>MailboxError</code>","text":"<pre><code>pub enum MailboxError {\n    Full,\n    Closed,\n    Timeout,\n}\n</code></pre> <p>Errors specific to mailbox operations.</p> <p>Variants:</p> <ul> <li><code>Full</code>: Bounded mailbox at capacity</li> <li><code>Closed</code>: Mailbox has been closed</li> <li><code>Timeout</code>: Operation timed out</li> </ul>"},{"location":"components/rt/reference/api/messaging/#enum-brokererror","title":"Enum: <code>BrokerError</code>","text":"<pre><code>pub enum BrokerError {\n    AlreadyRegistered,\n    NotFound,\n    RoutingFailed(String),\n}\n</code></pre> <p>Errors specific to broker operations.</p> <p>Variants:</p> <ul> <li><code>AlreadyRegistered</code>: Actor ID already registered</li> <li><code>NotFound</code>: Actor not found in broker</li> <li><code>RoutingFailed(String)</code>: Message routing failed</li> </ul>"},{"location":"components/rt/reference/api/messaging/#see-also","title":"See Also","text":"<ul> <li>Core API Reference - Core types and system API</li> <li>Actors API Reference - Actor types and patterns</li> <li>Mailbox API Reference - Detailed mailbox API</li> <li>Broker API Reference - Detailed broker API</li> <li>Architecture: Message Passing - Design overview</li> <li>How-To: Message Passing - Usage guide</li> </ul>"},{"location":"components/rt/reference/api/monitoring/","title":"Monitoring API Reference","text":"<p>This reference documents the monitoring and health check system for actors and supervisors.</p>"},{"location":"components/rt/reference/api/monitoring/#module-monitoring","title":"Module: <code>monitoring</code>","text":"<p>Health monitoring and metrics collection for actors.</p>"},{"location":"components/rt/reference/api/monitoring/#trait-healthcheck","title":"Trait: <code>HealthCheck</code>","text":"<pre><code>pub trait HealthCheck: Send + Sync {\n    async fn check_health(&amp;self, actor_id: ActorId) -&gt; HealthStatus;\n    fn health_check_interval(&amp;self) -&gt; Duration;\n    fn health_check_timeout(&amp;self) -&gt; Duration;\n}\n</code></pre> <p>Trait for implementing health checks on actors.</p> <p>Required Methods:</p> <ul> <li><code>check_health()</code>: Performs health check and returns status</li> <li><code>health_check_interval()</code>: How often to perform checks</li> <li><code>health_check_timeout()</code>: Maximum time to wait for response</li> </ul> <p>Trait Bounds: - <code>Send + Sync</code>: Can be safely shared across threads</p> <p>Example:</p> <pre><code>use airssys_rt::monitoring::{HealthCheck, HealthStatus};\nuse airssys_rt::util::ActorId;\nuse std::time::Duration;\n\nstruct PingHealthCheck;\n\n#[async_trait::async_trait]\nimpl HealthCheck for PingHealthCheck {\n    async fn check_health(&amp;self, actor_id: ActorId) -&gt; HealthStatus {\n        // Send ping message to actor\n        match send_ping(actor_id).await {\n            Ok(()) =&gt; HealthStatus::Healthy,\n            Err(e) =&gt; HealthStatus::Unhealthy {\n                reason: format!(\"Ping failed: {}\", e),\n            },\n        }\n    }\n\n    fn health_check_interval(&amp;self) -&gt; Duration {\n        Duration::from_secs(30)\n    }\n\n    fn health_check_timeout(&amp;self) -&gt; Duration {\n        Duration::from_secs(5)\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#enum-healthstatus","title":"Enum: <code>HealthStatus</code>","text":"<pre><code>pub enum HealthStatus {\n    Healthy,\n    Degraded {\n        reason: String,\n    },\n    Unhealthy {\n        reason: String,\n    },\n    Unknown,\n}\n</code></pre> <p>Represents the health state of an actor.</p> <p>Variants:</p> <ul> <li><code>Healthy</code>: Actor is functioning normally</li> <li><code>Degraded { reason }</code>: Actor is operational but with reduced performance</li> <li><code>Unhealthy { reason }</code>: Actor is not functioning correctly</li> <li><code>Unknown</code>: Health status cannot be determined</li> </ul> <p>State Transitions:</p> <pre><code>Unknown -&gt; Healthy       (successful health check)\nUnknown -&gt; Unhealthy     (failed health check)\nHealthy -&gt; Degraded      (performance issue detected)\nHealthy -&gt; Unhealthy     (critical failure)\nDegraded -&gt; Healthy      (issue resolved)\nDegraded -&gt; Unhealthy    (issue worsened)\nUnhealthy -&gt; Degraded    (partial recovery)\nUnhealthy -&gt; Healthy     (full recovery)\n</code></pre> <p>Example:</p> <pre><code>use airssys_rt::monitoring::HealthStatus;\n\nfn handle_health_status(status: HealthStatus) {\n    match status {\n        HealthStatus::Healthy =&gt; {\n            println!(\"\u2713 Actor is healthy\");\n        }\n        HealthStatus::Degraded { reason } =&gt; {\n            eprintln!(\"\u26a0 Actor degraded: {}\", reason);\n            // Maybe reduce load\n        }\n        HealthStatus::Unhealthy { reason } =&gt; {\n            eprintln!(\"\u2717 Actor unhealthy: {}\", reason);\n            // Trigger restart or failover\n        }\n        HealthStatus::Unknown =&gt; {\n            eprintln!(\"? Actor health unknown\");\n            // Retry health check\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#health-monitoring","title":"Health Monitoring","text":""},{"location":"components/rt/reference/api/monitoring/#struct-healthmonitor","title":"Struct: <code>HealthMonitor</code>","text":"<pre><code>pub struct HealthMonitor {\n    // fields omitted\n}\n</code></pre> <p>Monitors actor health and triggers recovery actions.</p> <p>Features: - Periodic health checks - Automatic unhealthy actor detection - Integration with supervisor for restarts - Configurable check intervals and timeouts - Health history tracking</p>"},{"location":"components/rt/reference/api/monitoring/#constructors","title":"Constructors","text":""},{"location":"components/rt/reference/api/monitoring/#new","title":"<code>new()</code>","text":"<pre><code>pub fn new(system: Arc&lt;ActorSystem&gt;) -&gt; Self\n</code></pre> <p>Creates a new health monitor.</p> <p>Parameters: - <code>system</code>: The actor system to monitor</p> <p>Example:</p> <pre><code>use airssys_rt::monitoring::HealthMonitor;\nuse std::sync::Arc;\n\nlet monitor = HealthMonitor::new(Arc::clone(&amp;system));\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#with_config","title":"<code>with_config()</code>","text":"<pre><code>pub fn with_config(system: Arc&lt;ActorSystem&gt;, config: HealthMonitorConfig) -&gt; Self\n</code></pre> <p>Creates a health monitor with custom configuration.</p> <p>Parameters: - <code>system</code>: Actor system to monitor - <code>config</code>: Health monitor configuration</p> <p>Example:</p> <pre><code>use airssys_rt::monitoring::{HealthMonitor, HealthMonitorConfig};\nuse std::time::Duration;\n\nlet config = HealthMonitorConfig {\n    check_interval: Duration::from_secs(10),\n    check_timeout: Duration::from_secs(2),\n    failure_threshold: 3,\n    recovery_threshold: 2,\n};\n\nlet monitor = HealthMonitor::with_config(Arc::clone(&amp;system), config);\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#methods","title":"Methods","text":""},{"location":"components/rt/reference/api/monitoring/#monitor_actor","title":"<code>monitor_actor()</code>","text":"<pre><code>pub async fn monitor_actor&lt;H&gt;(&amp;self, actor_id: ActorId, health_check: H)\nwhere\n    H: HealthCheck + 'static,\n</code></pre> <p>Starts monitoring an actor with a custom health check.</p> <p>Type Parameters: - <code>H</code>: The health check implementation</p> <p>Parameters: - <code>actor_id</code>: Actor to monitor - <code>health_check</code>: Health check implementation</p> <p>Behavior: - Spawns background task for periodic checks - Continues until actor stops or monitor is stopped - Reports status changes to supervisor (if supervised)</p> <p>Example:</p> <pre><code>use airssys_rt::monitoring::PingHealthCheck;\n\nmonitor.monitor_actor(actor_id, PingHealthCheck).await;\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#stop_monitoring","title":"<code>stop_monitoring()</code>","text":"<pre><code>pub fn stop_monitoring(&amp;self, actor_id: ActorId) -&gt; Result&lt;(), MonitoringError&gt;\n</code></pre> <p>Stops monitoring an actor.</p> <p>Parameters: - <code>actor_id</code>: Actor to stop monitoring</p> <p>Returns: - <code>Ok(())</code>: Monitoring stopped successfully - <code>Err(MonitoringError::NotMonitored)</code>: Actor was not being monitored</p> <p>Example:</p> <pre><code>monitor.stop_monitoring(actor_id)?;\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#get_health_status","title":"<code>get_health_status()</code>","text":"<pre><code>pub fn get_health_status(&amp;self, actor_id: ActorId) -&gt; Option&lt;HealthStatus&gt;\n</code></pre> <p>Gets the current health status of an actor.</p> <p>Parameters: - <code>actor_id</code>: Actor to query</p> <p>Returns: - <code>Some(HealthStatus)</code>: Current health status - <code>None</code>: Actor not being monitored</p> <p>Example:</p> <pre><code>if let Some(status) = monitor.get_health_status(actor_id) {\n    println!(\"Actor health: {:?}\", status);\n}\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#get_health_history","title":"<code>get_health_history()</code>","text":"<pre><code>pub fn get_health_history(&amp;self, actor_id: ActorId, limit: usize) -&gt; Vec&lt;HealthRecord&gt;\n</code></pre> <p>Gets the health check history for an actor.</p> <p>Parameters: - <code>actor_id</code>: Actor to query - <code>limit</code>: Maximum number of records to return</p> <p>Returns: - <code>Vec&lt;HealthRecord&gt;</code>: Health check history (most recent first)</p> <p>Example:</p> <pre><code>let history = monitor.get_health_history(actor_id, 10);\nfor record in history {\n    println!(\"{}: {:?}\", record.timestamp, record.status);\n}\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#health-monitoring-configuration","title":"Health Monitoring Configuration","text":""},{"location":"components/rt/reference/api/monitoring/#struct-healthmonitorconfig","title":"Struct: <code>HealthMonitorConfig</code>","text":"<pre><code>pub struct HealthMonitorConfig {\n    pub check_interval: Duration,\n    pub check_timeout: Duration,\n    pub failure_threshold: u32,\n    pub recovery_threshold: u32,\n}\n</code></pre> <p>Configuration for health monitoring behavior.</p> <p>Fields:</p> <ul> <li><code>check_interval</code>: Time between health checks</li> <li><code>check_timeout</code>: Maximum time to wait for health check response</li> <li><code>failure_threshold</code>: Number of consecutive failures before marking unhealthy</li> <li><code>recovery_threshold</code>: Number of consecutive successes before marking healthy</li> </ul> <p>Default Values:</p> <pre><code>impl Default for HealthMonitorConfig {\n    fn default() -&gt; Self {\n        Self {\n            check_interval: Duration::from_secs(30),\n            check_timeout: Duration::from_secs(5),\n            failure_threshold: 3,\n            recovery_threshold: 2,\n        }\n    }\n}\n</code></pre> <p>Example:</p> <pre><code>use airssys_rt::monitoring::HealthMonitorConfig;\nuse std::time::Duration;\n\n// Aggressive monitoring for critical service\nlet critical_config = HealthMonitorConfig {\n    check_interval: Duration::from_secs(5),\n    check_timeout: Duration::from_secs(1),\n    failure_threshold: 2,\n    recovery_threshold: 3,\n};\n\n// Relaxed monitoring for background worker\nlet worker_config = HealthMonitorConfig {\n    check_interval: Duration::from_secs(60),\n    check_timeout: Duration::from_secs(10),\n    failure_threshold: 5,\n    recovery_threshold: 2,\n};\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#built-in-health-checks","title":"Built-in Health Checks","text":""},{"location":"components/rt/reference/api/monitoring/#struct-pinghealthcheck","title":"Struct: <code>PingHealthCheck</code>","text":"<pre><code>pub struct PingHealthCheck;\n</code></pre> <p>Simple ping-based health check.</p> <p>Behavior: - Sends ping message to actor - Expects pong response within timeout - Marks healthy if response received</p> <p>Example:</p> <pre><code>use airssys_rt::monitoring::PingHealthCheck;\n\nmonitor.monitor_actor(actor_id, PingHealthCheck).await;\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#struct-messageratehealthcheck","title":"Struct: <code>MessageRateHealthCheck</code>","text":"<pre><code>pub struct MessageRateHealthCheck {\n    pub min_messages_per_sec: f64,\n}\n</code></pre> <p>Health check based on message processing rate.</p> <p>Fields: - <code>min_messages_per_sec</code>: Minimum expected message processing rate</p> <p>Behavior: - Tracks actor's message processing rate - Marks degraded if below minimum rate - Marks unhealthy if processing stopped</p> <p>Example:</p> <pre><code>use airssys_rt::monitoring::MessageRateHealthCheck;\n\nlet health_check = MessageRateHealthCheck {\n    min_messages_per_sec: 100.0,\n};\n\nmonitor.monitor_actor(worker_id, health_check).await;\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#struct-memoryhealthcheck","title":"Struct: <code>MemoryHealthCheck</code>","text":"<pre><code>pub struct MemoryHealthCheck {\n    pub max_memory_mb: usize,\n}\n</code></pre> <p>Health check based on actor memory usage.</p> <p>Fields: - <code>max_memory_mb</code>: Maximum acceptable memory usage in MB</p> <p>Behavior: - Monitors actor's memory footprint - Marks degraded if approaching limit (&gt;80%) - Marks unhealthy if exceeding limit</p> <p>Example:</p> <pre><code>use airssys_rt::monitoring::MemoryHealthCheck;\n\nlet health_check = MemoryHealthCheck {\n    max_memory_mb: 100,  // 100 MB limit\n};\n\nmonitor.monitor_actor(actor_id, health_check).await;\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#struct-compositehealthcheck","title":"Struct: <code>CompositeHealthCheck</code>","text":"<pre><code>pub struct CompositeHealthCheck {\n    checks: Vec&lt;Box&lt;dyn HealthCheck&gt;&gt;,\n}\n</code></pre> <p>Combines multiple health checks with AND logic.</p> <p>Behavior: - Runs all health checks in parallel - Healthy only if all checks are healthy - Degraded if any check is degraded - Unhealthy if any check is unhealthy</p> <p>Example:</p> <pre><code>use airssys_rt::monitoring::{CompositeHealthCheck, PingHealthCheck, MessageRateHealthCheck};\n\nlet composite = CompositeHealthCheck::new()\n    .add_check(PingHealthCheck)\n    .add_check(MessageRateHealthCheck { min_messages_per_sec: 50.0 })\n    .add_check(MemoryHealthCheck { max_memory_mb: 200 });\n\nmonitor.monitor_actor(actor_id, composite).await;\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#health-records","title":"Health Records","text":""},{"location":"components/rt/reference/api/monitoring/#struct-healthrecord","title":"Struct: <code>HealthRecord</code>","text":"<pre><code>pub struct HealthRecord {\n    pub timestamp: DateTime&lt;Utc&gt;,\n    pub status: HealthStatus,\n    pub check_duration: Duration,\n}\n</code></pre> <p>Record of a single health check execution.</p> <p>Fields:</p> <ul> <li><code>timestamp</code>: When the health check was performed (UTC)</li> <li><code>status</code>: The health status result</li> <li><code>check_duration</code>: How long the health check took</li> </ul> <p>Example:</p> <pre><code>use chrono::{DateTime, Utc};\n\nlet history = monitor.get_health_history(actor_id, 5);\nfor record in history {\n    println!(\"[{}] {:?} (took {:?})\",\n        record.timestamp.format(\"%Y-%m-%d %H:%M:%S\"),\n        record.status,\n        record.check_duration\n    );\n}\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#supervisor-integration","title":"Supervisor Integration","text":""},{"location":"components/rt/reference/api/monitoring/#automatic-health-monitoring","title":"Automatic Health Monitoring","text":"<p>Supervisors can automatically monitor child actors.</p> <pre><code>use airssys_rt::{Supervisor, ChildSpec};\nuse airssys_rt::monitoring::{HealthMonitor, PingHealthCheck};\nuse std::time::Duration;\n\nimpl Supervisor for MonitoredSupervisor {\n    fn child_specs(&amp;self) -&gt; Vec&lt;ChildSpec&gt; {\n        vec![\n            ChildSpec::new(\"worker\", || Worker::new())\n                .with_health_check(PingHealthCheck)\n                .with_health_interval(Duration::from_secs(30))\n                .with_restart_on_unhealthy(true),\n        ]\n    }\n\n    fn restart_strategy(&amp;self) -&gt; RestartStrategy {\n        RestartStrategy::OneForOne\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#health-based-restart-policy","title":"Health-Based Restart Policy","text":"<pre><code>use airssys_rt::monitoring::HealthBasedRestartPolicy;\n\nlet policy = HealthBasedRestartPolicy {\n    restart_on_unhealthy: true,\n    restart_on_degraded: false,\n    max_restarts: 3,\n    restart_window: Duration::from_secs(60),\n};\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#metrics-and-reporting","title":"Metrics and Reporting","text":""},{"location":"components/rt/reference/api/monitoring/#struct-healthmetrics","title":"Struct: <code>HealthMetrics</code>","text":"<pre><code>pub struct HealthMetrics {\n    pub total_checks: u64,\n    pub healthy_checks: u64,\n    pub degraded_checks: u64,\n    pub unhealthy_checks: u64,\n    pub avg_check_duration: Duration,\n}\n</code></pre> <p>Aggregated health check metrics.</p> <p>Fields:</p> <ul> <li><code>total_checks</code>: Total number of health checks performed</li> <li><code>healthy_checks</code>: Number of healthy results</li> <li><code>degraded_checks</code>: Number of degraded results</li> <li><code>unhealthy_checks</code>: Number of unhealthy results</li> <li><code>avg_check_duration</code>: Average time per health check</li> </ul>"},{"location":"components/rt/reference/api/monitoring/#methods_1","title":"Methods","text":""},{"location":"components/rt/reference/api/monitoring/#health_percentage","title":"<code>health_percentage()</code>","text":"<pre><code>pub fn health_percentage(&amp;self) -&gt; f64\n</code></pre> <p>Calculates percentage of healthy checks.</p> <p>Example:</p> <pre><code>let metrics = monitor.get_metrics(actor_id);\nprintln!(\"Health: {:.1}%\", metrics.health_percentage());\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"components/rt/reference/api/monitoring/#health-check-overhead","title":"Health Check Overhead","text":"Check Type Latency Frequency Overhead Ping 0.5-2ms 30s Negligible MessageRate 50-100\u00b5s 30s &lt;0.01% Memory 100-500\u00b5s 60s &lt;0.01% Composite (3 checks) 1-3ms 30s &lt;0.1%"},{"location":"components/rt/reference/api/monitoring/#memory-usage","title":"Memory Usage","text":"Component Size Per Actor Notes HealthMonitor ~512 bytes - Base structure Per-actor state ~256 bytes Yes Status + history Health history (10 records) ~480 bytes Yes Circular buffer"},{"location":"components/rt/reference/api/monitoring/#recommended-check-intervals","title":"Recommended Check Intervals","text":"Actor Type Check Interval Timeout Failure Threshold Critical service 10s 2s 2 Standard actor 30s 5s 3 Background worker 60s 10s 5 Batch processor 120s 30s 3"},{"location":"components/rt/reference/api/monitoring/#error-types","title":"Error Types","text":""},{"location":"components/rt/reference/api/monitoring/#enum-monitoringerror","title":"Enum: <code>MonitoringError</code>","text":"<pre><code>pub enum MonitoringError {\n    NotMonitored,\n    CheckFailed(String),\n    Timeout,\n    SystemError(String),\n}\n</code></pre> <p>Errors specific to monitoring operations.</p> <p>Variants:</p> <ul> <li><code>NotMonitored</code>: Actor is not being monitored</li> <li><code>CheckFailed(String)</code>: Health check execution failed</li> <li><code>Timeout</code>: Health check exceeded timeout</li> <li><code>SystemError(String)</code>: System-level monitoring error</li> </ul> <p>Example:</p> <pre><code>use airssys_rt::monitoring::MonitoringError;\n\nmatch monitor.stop_monitoring(actor_id) {\n    Ok(()) =&gt; println!(\"Stopped monitoring\"),\n    Err(MonitoringError::NotMonitored) =&gt; {\n        println!(\"Actor wasn't being monitored\");\n    }\n    Err(e) =&gt; eprintln!(\"Error: {:?}\", e),\n}\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#testing-utilities","title":"Testing Utilities","text":""},{"location":"components/rt/reference/api/monitoring/#struct-mockhealthcheck","title":"Struct: <code>MockHealthCheck</code>","text":"<pre><code>pub struct MockHealthCheck {\n    // fields omitted\n}\n</code></pre> <p>Mock health check for testing.</p> <p>Available in: Test builds only (<code>#[cfg(test)]</code>)</p>"},{"location":"components/rt/reference/api/monitoring/#methods_2","title":"Methods","text":""},{"location":"components/rt/reference/api/monitoring/#new_1","title":"<code>new()</code>","text":"<pre><code>pub fn new() -&gt; Self\n</code></pre> <p>Creates a new mock health check.</p>"},{"location":"components/rt/reference/api/monitoring/#set_status","title":"<code>set_status()</code>","text":"<pre><code>pub fn set_status(&amp;mut self, status: HealthStatus)\n</code></pre> <p>Sets the status this health check will return.</p> <p>Example:</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use airssys_rt::monitoring::{MockHealthCheck, HealthStatus};\n\n    #[tokio::test]\n    async fn test_unhealthy_actor_restart() {\n        let mut health_check = MockHealthCheck::new();\n        health_check.set_status(HealthStatus::Unhealthy {\n            reason: \"Test failure\".to_string(),\n        });\n\n        monitor.monitor_actor(actor_id, health_check).await;\n\n        // Wait for health check\n        tokio::time::sleep(Duration::from_secs(1)).await;\n\n        // Verify actor was restarted\n        assert!(supervisor_probe.was_restarted(actor_id));\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#best-practices","title":"Best Practices","text":""},{"location":"components/rt/reference/api/monitoring/#health-check-design","title":"Health Check Design","text":"<pre><code>// \u2705 Good - Lightweight and focused\nstruct QuickHealthCheck;\nimpl HealthCheck for QuickHealthCheck {\n    async fn check_health(&amp;self, actor_id: ActorId) -&gt; HealthStatus {\n        // Simple ping, returns quickly\n        ping_actor(actor_id).await\n    }\n}\n\n// \u274c Bad - Expensive operations\nstruct SlowHealthCheck;\nimpl HealthCheck for SlowHealthCheck {\n    async fn check_health(&amp;self, actor_id: ActorId) -&gt; HealthStatus {\n        // Complex database query (too slow)\n        database.complex_query().await;\n        HealthStatus::Healthy\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#monitoring-configuration","title":"Monitoring Configuration","text":"<pre><code>// \u2705 Good - Reasonable intervals and thresholds\nlet config = HealthMonitorConfig {\n    check_interval: Duration::from_secs(30),\n    check_timeout: Duration::from_secs(5),\n    failure_threshold: 3,  // Avoid false positives\n    recovery_threshold: 2,\n};\n\n// \u274c Bad - Too aggressive, overhead too high\nlet bad_config = HealthMonitorConfig {\n    check_interval: Duration::from_millis(100),  // Too frequent!\n    check_timeout: Duration::from_secs(30),      // Timeout &gt; interval!\n    failure_threshold: 1,                        // No tolerance for transients\n    recovery_threshold: 10,                      // Takes too long to recover\n};\n</code></pre>"},{"location":"components/rt/reference/api/monitoring/#see-also","title":"See Also","text":"<ul> <li>Core API Reference - Core types and system</li> <li>Actors API Reference - Actor lifecycle</li> <li>Supervisors API Reference - Supervision integration</li> <li>Architecture: Supervision - Design overview</li> <li>How-To: Supervisor Patterns - Usage patterns</li> </ul>"},{"location":"components/rt/reference/api/supervisors/","title":"Supervisors API Reference","text":"<p>This reference documents the supervision system, restart strategies, and fault tolerance mechanisms.</p>"},{"location":"components/rt/reference/api/supervisors/#module-supervisor","title":"Module: <code>supervisor</code>","text":"<p>Supervision and fault tolerance types.</p>"},{"location":"components/rt/reference/api/supervisors/#trait-supervisor","title":"Trait: <code>Supervisor</code>","text":"<pre><code>pub trait Supervisor: Actor {\n    fn child_specs(&amp;self) -&gt; Vec&lt;ChildSpec&gt;;\n    fn restart_strategy(&amp;self) -&gt; RestartStrategy;\n\n    async fn handle_child_failure(\n        &amp;mut self,\n        child_id: ActorId,\n        error: ActorError,\n        ctx: &amp;mut ActorContext&lt;Self&gt;,\n    ) -&gt; ErrorAction {\n        // Default implementation based on restart_strategy()\n    }\n}\n</code></pre> <p>Trait for actors that supervise child actors.</p> <p>Required Methods:</p> <ul> <li><code>child_specs()</code>: Returns specifications for children to spawn</li> <li><code>restart_strategy()</code>: Returns the restart strategy to use</li> </ul> <p>Provided Methods:</p> <ul> <li><code>handle_child_failure()</code>: Handles child actor failures (default: apply restart_strategy)</li> </ul> <p>Trait Bounds: - Must implement <code>Actor</code></p> <p>Example:</p> <pre><code>use airssys_rt::{Actor, ActorContext, Supervisor, ChildSpec, RestartStrategy};\n\nstruct AppSupervisor {\n    workers: Vec&lt;ActorRef&lt;Worker&gt;&gt;,\n}\n\nimpl Actor for AppSupervisor {\n    async fn receive(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;, msg: Box&lt;dyn Message&gt;) {\n        // Handle messages\n    }\n}\n\nimpl Supervisor for AppSupervisor {\n    fn child_specs(&amp;self) -&gt; Vec&lt;ChildSpec&gt; {\n        vec![\n            ChildSpec::new(\"worker-1\", || Worker::new()),\n            ChildSpec::new(\"worker-2\", || Worker::new()),\n            ChildSpec::new(\"worker-3\", || Worker::new()),\n        ]\n    }\n\n    fn restart_strategy(&amp;self) -&gt; RestartStrategy {\n        RestartStrategy::OneForOne\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#trait-child","title":"Trait: <code>Child</code>","text":"<pre><code>pub trait Child: Actor {\n    fn child_id(&amp;self) -&gt; &amp;str;\n    fn restart_policy(&amp;self) -&gt; RestartPolicy;\n}\n</code></pre> <p>Trait for actors that can be supervised.</p> <p>Required Methods:</p> <ul> <li><code>child_id()</code>: Returns unique identifier for this child</li> <li><code>restart_policy()</code>: Returns restart policy for this child</li> </ul> <p>Example:</p> <pre><code>use airssys_rt::{Actor, Child, RestartPolicy};\n\nstruct Worker {\n    id: String,\n    max_retries: u32,\n}\n\nimpl Actor for Worker {\n    async fn receive(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;, msg: Box&lt;dyn Message&gt;) {\n        // Handle messages\n    }\n}\n\nimpl Child for Worker {\n    fn child_id(&amp;self) -&gt; &amp;str {\n        &amp;self.id\n    }\n\n    fn restart_policy(&amp;self) -&gt; RestartPolicy {\n        RestartPolicy::Transient {\n            max_retries: self.max_retries,\n            backoff: Duration::from_secs(1),\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#child-specifications","title":"Child Specifications","text":""},{"location":"components/rt/reference/api/supervisors/#struct-childspec","title":"Struct: <code>ChildSpec</code>","text":"<pre><code>pub struct ChildSpec {\n    pub id: String,\n    pub factory: Box&lt;dyn Fn() -&gt; Box&lt;dyn Actor&gt; + Send + Sync&gt;,\n    pub restart_policy: RestartPolicy,\n}\n</code></pre> <p>Specification for spawning and managing a child actor.</p> <p>Fields:</p> <ul> <li><code>id</code>: Unique identifier for the child</li> <li><code>factory</code>: Function to create new child instances</li> <li><code>restart_policy</code>: Policy for restarting on failure</li> </ul>"},{"location":"components/rt/reference/api/supervisors/#constructors","title":"Constructors","text":""},{"location":"components/rt/reference/api/supervisors/#new","title":"<code>new()</code>","text":"<pre><code>pub fn new&lt;F, A&gt;(id: &amp;str, factory: F) -&gt; Self\nwhere\n    F: Fn() -&gt; A + Send + Sync + 'static,\n    A: Actor,\n</code></pre> <p>Creates a child specification with default restart policy.</p> <p>Type Parameters: - <code>F</code>: Factory function type - <code>A</code>: Actor type</p> <p>Parameters: - <code>id</code>: Unique identifier - <code>factory</code>: Function to create actor instances</p> <p>Default Policy: - <code>RestartPolicy::Permanent</code> (always restart)</p> <p>Example:</p> <pre><code>use airssys_rt::supervisor::ChildSpec;\n\nlet spec = ChildSpec::new(\"worker\", || Worker::new());\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#with_policy","title":"<code>with_policy()</code>","text":"<pre><code>pub fn with_policy&lt;F, A&gt;(id: &amp;str, factory: F, policy: RestartPolicy) -&gt; Self\nwhere\n    F: Fn() -&gt; A + Send + Sync + 'static,\n    A: Actor,\n</code></pre> <p>Creates a child specification with custom restart policy.</p> <p>Example:</p> <pre><code>use airssys_rt::supervisor::{ChildSpec, RestartPolicy};\nuse std::time::Duration;\n\nlet spec = ChildSpec::with_policy(\n    \"worker\",\n    || Worker::new(),\n    RestartPolicy::Transient {\n        max_retries: 3,\n        backoff: Duration::from_secs(1),\n    },\n);\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#restart-strategies","title":"Restart Strategies","text":""},{"location":"components/rt/reference/api/supervisors/#enum-restartstrategy","title":"Enum: <code>RestartStrategy</code>","text":"<pre><code>pub enum RestartStrategy {\n    OneForOne,\n    OneForAll,\n    RestForOne,\n}\n</code></pre> <p>Strategy for restarting child actors when failures occur.</p> <p>Variants:</p> <ul> <li><code>OneForOne</code>: Restart only the failed child</li> <li><code>OneForAll</code>: Restart all children when any child fails</li> <li><code>RestForOne</code>: Restart failed child and all children started after it</li> </ul> <p>Performance Characteristics:</p> Strategy Latency Disruption Use Case OneForOne 10-50\u00b5s Minimal Independent workers OneForAll 30-150\u00b5s Complete Interdependent components RestForOne 20-100\u00b5s Partial Pipeline stages <p>Visual Representation:</p> <pre><code>OneForOne:\nBefore: [A] [B] [C] [D]\nB fails: [A] [B'] [C] [D]  (only B restarted)\n\nOneForAll:\nBefore: [A] [B] [C] [D]\nB fails: [A'] [B'] [C'] [D']  (all restarted)\n\nRestForOne:\nBefore: [A] [B] [C] [D]\nB fails: [A] [B'] [C'] [D']  (B, C, D restarted)\n</code></pre> <p>Decision Guide:</p> <pre><code>// Independent workers - failures don't affect each other\nimpl Supervisor for WorkerPool {\n    fn restart_strategy(&amp;self) -&gt; RestartStrategy {\n        RestartStrategy::OneForOne\n    }\n}\n\n// Interconnected services - need consistent state\nimpl Supervisor for ServiceCluster {\n    fn restart_strategy(&amp;self) -&gt; RestartStrategy {\n        RestartStrategy::OneForAll\n    }\n}\n\n// Pipeline stages - downstream depends on upstream\nimpl Supervisor for Pipeline {\n    fn restart_strategy(&amp;self) -&gt; RestartStrategy {\n        RestartStrategy::RestForOne\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#enum-restartpolicy","title":"Enum: <code>RestartPolicy</code>","text":"<pre><code>pub enum RestartPolicy {\n    Permanent,\n    Temporary,\n    Transient {\n        max_retries: u32,\n        backoff: Duration,\n    },\n}\n</code></pre> <p>Policy for when and how to restart a specific child.</p> <p>Variants:</p> <ul> <li><code>Permanent</code>: Always restart on failure (default)</li> <li><code>Temporary</code>: Never restart, remove on failure</li> <li><code>Transient { max_retries, backoff }</code>: Restart up to max_retries with exponential backoff</li> </ul> <p>Use Cases:</p> <pre><code>use airssys_rt::supervisor::RestartPolicy;\nuse std::time::Duration;\n\n// Critical service - must always be running\nlet database_policy = RestartPolicy::Permanent;\n\n// One-time initialization task\nlet init_policy = RestartPolicy::Temporary;\n\n// Flaky external service - retry with backoff\nlet api_policy = RestartPolicy::Transient {\n    max_retries: 5,\n    backoff: Duration::from_secs(2),\n};\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#supervisor-builder-pattern-rt-task-013","title":"Supervisor Builder Pattern (RT-TASK-013)","text":""},{"location":"components/rt/reference/api/supervisors/#struct-supervisorbuilder","title":"Struct: <code>SupervisorBuilder</code>","text":"<pre><code>pub struct SupervisorBuilder {\n    // fields omitted\n}\n</code></pre> <p>Builder for creating supervisors with fluent API.</p>"},{"location":"components/rt/reference/api/supervisors/#methods","title":"Methods","text":""},{"location":"components/rt/reference/api/supervisors/#new_1","title":"<code>new()</code>","text":"<pre><code>pub fn new(name: &amp;str) -&gt; Self\n</code></pre> <p>Creates a new supervisor builder.</p> <p>Parameters: - <code>name</code>: Supervisor identifier</p> <p>Example:</p> <pre><code>use airssys_rt::supervisor::SupervisorBuilder;\n\nlet builder = SupervisorBuilder::new(\"app-supervisor\");\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#with_strategy","title":"<code>with_strategy()</code>","text":"<pre><code>pub fn with_strategy(mut self, strategy: RestartStrategy) -&gt; Self\n</code></pre> <p>Sets the restart strategy.</p> <p>Parameters: - <code>strategy</code>: Restart strategy to use</p> <p>Returns: - <code>Self</code>: Builder for method chaining</p> <p>Example:</p> <pre><code>builder.with_strategy(RestartStrategy::OneForAll)\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#add_child","title":"<code>add_child()</code>","text":"<pre><code>pub fn add_child(mut self, spec: ChildSpec) -&gt; Self\n</code></pre> <p>Adds a child specification.</p> <p>Parameters: - <code>spec</code>: Child specification</p> <p>Returns: - <code>Self</code>: Builder for method chaining</p> <p>Example:</p> <pre><code>builder.add_child(ChildSpec::new(\"worker-1\", || Worker::new()))\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#build","title":"<code>build()</code>","text":"<pre><code>pub fn build(self) -&gt; Result&lt;GenericSupervisor, BuildError&gt;\n</code></pre> <p>Builds the supervisor.</p> <p>Returns: - <code>Ok(GenericSupervisor)</code>: Successfully built supervisor - <code>Err(BuildError)</code>: Build failed (e.g., no children specified)</p> <p>Example:</p> <pre><code>use airssys_rt::supervisor::{SupervisorBuilder, ChildSpec, RestartStrategy};\n\nlet supervisor = SupervisorBuilder::new(\"app\")\n    .with_strategy(RestartStrategy::OneForOne)\n    .add_child(ChildSpec::new(\"worker-1\", || Worker::new()))\n    .add_child(ChildSpec::new(\"worker-2\", || Worker::new()))\n    .add_child(ChildSpec::new(\"worker-3\", || Worker::new()))\n    .build()?;\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#supervision-patterns","title":"Supervision Patterns","text":""},{"location":"components/rt/reference/api/supervisors/#basic-supervision","title":"Basic Supervision","text":"<pre><code>use airssys_rt::{Actor, ActorContext, Supervisor, ChildSpec, RestartStrategy};\n\nstruct WorkerSupervisor;\n\nimpl Actor for WorkerSupervisor {\n    async fn receive(&amp;mut self, ctx: &amp;mut ActorContext&lt;Self&gt;, msg: Box&lt;dyn Message&gt;) {\n        // Handle supervisor messages\n    }\n}\n\nimpl Supervisor for WorkerSupervisor {\n    fn child_specs(&amp;self) -&gt; Vec&lt;ChildSpec&gt; {\n        vec![\n            ChildSpec::new(\"worker-1\", || Worker::new()),\n            ChildSpec::new(\"worker-2\", || Worker::new()),\n        ]\n    }\n\n    fn restart_strategy(&amp;self) -&gt; RestartStrategy {\n        RestartStrategy::OneForOne\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#hierarchical-supervision","title":"Hierarchical Supervision","text":"<pre><code>// Top-level supervisor\nstruct AppSupervisor;\n\nimpl Supervisor for AppSupervisor {\n    fn child_specs(&amp;self) -&gt; Vec&lt;ChildSpec&gt; {\n        vec![\n            ChildSpec::new(\"web-supervisor\", || WebSupervisor),\n            ChildSpec::new(\"db-supervisor\", || DbSupervisor),\n            ChildSpec::new(\"cache-supervisor\", || CacheSupervisor),\n        ]\n    }\n\n    fn restart_strategy(&amp;self) -&gt; RestartStrategy {\n        RestartStrategy::OneForAll  // Coordinated restart\n    }\n}\n\n// Mid-level supervisor\nstruct WebSupervisor;\n\nimpl Supervisor for WebSupervisor {\n    fn child_specs(&amp;self) -&gt; Vec&lt;ChildSpec&gt; {\n        vec![\n            ChildSpec::new(\"http-server\", || HttpServer::new()),\n            ChildSpec::new(\"websocket-server\", || WebSocketServer::new()),\n        ]\n    }\n\n    fn restart_strategy(&amp;self) -&gt; RestartStrategy {\n        RestartStrategy::RestForOne  // Sequential dependency\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#custom-failure-handling","title":"Custom Failure Handling","text":"<pre><code>impl Supervisor for CustomSupervisor {\n    fn child_specs(&amp;self) -&gt; Vec&lt;ChildSpec&gt; {\n        // ... child specs ...\n    }\n\n    fn restart_strategy(&amp;self) -&gt; RestartStrategy {\n        RestartStrategy::OneForOne\n    }\n\n    async fn handle_child_failure(\n        &amp;mut self,\n        child_id: ActorId,\n        error: ActorError,\n        ctx: &amp;mut ActorContext&lt;Self&gt;,\n    ) -&gt; ErrorAction {\n        // Log failure\n        eprintln!(\"Child {} failed: {:?}\", child_id, error);\n\n        // Custom logic based on error type\n        match error {\n            ActorError::Timeout =&gt; {\n                // Timeouts are transient, restart\n                ErrorAction::Restart\n            }\n            ActorError::ConfigError(_) =&gt; {\n                // Config errors are permanent, stop\n                ErrorAction::Stop\n            }\n            _ =&gt; {\n                // Unknown errors, escalate\n                ErrorAction::Escalate\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#health-monitoring-integration","title":"Health Monitoring Integration","text":""},{"location":"components/rt/reference/api/supervisors/#automatic-health-checks","title":"Automatic Health Checks","text":"<pre><code>use airssys_rt::supervisor::HealthCheck;\n\nimpl Supervisor for MonitoredSupervisor {\n    fn child_specs(&amp;self) -&gt; Vec&lt;ChildSpec&gt; {\n        vec![\n            ChildSpec::new(\"worker\", || Worker::new())\n                .with_health_check(HealthCheck {\n                    interval: Duration::from_secs(30),\n                    timeout: Duration::from_secs(5),\n                }),\n        ]\n    }\n\n    fn restart_strategy(&amp;self) -&gt; RestartStrategy {\n        RestartStrategy::OneForOne\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#manual-health-checks","title":"Manual Health Checks","text":"<pre><code>use airssys_rt::Message;\n\nstruct CheckHealth;\nimpl Message for CheckHealth {\n    type Result = HealthStatus;\n}\n\nimpl Handler&lt;CheckHealth&gt; for Worker {\n    async fn handle(&amp;mut self, _msg: CheckHealth, _ctx: &amp;mut ActorContext&lt;Self&gt;) -&gt; HealthStatus {\n        if self.is_healthy() {\n            HealthStatus::Healthy\n        } else {\n            HealthStatus::Unhealthy {\n                reason: \"Connection lost\".to_string(),\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"components/rt/reference/api/supervisors/#restart-latency","title":"Restart Latency","text":"Strategy Min Avg Max Notes OneForOne 8\u00b5s 10-50\u00b5s 200\u00b5s Single actor restart OneForAll (4 children) 25\u00b5s 30-150\u00b5s 500\u00b5s Parallel restart RestForOne (3 affected) 18\u00b5s 20-100\u00b5s 350\u00b5s Sequential restart"},{"location":"components/rt/reference/api/supervisors/#restart-count-performance","title":"Restart Count Performance","text":"Restart Count Cold Start Warm Restart Delta 1<sup>st</sup> restart 50\u00b5s 10\u00b5s -80% 5<sup>th</sup> restart 50\u00b5s 8\u00b5s -84% 10<sup>th</sup> restart 50\u00b5s 7\u00b5s -86% <p>Warm restarts are faster due to: - Cached actor metadata - Pre-allocated mailboxes - Optimized supervision tree traversal</p>"},{"location":"components/rt/reference/api/supervisors/#memory-overhead","title":"Memory Overhead","text":"Component Size Per Child Notes Supervisor state ~512 bytes - Base overhead ChildSpec ~128 bytes Yes Per child spec Restart tracking ~64 bytes Yes Per active child Health check state ~96 bytes Yes If enabled"},{"location":"components/rt/reference/api/supervisors/#error-types","title":"Error Types","text":""},{"location":"components/rt/reference/api/supervisors/#enum-supervisorerror","title":"Enum: <code>SupervisorError</code>","text":"<pre><code>pub enum SupervisorError {\n    ChildStartFailed(String),\n    TooManyRestarts {\n        child_id: String,\n        count: u32,\n        window: Duration,\n    },\n    InvalidStrategy,\n}\n</code></pre> <p>Errors specific to supervisor operations.</p> <p>Variants:</p> <ul> <li><code>ChildStartFailed(String)</code>: Child actor failed to start</li> <li><code>TooManyRestarts</code>: Restart limit exceeded</li> <li><code>InvalidStrategy</code>: Unsupported restart strategy configuration</li> </ul> <p>Example:</p> <pre><code>use airssys_rt::supervisor::SupervisorError;\n\nmatch supervisor_result {\n    Err(SupervisorError::TooManyRestarts { child_id, count, window }) =&gt; {\n        eprintln!(\"Child {} restarted {} times in {:?}\", child_id, count, window);\n        // Take corrective action\n    }\n    _ =&gt; {}\n}\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#testing-utilities","title":"Testing Utilities","text":""},{"location":"components/rt/reference/api/supervisors/#struct-supervisortestprobe","title":"Struct: <code>SupervisorTestProbe</code>","text":"<pre><code>pub struct SupervisorTestProbe {\n    // fields omitted\n}\n</code></pre> <p>Testing utility for supervisor behavior.</p> <p>Available in: Test builds only (<code>#[cfg(test)]</code>)</p>"},{"location":"components/rt/reference/api/supervisors/#methods_1","title":"Methods","text":""},{"location":"components/rt/reference/api/supervisors/#expect_restart","title":"<code>expect_restart()</code>","text":"<pre><code>pub async fn expect_restart(&amp;mut self, child_id: &amp;str, timeout: Duration) -&gt; bool\n</code></pre> <p>Waits for a child restart event.</p> <p>Example:</p> <pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use airssys_rt::supervisor::SupervisorTestProbe;\n\n    #[tokio::test]\n    async fn test_supervisor_restarts_failed_child() {\n        let mut probe = SupervisorTestProbe::new();\n        // ... trigger child failure ...\n        assert!(probe.expect_restart(\"worker-1\", Duration::from_secs(1)).await);\n    }\n}\n</code></pre>"},{"location":"components/rt/reference/api/supervisors/#restart_count","title":"<code>restart_count()</code>","text":"<pre><code>pub fn restart_count(&amp;self, child_id: &amp;str) -&gt; u32\n</code></pre> <p>Returns the number of times a child has been restarted.</p>"},{"location":"components/rt/reference/api/supervisors/#see-also","title":"See Also","text":"<ul> <li>Core API Reference - Core types and system API</li> <li>Actors API Reference - Actor types and lifecycle</li> <li>Monitoring API Reference - Health monitoring system</li> <li>Architecture: Supervision - Design overview</li> <li>How-To: Supervisor Patterns - Usage patterns</li> <li>Explanation: Supervision - Design rationale</li> </ul>"},{"location":"components/rt/reference/architecture/components/","title":"Components","text":""},{"location":"components/rt/reference/architecture/message-passing/","title":"Message Passing","text":""},{"location":"components/rt/reference/architecture/process-lifecycle/","title":"Process Lifecycle","text":""},{"location":"components/rt/reference/architecture/supervision/","title":"Supervision","text":""},{"location":"components/rt/reference/architecture/system-overview/","title":"System Overview","text":""},{"location":"components/rt/researches/beam-inspired-runtime/","title":"Architecting a BEAM-Inspired Runtime in Rust: A Foundational Analysis and Practical Implementation Guide","text":""},{"location":"components/rt/researches/beam-inspired-runtime/#i-introduction-the-architectural-blueprint-for-a-beam-like-runtime-in-rust","title":"I. Introduction: The Architectural Blueprint for a BEAM-like Runtime in Rust","text":"<p>This report presents a comprehensive architectural analysis and practical implementation guide for the development of a high-concurrency, fault-tolerant runtime in Rust, modeled on the principles of the Erlang Run-Time System (ERTS) and its virtual machine, the BEAM. The endeavor to create such a system is ambitious, seeking to merge the battle-tested concurrency and resilience philosophy of Erlang with the performance, memory safety, and systems-level control offered by Rust. This document serves as a foundational knowledge base, dissecting the target architecture of the BEAM, surveying the analogous landscape within the Rust ecosystem, and synthesizing these findings into a concrete roadmap for implementation.</p> <p>The Erlang ecosystem, born from the demanding world of telecommunications, is built upon a distinct philosophy centered on reliability and massive concurrency. Its core tenets include the actor model for concurrent computation, a \"let it crash\" approach to fault tolerance where failures are isolated and handled by external supervisors, and high-availability features such as hot code loading that permit system updates without downtime. This philosophy is embodied in the BEAM virtual machine, a sophisticated piece of engineering that manages millions of lightweight, isolated processes with a preemptive scheduler to ensure fairness and responsiveness.</p> <p>In contrast, the Rust paradigm emphasizes a different form of resilience, rooted in compile-time guarantees. Its powerful type system, ownership model, and borrow checker eliminate entire classes of memory-related bugs, providing a robust foundation for building reliable software.5 Rust's philosophy of zero-cost abstractions ensures that these safety guarantees do not come at the expense of performance, making it an ideal language for systems programming. However, Rust lacks a built-in, managed runtime of the BEAM's complexity; its approach to application-level fault tolerance relies on library-based patterns rather than inherent properties of the execution environment.</p> <p>The central thesis of this report is that while a direct, one-to-one replication of the BEAM in Rust presents significant architectural challenges, a functionally equivalent and idiomatically Rust-based runtime is not only achievable but also holds the potential for creating a uniquely powerful system. Such a system would leverage Rust's performance and safety while adopting the BEAM's proven strategies for managing large-scale, fault-tolerant applications. This report will first deconstruct the BEAM's architecture to establish a clear blueprint. It will then analyze the current state of the Rust concurrency landscape to identify existing patterns and tools. Finally, it will synthesize these two domains to provide a practical roadmap, highlighting the critical design trade-offs and architectural decisions required for this undertaking.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#ii-the-erlang-run-time-system-erts-a-foundational-analysis","title":"II. The Erlang Run-Time System (ERTS): A Foundational Analysis","text":"<p>To construct a BEAM-inspired runtime, one must first possess a deep and nuanced understanding of the original. The BEAM is not merely a collection of features but a holistic, synergistic system where each component is designed to reinforce the others in service of a singular goal: building massively concurrent, highly available, and fault-tolerant software. This section provides a foundational analysis of the ERTS and its core components.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#21-the-actor-model-and-the-let-it-crash-philosophy","title":"2.1 The Actor Model and the \"Let it Crash\" Philosophy","text":"<p>At the heart of Erlang's concurrency model lies the Actor Model of computation.8 An actor is the fundamental unit of computation, a self-contained entity that encapsulates both state and behavior. The principles of the model are simple but profound:</p> <ul> <li>Encapsulation: An actor maintains its own private, internal state that cannot be directly accessed or modified by any other actor.</li> <li>Asynchronous Message Passing: Actors communicate exclusively by sending and receiving immutable messages asynchronously. There is no shared memory, which eliminates the need for complex and error-prone synchronization mechanisms like locks, thereby preventing race conditions by design.</li> <li>Mailbox and Sequential Processing: Each actor has a \"mailbox\" that queues incoming messages. The actor processes these messages one at a time, in a sequential manner, ensuring that its internal state is always consistent.</li> </ul> <p>This model of complete isolation is the bedrock upon which Erlang's famous \"let it crash\" philosophy is built. Instead of engaging in defensive programming\u2014where code is filled with complex <code>try-catch</code> blocks and error-checking logic to handle every conceivable failure\u2014Erlang/OTP encourages developers to write the \"happy path\" code and allow processes to fail when an unexpected error occurs. A process crash is treated as a clean, isolated event. The responsibility for recovery is not placed on the failing process itself but is delegated to a separate, dedicated \"supervisor\" process. This supervisor's sole job is to monitor its child processes and restart them according to a predefined strategy when they fail. This architectural pattern simplifies application logic immensely, moving the concern of fault tolerance from the individual component level to the system's structural level.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#22-architectural-overview-of-the-beam-virtual-machine","title":"2.2 Architectural Overview of the BEAM Virtual Machine","text":"<p>The BEAM, which stands for Bogdan's (or Bj\u00f6rn's) Erlang Abstract Machine, is the high-performance, production-grade virtual machine at the core of the Erlang Run-Time System (ERTS). It was developed at Ericsson to meet the stringent uptime requirements of telecommunications infrastructure, a domain where systems are expected to run continuously for years.</p> <p>When an Erlang or Elixir system is started, it runs as a single operating system process. Within this OS process, the BEAM VM executes, managing its own ecosystem of lightweight Erlang processes.13 It is not uncommon for a single BEAM instance to manage hundreds of thousands, or even millions, of these concurrent processes. The BEAM is responsible for compiling Erlang source code into its own bytecode format, which is stored in  <code>.beam</code> files, and then executing this bytecode.</p> <p>A key aspect of the BEAM is its polyglot nature. While created for Erlang, it serves as a robust and powerful runtime for a variety of other languages, most notably Elixir, which leverages the full power of the BEAM and OTP while offering a different syntax and feature set.1 Other languages like Gleam, LFE (Lisp Flavoured Erlang), and Clojerl also target the BEAM, demonstrating its flexibility as a compilation target.12</p> <p>The primary responsibilities of the BEAM can be summarized as managing the system's scalability, distribution, and responsiveness by:</p> <ul> <li>Creating, scheduling, and managing concurrency via lightweight processes.</li> <li>Providing the mechanisms for error detection and fault-tolerant handling.</li> <li>Efficiently utilizing all available machine resources, particularly on multi-core CPUs.</li> </ul> <p>For those seeking the most exhaustive technical details, \"The BEAM Book\" by Erik Stenman is the definitive resource, providing a ground-up explanation of the VM's internals.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#23-core-component-deep-dive-lightweight-processes-and-state-isolation","title":"2.3 Core Component Deep Dive: Lightweight Processes and State Isolation","text":"<p>The term \"process\" in Erlang is fundamentally different from an operating system process or thread. Erlang processes are extremely lightweight units of execution managed entirely by the BEAM VM, not the underlying OS. This internal management is what makes their creation, destruction, and context-switching operations orders of magnitude faster and less resource-intensive than their OS counterparts.</p> <p>The \"lightweight\" nature is quantifiable. A newly spawned process has a very small initial memory footprint, with a default heap size of just 233 words (a \"word\" being the native pointer size of the machine, e.g., 8 bytes on a 64-bit system). This conservative default is a deliberate design choice to enable massive scalability, allowing a single BEAM node to host millions of concurrent processes without exhausting system memory.</p> <p>Communication between these processes is the key to their isolation. When a message is sent from one process to another on the same BEAM node, its data is, by default, copied from the sender's heap to the receiver's heap. This strict copying ensures perfect memory isolation; a bug or crash in one process cannot corrupt the memory or state of another. This design choice is a cornerstone of the \"let it crash\" philosophy, as it guarantees that failures are contained. The primary exception to this rule is for large binaries (specifically, reference-counted binaries or \"refc binaries\"), which can be shared between processes on the same node via reference passing to avoid the performance overhead of copying large amounts of data.15 When messages are sent to a process on a different BEAM node, they are first encoded into the Erlang External Term Format and sent over a TCP/IP socket.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#24-core-component-deep-dive-the-preemptive-scheduler-and-reductions","title":"2.4 Core Component Deep Dive: The Preemptive Scheduler and \"Reductions\"","text":"<p>The BEAM's scheduler is a masterclass in designing for concurrency and responsiveness on modern multi-core hardware. The initial single-queue model evolved into a symmetric multiprocessing (SMP) architecture where, by default, one scheduler thread is created for each available CPU core.1 Each of these scheduler threads maintains its own run queue of ready-to-execute Erlang processes. This design avoids the contention and bottleneck issues of a single, global lock on a run queue, enabling true parallelism as multiple processes can execute simultaneously on different cores. The VM itself acts as an intelligent load balancer, capable of migrating processes between scheduler run queues to ensure that work is distributed evenly and no core sits idle while others are overloaded.</p> <p>A critical and defining feature of the BEAM scheduler is that it is preemptive. Unlike cooperative schedulers, which rely on tasks to voluntarily yield control, the BEAM scheduler can forcibly interrupt a running process to allow another process to have its turn on the CPU. This prevents a single, long-running, CPU-bound process from monopolizing a scheduler thread and starving all other processes in that queue, which is essential for maintaining system-wide responsiveness.</p> <p>This preemption is not governed by traditional time slices. Instead, the BEAM uses a concept called reductions. A reduction is an abstract unit of work, roughly equivalent to a function call or a basic operation. Each Erlang process is given a \"reduction budget\" (typically 2,000) when it is scheduled to run. The scheduler decrements this budget as the process executes its code. Once the reduction count reaches zero, the process is preempted, placed back into the run queue, and the scheduler moves on to the next process, even if the first process has not completed its task. This reduction-counting mechanism provides a more deterministic and fair way to share CPU resources than simple timers, ensuring that all processes make progress and contributing to the soft real-time capabilities of the system. Furthermore, the scheduler supports multiple priority levels (low, normal, high, and max), with separate run queues for each, ensuring that high-priority system tasks are given preference over lower-priority application tasks.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#25-core-component-deep-dive-per-process-memory-management-and-generational-garbage-collection","title":"2.5 Core Component Deep Dive: Per-Process Memory Management and Generational Garbage Collection","text":"<p>The BEAM's approach to memory management is a direct consequence of its process architecture and is fundamental to its fault-tolerance and low-latency characteristics. The single most important design decision is that every Erlang process has its own private heap and stack, allocated within a contiguous block of memory.4 This complete memory isolation is what makes the \"share nothing\" concurrency model a physical reality within the VM.</p> <p>This per-process heap architecture enables a highly efficient and concurrent garbage collection (GC) strategy. When the heap and stack of a single process grow to meet each other, a garbage collection cycle is triggered for that process and that process alone.19 All other processes in the system continue their execution completely uninterrupted.20 This avoids the \"stop-the-world\" problem common in many other garbage-collected runtimes, where the entire application must be paused for a GC cycle, leading to unpredictable latency spikes.</p> <p>The GC algorithm itself is a sophisticated per-process, generational, semi-space copying collector, based on Cheney's algorithm.19 Memory within a process's heap is divided into a \"young generation\" (or young heap) and an \"old generation\" (old heap). New objects are allocated in the young heap. The \"generational hypothesis\" posits that most objects die young. Therefore, the garbage collector runs most frequently on the smaller young heap, which is a very fast operation. Objects that survive multiple young-generation collections are promoted to the old heap.19 A \"full sweep\" collection that includes the old heap is a much less frequent event, triggered only when the old heap itself becomes full.19 This generational approach, combined with the per-process model, means that GC pauses in a well-behaved Erlang system are typically measured in microseconds and are imperceptible to the overall system's operation.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#26-the-power-of-otp-supervision-hierarchies-distribution-and-hot-code-loading","title":"2.6 The Power of OTP: Supervision Hierarchies, Distribution, and Hot Code Loading","text":"<p>While the BEAM provides the raw capabilities for concurrency and fault isolation, it is the Open Telecom Platform (OTP) framework that provides the architectural patterns and libraries for building robust applications with these primitives.1 OTP is not an optional library; it is an integral part of the Erlang ecosystem.</p> <p>The most fundamental OTP pattern is the supervision tree. Applications are structured as a hierarchy of processes. \"Worker\" processes perform the actual application logic, while \"supervisor\" processes have the sole responsibility of monitoring their children. If a worker process crashes, its supervisor is notified and, based on a pre-configured strategy, can restart the failed worker.3 Common strategies include:</p> <ul> <li>One-for-one: If a child process terminates, only that process is restarted.</li> <li>One-for-all: If a child process terminates, all other child processes managed by the same supervisor are terminated and then all are restarted.</li> <li>Rest-for-one: If a child process terminates, the rest of the child processes (those started after the failing one) are terminated and then the failing process and the ones after it are restarted.</li> </ul> <p>This hierarchical structure allows for the creation of self-healing systems where failures are contained and automatically rectified at the lowest possible level of the application.</p> <p>OTP also provides powerful, built-in support for distribution. The mechanisms for sending messages between processes are location-transparent. The same <code>send</code> primitive is used whether the destination process is on the same BEAM node or on a different machine across a network.3 The runtime handles the underlying serialization and network communication, allowing developers to build complex distributed systems with relative ease.</p> <p>Finally, one of the BEAM's most celebrated features, enabled by the OTP framework, is hot code loading. This is the ability to load a new version of a code module into a running, live production system without stopping or restarting it.13 When a module is updated, existing processes can continue to run the old code, while new calls to that module will execute the new version. OTP provides specific patterns (code change callbacks) for processes to gracefully migrate their internal state to be compatible with the new code version. This feature is paramount for systems that demand continuous availability and cannot tolerate downtime for software updates.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#iii-the-rust-concurrency-landscape-a-survey-of-erlang-inspired-frameworks-and-runtimes","title":"III. The Rust Concurrency Landscape: A Survey of Erlang-Inspired Frameworks and Runtimes","text":"<p>While Rust does not have a built-in runtime comparable to the BEAM, its powerful concurrency primitives and focus on safety have fostered a vibrant ecosystem of libraries and frameworks that aim to solve similar problems. Many of these are explicitly inspired by Erlang and the actor model. An analysis of these existing solutions provides invaluable insight into established patterns, common challenges, and idiomatic Rust approaches to concurrency and fault tolerance.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#31-the-foundation-tokio-and-the-cooperative-asyncawait-paradigm","title":"3.1 The Foundation: Tokio and the Cooperative <code>async</code>/<code>await</code> Paradigm","text":"<p>At the foundation of modern asynchronous programming in Rust is Tokio. It is the de facto standard asynchronous runtime, providing the essential building blocks for writing networking applications and other concurrent systems.5 Tokio offers a multi-threaded, work-stealing scheduler, an asynchronous version of the standard library's I/O and timer APIs, and a vast ecosystem of compatible libraries.5</p> <p>The most critical architectural aspect of Tokio is its cooperative scheduling model.5 Rust's </p> <p><code>async</code>/<code>await</code> syntax allows functions to be defined as asynchronous tasks (futures). When a task is run on the Tokio executor, it executes on a worker thread until it reaches an <code>.await</code> point on an operation that cannot complete immediately (e.g., waiting for data from a network socket). At this point, the task voluntarily yields control back to the scheduler, which can then run another ready task on the same thread. This model is extremely efficient for I/O-bound workloads, as it minimizes the time a thread spends idly waiting. However, it is fundamentally different from the BEAM's preemptive model. A CPU-bound task in Tokio that does not contain any <code>.await</code> points will monopolize its worker thread until it completes, potentially starving other tasks scheduled on the same thread.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#32-mature-actor-implementation-a-case-study-of-actix","title":"3.2 Mature Actor Implementation: A Case Study of Actix","text":"<p>Actix is one of the most mature and performant actor frameworks in the Rust ecosystem.25 It provides a powerful, pragmatic framework for building concurrent applications based on the actor model, and is built on top of the Tokio runtime.28</p> <p>In Actix, any Rust struct can become an actor by implementing the <code>Actor</code> trait. Actors encapsulate state and behavior, and communicate exclusively through statically typed messages.28 State is managed within the actor's struct and is mutated via a </p> <p><code>&amp;mut self</code> reference in its message handlers. Rust's ownership rules, combined with the framework's API which provides access to actors only through an <code>Addr</code> (address) object, ensure logical state isolation.29 There is no concept of per-actor heaps; all actors share the main OS process heap.</p> <p>For fault tolerance, Actix provides supervision capabilities through a <code>Supervisor</code> struct and a <code>Supervised</code> trait. An actor that implements <code>Supervised</code> can be managed by a supervisor, which will restart it if it fails.28 This provides a mechanism for recovery, but it is a feature that developers must explicitly opt into, rather than being the default architectural pattern as it is in OTP.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#33-fault-tolerance-first-an-analysis-of-bastion-and-its-lightproc-model","title":"3.3 Fault-Tolerance First: An Analysis of Bastion and its \"Lightproc\" Model","text":"<p>Bastion is a framework that explicitly aims to bring the \"smell of Erlang\" to Rust, with a primary focus on high availability and fault tolerance.32 It describes itself as a \"highly-available, fault-tolerant runtime system with dynamic dispatch oriented lightweight process model\".32</p> <p>Its core concurrency primitive is the \"lightproc\" (lightweight process), which is an abstraction built on top of Rust futures designed to emulate the behavior of Erlang processes.32 A key differentiator for Bastion is that it makes supervision a central, first-class concept. It comes with a default root supervisor and provides built-in supervision strategies such as </p> <p><code>OneForOne</code> and <code>AllForOne</code>, closely mirroring the structure and terminology of OTP.34 This design choice encourages developers to structure their applications around fault-tolerance from the outset.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#34-hierarchical-resilience-rikers-akka-inspired-approach-to-supervision","title":"3.4 Hierarchical Resilience: Riker's Akka-Inspired Approach to Supervision","text":"<p>Riker is another full-featured actor framework for Rust, drawing heavy inspiration from the Akka framework (which itself is a JVM implementation of the actor model inspired by Erlang).35 Like Bastion, Riker emphasizes the actor hierarchy as the fundamental structure for building resilient, self-healing systems.27</p> <p>Riker provides a complete actor runtime, actor supervision mechanisms, message scheduling, and publish/subscribe channels for event-driven architectures.27 The framework's roadmap explicitly includes plans for clustering, remote actors, and location transparency, indicating a clear ambition to provide a feature set comparable to that of Akka and OTP, allowing for the construction of distributed, fault-tolerant systems.27</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#35-the-next-frontier-lunatic-and-webassembly-based-process-isolation","title":"3.5 The Next Frontier: Lunatic and WebAssembly-based Process Isolation","text":"<p>Lunatic presents a novel and compelling architecture for an Erlang-inspired runtime. Instead of compiling Rust code directly to a native binary, Lunatic applications are compiled to WebAssembly (Wasm) and executed within the Lunatic Wasm runtime.39</p> <p>This architectural choice provides two profound benefits that align closely with the BEAM's design. First, it achieves hard memory isolation. Each Lunatic process is a distinct Wasm instance, and the Wasm specification mandates that each instance has its own sandboxed linear memory space, including its own stack and heap.39 This is the closest architectural analogue in the Rust ecosystem to the BEAM's per-process heaps, providing a strong, runtime-enforced guarantee against memory corruption between processes.</p> <p>Second, Lunatic implements a preemptive scheduler. Because the runtime has full control over the execution of the Wasm bytecode, it can instrument the code or use other mechanisms to interrupt a running Wasm instance, even one stuck in an infinite loop, and schedule another process to run.39 This allows Lunatic to offer the same kind of fairness and responsiveness guarantees as the BEAM, a feature that is notably absent in Tokio-based frameworks. Lunatic also supports supervision, distribution, and even hot code reloading (by loading new Wasm modules at runtime), making it a very significant project in the space of BEAM-like runtimes.39</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#36-direct-implementation-lessons-from-the-enigma-vm-project","title":"3.6 Direct Implementation: Lessons from the Enigma VM Project","text":"<p>The Enigma VM project is a direct attempt to implement the Erlang VM in Rust, with the goal of achieving OTP 22+ compatibility.44 While still experimental, it serves as an invaluable case study for understanding the practical challenges of such an undertaking.</p> <p>Architecturally, Enigma represents Erlang processes as long-running Rust futures and schedules them on a <code>tokio-threadpool</code> work-stealing queue.44 This design choice immediately highlights the central conflict between the BEAM's preemptive model and the cooperative nature of the underlying Tokio runtime. The project's source code is a rich resource for learning about the implementation details of BEAM opcodes, built-in functions (BIFs), the external term format, and other low-level runtime features in the context of Rust. It demonstrates the sheer complexity of the task while also providing a tangible example of how one might begin to structure such a system.</p> <p>The following table provides a high-level comparison of the surveyed Rust frameworks and runtimes across key architectural dimensions. This matrix is designed to distill the core design choices of each system, offering an at-a-glance overview of the existing landscape.</p> <p>Table 1: Comparative Feature Matrix of Rust Actor Frameworks and Runtimes</p> Feature Actix Bastion Riker Elfo Lunatic Underlying Runtime Tokio Tokio (via Agnostik abstraction) <code>futures::execution::ThreadPool</code> Tokio Custom (Wasmtime-based) Process Isolation Model Logical (Rust Ownership) Logical (Rust Ownership via <code>lightproc</code>) Logical (Rust Ownership) Logical (Rust Ownership) Hard (Per-process Wasm Instance/Heap) Scheduling Model Cooperative (<code>async</code>/<code>await</code>) Cooperative (<code>async</code>/<code>await</code>) Cooperative (<code>async</code>/<code>await</code>) Cooperative (<code>async</code>/<code>await</code>) Preemptive Supervision Model Opt-in (<code>Supervisor</code> struct) Core Feature (OTP-like strategies) Core Feature (Hierarchy-based) Core Feature (Supervisor support) Core Feature (OTP-inspired supervision) Built-in Distribution No (Requires external crates) Yes (Cluster formation) Planned (Roadmap feature) Yes (Distributed framework) Yes (Distributed nodes via QUIC) <p>This comparative analysis reveals several critical patterns and trends within the Rust ecosystem. The majority of actor frameworks are built upon the solid foundation of Tokio, and as a result, they inherit its cooperative scheduling model. This represents the most significant architectural divergence from the BEAM. A developer using these frameworks must be mindful that a long-running, non-yielding task can block a scheduler thread, a problem that does not exist in Erlang.</p> <p>Furthermore, there is a clear spectrum of approaches to process isolation. Most frameworks rely on Rust's powerful type system and ownership model to provide logical isolation at the API level. This is idiomatic and performant but does not provide the same hard, runtime-enforced memory boundary as the BEAM's per-process heaps. Lunatic stands apart by using WebAssembly sandboxing to achieve this hard memory isolation, offering a model that is philosophically much closer to the BEAM's but at the cost of introducing a Wasm runtime layer.</p> <p>Finally, while supervision is a feature in many Rust frameworks, its integration level varies. In frameworks like Bastion and Riker, it is presented as a central architectural pattern, echoing its importance in OTP. In others, it may be a more optional, library-level feature. This reflects a broader philosophical difference: Erlang/OTP is a runtime environment where supervision is a fundamental primitive, whereas in Rust, it is often a design pattern implemented on top of more general concurrency tools.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#iv-synthesis-and-comparative-analysis-bridging-erlangs-philosophy-with-rusts-guarantees","title":"IV. Synthesis and Comparative Analysis: Bridging Erlang's Philosophy with Rust's Guarantees","text":"<p>Building a BEAM-inspired runtime in Rust is not a simple matter of translation; it is an exercise in bridging two distinct programming philosophies. Erlang's design prioritizes runtime resilience, dynamic behavior, and system-level fault tolerance. Rust prioritizes compile-time safety, performance, and explicit control over memory. A successful implementation must navigate the fundamental conflicts between these two paradigms and make deliberate architectural trade-offs.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#41-process-and-state-isolation-beams-heaps-vs-rusts-ownership-model","title":"4.1 Process and State Isolation: BEAM's Heaps vs. Rust's Ownership Model","text":"<p>The BEAM achieves its gold standard of process isolation through a straightforward, if brute-force, mechanism: giving every process its own heap.19 This provides a hard, runtime-enforced memory boundary. A bug in one process, even one that causes a segmentation fault in native code, is contained within that process's memory space and cannot corrupt the state of any other process. This physical separation simplifies garbage collection and is the ultimate enabler of the \"let it crash\" philosophy.</p> <p>Rust, on the other hand, achieves memory safety and prevents data races through its ownership model and borrow checker at compile time.45 In a typical Rust actor framework, an actor's state is encapsulated within its struct. The framework's API, combined with the borrow checker, prevents any other part of the system from obtaining a mutable reference to that state concurrently. This provides strong </p> <p>logical isolation. However, it is not the same as the BEAM's physical isolation. All actors still share the same process-wide heap. A bug in <code>unsafe</code> code or a flaw in a C library dependency could, in theory, corrupt memory that affects other actors.</p> <p>This presents a critical architectural decision. Relying on Rust's ownership model is the most idiomatic and likely the most performant approach, leveraging the language's core strengths. However, to achieve the same level of absolute, untrusted-code-safe isolation as the BEAM, a model like Lunatic's, which uses an external sandboxing mechanism like WebAssembly, is necessary.40 This choice trades some native performance and simplicity for a much stronger fault-isolation guarantee.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#42-scheduling-models-preemptive-fairness-vs-cooperative-throughput","title":"4.2 Scheduling Models: Preemptive Fairness vs. Cooperative Throughput","text":"<p>This is arguably the most significant architectural conflict. The BEAM's preemptive scheduler, based on reductions, is the heart of its ability to provide soft real-time guarantees and fairness.4 It ensures that no single process can dominate a CPU core, which is essential for keeping a system with millions of processes responsive.</p> <p>The dominant paradigm in the Rust async ecosystem, provided by Tokio, is cooperative scheduling.23 This model is optimized for high throughput in I/O-bound applications, where tasks frequently yield control at </p> <p><code>.await</code> points. It is simpler and has lower overhead than a preemptive scheduler. However, it is vulnerable to \"bad actor\" processes\u2014CPU-bound tasks that compute for long periods without yielding. Such a task will starve all other tasks on its worker thread, leading to unpredictable latency and a loss of the fairness guarantees that are central to the Erlang model.</p> <p>Therefore, a true BEAM-like runtime cannot be built directly on a standard Tokio executor without modification. The implementation must choose one of three paths:</p> <ol> <li>Accept the cooperative model: This is the simplest path but represents a major compromise on the BEAM's core principles of fairness and responsiveness.</li> <li>Build a custom preemptive scheduler: This is a highly complex undertaking, requiring mechanisms to interrupt running Rust code. This could potentially be achieved by running tasks in separate OS threads (which would sacrifice the \"lightweight\" nature of processes) or by instrumenting the compiled code to insert yield points, similar to how reduction counting works.</li> <li>Use a sandboxed runtime: This is the approach taken by Lunatic.39 By compiling code to Wasm, the host runtime can pause and resume the Wasm instance at will, effectively implementing preemption without needing to modify the Rust compiler or rely on OS threads for every process.</li> </ol>"},{"location":"components/rt/researches/beam-inspired-runtime/#43-message-passing-semantics-data-copying-vs-ownership-transfer","title":"4.3 Message Passing Semantics: Data Copying vs. Ownership Transfer","text":"<p>In the BEAM, messages are generally copied from the sender's heap to the receiver's.16 This reinforces the \"share nothing\" principle, ensuring complete decoupling between processes. The performance cost of this copying is considered an acceptable price for the resulting simplicity and robustness.</p> <p>In Rust, the most idiomatic and performant way to pass data is to transfer ownership via a <code>move</code>. This is a zero-copy operation, as only the pointer and ownership metadata on the stack are moved.47 This is highly efficient but creates a stronger link between components than the Erlang model. While Rust's channels and actor mailboxes handle the ownership transfer, it is a different semantic model from Erlang's copy-on-send.</p> <p>A Rust implementation must make a conscious choice. It could enforce a <code>Clone</code> bound on all messages, simulating the BEAM's copy-on-send behavior. This would be semantically faithful but would opt out of one of Rust's major performance advantages. Alternatively, it could embrace ownership transfer for its performance benefits, accepting that this represents a deviation from the pure \"share nothing\" model and may require more careful consideration of data lifetimes.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#44-fault-tolerance-replicating-otp-supervision-trees-in-rust","title":"4.4 Fault Tolerance: Replicating OTP Supervision Trees in Rust","text":"<p>In OTP, supervision is a set of runtime primitives. Processes can be \"linked,\" meaning a crash in one will propagate a kill signal to the other. Supervisors use \"monitors\" to receive notifications when a child process dies.3 These are low-level mechanisms upon which the supervision tree pattern is built.</p> <p>In Rust, frameworks like Bastion and Riker implement supervision as a library pattern on top of the async runtime.27 A supervisor actor spawns child actors as async tasks and holds onto their </p> <p><code>JoinHandle</code>. It can then poll these handles or use channels to be notified when a task panics or exits with an error. This works, but it is an abstraction layer built by the framework.</p> <p>A true BEAM-like runtime in Rust would need to integrate these concepts more deeply. The runtime's internal process registry would need to track the links and monitor relationships between processes. The scheduler would need to understand this hierarchy to correctly propagate exit signals and execute the restart strategies defined by the supervisor. This requires making supervision a first-class citizen of the runtime, not just an application-level pattern.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#45-the-hot-code-loading-challenge-in-a-statically-compiled-language","title":"4.5 The Hot Code Loading Challenge in a Statically Compiled Language","text":"<p>Hot code loading is perhaps the most difficult BEAM feature to replicate in a statically compiled language like Rust.13 The BEAM achieves this by having a module loader that can replace the code for a given module at runtime.</p> <p>The only viable mechanism for this in Rust is dynamic loading of shared libraries (<code>.so</code>, <code>.dll</code>, <code>.dylib</code>).48 However, this approach is fraught with challenges:</p> <ul> <li>Unstable ABI: Rust does not have a stable Application Binary Interface (ABI). This means that code compiled with one version of the Rust compiler may not be compatible with code compiled with another. To ensure compatibility between the main application and a dynamically loaded library, all exported functions must use the C ABI (<code>extern \"C\"</code>) and avoid complex Rust types in their signatures.50</li> <li>State Migration: This is the most significant hurdle. When a new version of a library is loaded, any existing state from the old version must be carefully migrated. This typically involves serializing the state to a stable format (like JSON or protobuf) before the old library is unloaded, and then deserializing it in the new library.52 This process is manual, complex, and a potential source of bugs.</li> <li>Safety: Interacting with dynamic libraries in Rust is inherently <code>unsafe</code>. The compiler cannot verify the correctness of the function signatures, and improper handling of library handles can lead to dangling pointers or memory leaks.49</li> </ul> <p>Replicating the seamlessness of BEAM's hot code loading is likely impossible. A practical Rust implementation would be much more constrained. A more promising, though still complex, avenue is the one offered by Wasm-based runtimes like Lunatic, which can load and instantiate new Wasm modules at runtime, potentially offering a safer and more manageable approach to dynamic code updates.55</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#v-a-practical-roadmap-for-implementation","title":"V. A Practical Roadmap for Implementation","text":"<p>Translating the preceding analysis into a concrete implementation requires a phased approach, beginning with foundational architectural decisions and progressively building towards the more advanced features of a BEAM-like system. This roadmap outlines a logical sequence of development, highlighting the critical choices at each stage.</p>"},{"location":"components/rt/researches/beam-inspired-runtime/#51-key-architectural-decisions-and-their-trade-offs","title":"5.1 Key Architectural Decisions and Their Trade-offs","text":"<p>Before writing the first line of code, four fundamental architectural decisions must be made. These choices are deeply interconnected and will define the core character and capabilities of the final runtime.</p> <ul> <li>Decision 1: Scheduling Model (Preemptive vs. Cooperative). This is the most critical choice.</li> <li>Cooperative (Tokio-based): Pros: Simpler to implement, leverages the mature Tokio ecosystem, high throughput for I/O-bound tasks. Cons: Sacrifices fairness and responsiveness guarantees, vulnerable to blocking by CPU-bound tasks, a significant deviation from the BEAM's core behavior.</li> <li>Preemptive (Custom or Wasm-based): Pros: Achieves BEAM-like fairness and soft real-time behavior, robust against misbehaving processes. Cons: Far more complex to implement, requires either building a custom executor from scratch or integrating and managing a Wasm runtime like Wasmtime. This is the recommended path for a runtime that is truly BEAM-inspired.</li> <li>Decision 2: Process Isolation Model (Logical vs. Hard).</li> <li>Logical (Rust Ownership): Pros: Idiomatic Rust, zero-cost abstraction, high performance. Cons: Provides logical, not physical, memory isolation. A bug in <code>unsafe</code> code can still compromise the entire system.</li> <li>Hard (Wasm/OS Process): Pros: Provides strong, BEAM-like memory isolation. Failures are completely contained. Cons: Introduces performance overhead and the complexity of managing a Wasm runtime or OS processes. The Wasm approach is the most promising for replicating BEAM's model of lightweight, isolated processes.</li> <li>Decision 3: Message Passing Semantics (Move vs. Clone).</li> <li>Move (Ownership Transfer): Pros: Zero-copy, highly performant, idiomatic Rust. Cons: Deviates from the BEAM's \"share nothing\" by copying, creates stronger coupling between components.</li> <li>Clone (Copy-on-Send): Pros: Semantically identical to the BEAM's default, ensures complete decoupling. Cons: Incurs performance overhead for cloning messages, less idiomatic for Rust performance patterns.</li> <li>Decision 4: Supervision Integration (Library vs. Primitive).</li> <li>Library Pattern: Pros: Simpler to implement initially, decouples application logic from runtime internals. Cons: Less powerful, the runtime is not \"aware\" of the supervision hierarchy, limiting potential optimizations and deep integration.</li> <li>Runtime Primitive: Pros: A true replication of the OTP model, enables the scheduler to be aware of process links and monitors, allows for a more robust and integrated fault-tolerance system. Cons: More complex, requires tight coupling between the process management, scheduling, and supervision components.</li> </ul>"},{"location":"components/rt/researches/beam-inspired-runtime/#5-implementation-phases","title":"5. Implementation Phases","text":""},{"location":"components/rt/researches/beam-inspired-runtime/#51-core-runtime-executor-and-scheduler","title":"5.1 Core Runtime, Executor, and Scheduler","text":"<p>The first phase focuses on establishing the absolute core of the runtime: the ability to schedule and execute tasks.</p> <ol> <li>Define the <code>Runtime</code> Struct: This will be the main entry point and container for the system, holding the scheduler, process registry, and other global state.</li> <li>Implement the Scheduler: Based on Decision 1, implement the chosen scheduler.</li> <li>If preemptive, this involves integrating a Wasm runtime like <code>wasmtime</code> and building the logic to instantiate, run, and pause Wasm modules. The scheduler will manage a pool of OS threads and a run queue of ready-to-run Wasm instances.</li> <li>If cooperative, this involves creating a wrapper around a <code>tokio::runtime::Runtime</code> and its <code>Handle</code>.</li> <li>Implement Run Queues and Load Balancing: Each scheduler thread should have its own run queue. Implement the logic for tasks to be added to these queues and for the scheduler to pull from them. If building for multi-core, implement a work-stealing or process-migration strategy to balance load across schedulers.17</li> </ol>"},{"location":"components/rt/researches/beam-inspired-runtime/#52-lightweight-processes-and-message-passing-infrastructure","title":"5.2 Lightweight Processes and Message Passing Infrastructure","text":"<p>This phase introduces the core abstractions of the actor model: processes and messages.</p> <ol> <li>Define the Process Control Block (PCB): Create a Rust struct to represent an Erlang PCB.13 This will hold all metadata for a process, including its unique Process ID (PID), its current status (e.g., running, waiting, exiting), a pointer to its mailbox, its reduction count, and references to its parent/supervisor and linked processes.</li> <li>Implement Process Spawning: Create the <code>spawn</code> and <code>spawn_link</code> functions. These functions will allocate a new PCB, create the initial process state (including its Wasm instance or async task), and place it in a scheduler's run queue.</li> <li>Design the Mailbox: Implement the data structure for the process mailbox. A lock-free, multi-producer, single-consumer queue (e.g., from the <code>crossbeam-channel</code> crate) is a suitable choice. A decision must be made whether the mailboxes will be bounded (providing back-pressure) or unbounded.</li> <li>Implement Message Passing Primitives: Implement the <code>send</code> function. This will involve locating the target process's PCB via its PID, and enqueuing the message into its mailbox. The implementation must adhere to the copy/move semantics chosen in Decision 3.</li> </ol>"},{"location":"components/rt/researches/beam-inspired-runtime/#53-memory-management-and-garbage-collection-strategy","title":"5.3 Memory Management and Garbage Collection Strategy","text":"<p>This phase is only necessary if pursuing the hard isolation model with per-process heaps, as the logical isolation model would rely on Rust's global allocator.</p> <ol> <li>Implement a Heap Allocator: If using a Wasm runtime, this is largely handled by the Wasm instance's linear memory. If building a custom non-Wasm runtime with per-process heaps, this phase requires implementing a memory allocator that can create and manage distinct memory regions for each process.</li> <li>Implement a Garbage Collector: Start with a simple, correct GC algorithm. A Cheney's two-space copying collector is a classic and well-understood choice for functional languages.19</li> <li>Integrate GC with the Runtime: The GC needs to be triggered at appropriate times. This could be when a process's heap allocator fails to satisfy a request. The process would be suspended, the GC would run on its heap, and then the process would be rescheduled. The root set for the GC would be the process's stack and registers.19</li> </ol>"},{"location":"components/rt/researches/beam-inspired-runtime/#54-advanced-features-supervision-distribution-and-dynamic-code-reloading","title":"5.4 Advanced Features - Supervision, Distribution, and Dynamic Code Reloading","text":"<p>With the core runtime in place, the advanced features that define the Erlang/OTP experience can be built.</p> <ol> <li>Supervision: Implement the low-level primitives for linking and monitoring processes within the runtime's process registry. When a process crashes, the runtime should be able to identify its supervisor and send it a notification message. Then, implement the <code>Supervisor</code> behavior itself, with the logic for parsing restart strategies and managing child processes.</li> <li>Distribution: Design the internode protocol. This involves defining how Erlang terms will be serialized for the wire (e.g., using the External Term Format) and choosing a transport (e.g., QUIC, as used by Lunatic, or TCP).39 Implement a global process registry (or a distributed hash table) to map PIDs to node locations and a proxying mechanism to transparently forward messages to remote processes.</li> <li>Dynamic Code Reloading: This is the most challenging feature.</li> <li>Implement a module loader using a crate like <code>libloading</code>.56</li> <li>Define a stable C ABI for all functions that are intended to be reloadable. This interface must be minimal and use only C-compatible types.</li> <li>Develop a robust state-migration protocol. This requires defining a <code>code_change</code> callback that allows a process to receive its old state, transform it, and initialize its new state before the old code module is unloaded. This process is inherently <code>unsafe</code> and requires meticulous management of library handles and state serialization.52</li> </ol>"},{"location":"components/rt/researches/beam-inspired-runtime/#conclusion-the-path-to-a-production-ready-erlang-runtime-in-rust","title":"Conclusion: The Path to a Production-Ready Erlang Runtime in Rust","text":"<p>The endeavor to build an Erlang-inspired runtime in Rust is a significant systems engineering challenge that sits at the intersection of two powerful but philosophically distinct technologies. A direct, feature-for-feature clone of the BEAM is a monumental task, particularly with respect to its seamless hot code loading capabilities. However, a runtime that successfully captures the BEAM's core principles\u2014massive concurrency through lightweight processes, strong fault isolation, and resilient application architecture through supervision\u2014is a viable and immensely valuable project.</p> <p>The critical path to success lies in making informed architectural decisions at the outset, particularly regarding the choice between a cooperative and a preemptive scheduling model. While leveraging the existing Tokio ecosystem is tempting for its simplicity and maturity, a true BEAM-like system demands the fairness and responsiveness guarantees that only preemption can provide. The novel approach taken by the Lunatic project, using WebAssembly as a sandboxed, preemptible execution target, presents the most promising path forward for achieving BEAM's strongest guarantees in a Rust environment.</p> <p>By carefully navigating these trade-offs and following a phased implementation plan, it is possible to create a new class of runtime: one that combines the raw performance and compile-time memory safety of Rust with the architectural wisdom of Erlang for building scalable, resilient, and long-running systems. The result would not be merely a clone, but a powerful synthesis that stands on its own merits, inspired by one of the most robust runtimes ever created, and built with one of the most powerful systems languages of the modern era.</p>"},{"location":"components/rt/researches/beam-model/","title":"The BEAM Model: A Blueprint for Concurrent and Resilient Systems","text":"<p>The Erlang/OTP runtime, known as the BEAM (Bogdan's Erlang Abstract Machine), represents more than a virtual machine; it is a holistic architectural philosophy for building systems designed for continuous operation and massive concurrency. Originally developed by Ericsson to implement highly available telecom infrastructure, its principles offer a powerful model for any system where reliability and scalability are paramount.1</p>"},{"location":"components/rt/researches/beam-model/#11-fundamental-architecture-of-the-beam-virtual-machine","title":"1.1 Fundamental Architecture of the BEAM Virtual Machine","text":"<p>The BEAM's architecture is purpose-built to support its core design goals of concurrency, distribution, and fault tolerance. Its two most critical components are its process model and its scheduler.</p>"},{"location":"components/rt/researches/beam-model/#lightweight-processes-memory-isolation","title":"Lightweight Processes &amp; Memory Isolation","text":"<p>The fundamental unit of concurrency in BEAM is the lightweight process, an abstraction that is managed entirely by the VM and is significantly more efficient than an operating system thread.1 A single BEAM instance can run millions of these processes simultaneously with minimal overhead.2</p> <p>The most crucial architectural feature of these processes is their complete memory isolation. Each BEAM process is an independent entity with its own private heap and stack.2 There is no shared memory between processes.1 This isolation is the bedrock of BEAM's fault tolerance; a crash or error within one process, such as an unhandled exception or a memory corruption bug, cannot affect the state or stability of any other process in the system.2</p> <p>This design has a profound impact on resource management, particularly garbage collection (GC). Unlike runtimes like the JVM that often employ a global, \"stop-the-world\" GC which pauses the entire application, BEAM performs garbage collection on a per-process basis.1 Since processes are isolated and typically short-lived or handle small amounts of data, GC pauses are localized, extremely short, and do not impact the overall system's responsiveness. This is a key contributor to BEAM's ability to maintain low and predictable latency, a critical requirement for soft real-time systems.1</p>"},{"location":"components/rt/researches/beam-model/#preemptive-scheduler","title":"Preemptive Scheduler","text":"<p>To manage its millions of processes, BEAM employs a sophisticated, preemptive scheduler. The runtime starts one scheduler thread for each available CPU core, allowing for true parallelism.3 Each Erlang process is allocated a fixed budget of \"reductions\"\u2014a unit of work roughly equivalent to a function call\u2014before the scheduler preemptively suspends its execution and switches to another process in the queue.1</p> <p>This preemption guarantees fairness and prevents any single process, whether CPU-bound or misbehaving, from monopolizing a scheduler and starving other processes. This is a key differentiator from the cooperative scheduling models common in many asynchronous runtimes, where a task must explicitly yield control (e.g., at an <code>await</code> point).6 BEAM's preemptive nature provides the soft real-time guarantees necessary for applications like telecom switches and game servers, which must respond to events within a predictable timeframe.1 To further optimize resource utilization, the schedulers employ a work-stealing mechanism, where an idle scheduler can \"steal\" processes from the run queue of a busy scheduler, ensuring an even distribution of load across all available cores.3</p>"},{"location":"components/rt/researches/beam-model/#12-the-actor-model-and-let-it-crash-philosophy","title":"1.2 The Actor Model and \"Let It Crash\" Philosophy","text":"<p>Built upon the foundation of isolated processes and preemptive scheduling, Erlang/OTP implements a powerful concurrency and fault-tolerance model.</p>"},{"location":"components/rt/researches/beam-model/#message-passing-concurrency","title":"Message-Passing Concurrency","text":"<p>BEAM processes adhere to the Actor model of concurrency. They are computational entities (\"actors\") that encapsulate state and communicate exclusively by sending and receiving asynchronous messages.2 Since there is no shared memory, this model entirely eliminates the need for complex and error-prone synchronization primitives like locks, mutexes, or semaphores, which are a primary source of bugs such as data races and deadlocks in traditional shared-state concurrency models.1 Data is transferred between processes by copying messages, which is an efficient operation within the VM and is made safe by Erlang's use of immutable data structures.1</p>"},{"location":"components/rt/researches/beam-model/#supervision-trees-and-fault-tolerance","title":"Supervision Trees and Fault Tolerance","text":"<p>The most distinctive aspect of the Erlang/OTP philosophy is its approach to handling errors, encapsulated by the mantra \"Let It Crash\".2 This philosophy posits that attempting to defensively program against every conceivable error is complex, error-prone, and often leads to code that masks the underlying problem. Instead, it is more robust to write \"corrective\" code that allows a faulty process to fail quickly and cleanly, and then have a separate, dedicated process\u2014a supervisor\u2014take action to recover the system to a known-good state.8</p> <p>The Open Telecom Platform (OTP) framework provides the components to build these self-healing systems. The core pattern is the supervision tree, a hierarchical structure where supervisor processes monitor a set of child processes (which can be workers or other supervisors).2 When a child process terminates abnormally (i.e., \"crashes\"), the supervisor is notified and applies a pre-configured restart strategy.10 These strategies can be fine-grained: </p> <p><code>one_for_one</code> restarts only the failing process, <code>one_for_all</code> restarts all sibling processes if one fails (for tightly coupled components), and <code>rest_for_one</code> restarts the failing process and any siblings that were started after it.11 This combination of process isolation and automated supervision allows for the creation of highly resilient systems that can automatically recover from transient software and hardware faults without manual intervention.2</p>"},{"location":"components/rt/researches/beam-model/#13-distribution-and-live-upgrades","title":"1.3 Distribution and Live Upgrades","text":"<p>BEAM's architecture was designed not just for a single machine but for networks of machines, with features for distribution and continuous operation built into the runtime itself.</p>"},{"location":"components/rt/researches/beam-model/#built-in-distribution","title":"Built-in Distribution","text":"<p>BEAM has native, transparent support for distributed computing. Multiple BEAM instances, or \"nodes,\" can be connected to form a cluster.1 Processes on one node can discover, send messages to, and spawn processes on another node using the exact same syntax as for local processes.2 The runtime handles the underlying network communication, making the location of a process transparent to the developer. This is a foundational feature, not a library add-on, and it enables the seamless horizontal scaling of applications across multiple servers.1</p>"},{"location":"components/rt/researches/beam-model/#hot-code-swapping","title":"Hot Code Swapping","text":"<p>Perhaps the most celebrated feature of BEAM is its ability to perform hot code swapping, allowing a developer to upgrade the code of a module in a running, live production system without stopping it.1 When a new version of a module is loaded, the VM atomically updates the code pointers. New calls to that module will execute the new version of the code, while any processes currently executing code in the old version are allowed to complete their work undisturbed.4 This capability is critical for systems that require \"nine nines\" (</p> <p>99.9999999%) availability, such as telecommunication networks, and it also dramatically accelerates development cycles by allowing for rapid iteration without constant system restarts.1</p>"},{"location":"components/rt/researches/beam-model/#14-translating-beam-principles-to-the-rust-ecosystem","title":"1.4 Translating BEAM Principles to the Rust Ecosystem","text":"<p>The principles of the BEAM model offer a compelling vision for building resilient systems, but translating them to the Rust ecosystem reveals both significant opportunities and fundamental architectural differences.</p>"},{"location":"components/rt/researches/beam-model/#rusts-asyncawait-vs-beams-actors","title":"Rust's <code>async/await</code> vs. BEAM's Actors","text":"<p>Rust's primary model for concurrency is <code>async/await</code>, which is built to handle I/O-bound tasks with high efficiency. It is a cooperative, non-blocking model, where tasks run until they encounter an <code>.await</code> point, at which time they yield control back to the runtime's scheduler (e.g., Tokio).12 This contrasts sharply with BEAM's preemptive model, which is designed to handle both CPU-bound and I/O-bound work with guaranteed fairness.1 Fundamentally, </p> <p><code>async/await</code> is a lower-level language construct for managing asynchronous control flow, whereas the actor model is a higher-level architectural pattern for managing state, isolation, and communication.6</p>"},{"location":"components/rt/researches/beam-model/#the-rust-actor-framework-landscape","title":"The Rust Actor Framework Landscape","text":"<p>Recognizing the need for higher-level concurrency abstractions, the Rust ecosystem has produced a vibrant landscape of actor libraries, each attempting to provide BEAM-like features on top of Rust's native capabilities.15</p> <ul> <li>Actix: A mature and widely used framework that provides a robust actor system. It defines an <code>Actor</code> trait, typed messages, and actor lifecycle management.16 Crucially for fault tolerance, Actix includes a </li> </ul> <p><code>Supervisor</code> struct and a <code>Supervised</code> trait, which allow a failed actor to be automatically restarted by its supervisor, directly mirroring a core OTP concept.17</p> <ul> <li> <p>Riker: A framework explicitly designed with resilience in mind, offering supervision strategies as a core feature and aiming for a modular system architecture.19</p> </li> <li> <p>Ractor: A newer framework that aims for a closer emulation of Erlang/OTP patterns. It provides built-in support for supervision trees, process groups (named groups of actors), and a companion library, <code>ractor_cluster</code>, for building distributed systems.21 The separate </p> </li> </ul> <p><code>ractor-supervisor</code> crate offers explicit OTP-style supervision strategies like <code>OneForOne</code>, <code>OneForAll</code>, and <code>RestForOne</code>, giving architects fine-grained control over recovery logic.11</p>"},{"location":"components/rt/researches/beam-model/#the-supervision-gap-and-philosophical-tensions","title":"The Supervision Gap and Philosophical Tensions","text":"<p>Despite the progress of these libraries, a gap remains. In Erlang, supervision is not just a library feature; it is the default, \"thoughtless\" way to structure an application.21 In Rust, it is an opt-in pattern that requires conscious architectural effort. This points to a deeper, philosophical tension. Rust's core design ethos is to be \"fail-proof\" by using its powerful type system, ownership model, and explicit error handling (</p> <p><code>Result</code>, <code>Option</code>) to prevent entire classes of bugs at compile time.25 A panic is treated as an unrecoverable error that should, by default, terminate the program.26 Erlang's ethos, conversely, is to be \"fail-safe.\" It accepts that runtime failures are inevitable and focuses on building systems that can gracefully recover from them.8</p> <p>A direct translation of \"Let It Crash\" is therefore unnatural in idiomatic Rust. A panic within a standard Rust thread will tear down the entire process. To implement supervision, Rust actor frameworks must wrap the execution of actor code in a construct that catches the panic, preventing it from propagating and allowing the supervisor to take action.22 A truly \"Rusty\" approach to resilience would therefore be a hybrid: leveraging the type system to eliminate all preventable errors, while adopting an actor-based supervision model to manage the truly exceptional runtime failures that cannot be statically proven to be impossible (e.g., logic bugs, failures in external systems).</p> <p>This leads to a critical realization: the most significant difference between BEAM and Rust's actor ecosystem is that BEAM's features are deeply integrated into the VM itself, whereas Rust's actor frameworks are libraries layered on top of a general-purpose async runtime like Tokio.1 BEAM was designed from the ground up for concurrent, fault-tolerant systems.1 Rust's </p> <p><code>async</code> ecosystem was designed for high-performance, non-blocking I/O.12 Consequently, Rust actor libraries inherit the properties of the underlying runtime; they cannot implement true preemption but must rely on cooperative yielding at </p> <p><code>.await</code> points.6 Achieving BEAM-level guarantees in Rust would require more than just libraries; it would necessitate a specialized runtime or significant evolution of the existing async foundations to support concepts like preemption and deeper process isolation.</p> <p>Table 1: Feature Comparison of Erlang/OTP and Prominent Rust Actor Frameworks</p> Feature Erlang/BEAM/OTP Actix Ractor Concurrency Model Preemptive, lightweight processes managed by the VM. Cooperative tasks on an async runtime (e.g., Tokio). Cooperative tasks on an async runtime (e.g., Tokio). State Management Isolated process heaps; no shared memory. Actor struct state; relies on Rust's ownership/borrowing within the actor. Actor struct state with a separate <code>State</code> type; relies on Rust's ownership. Fault Isolation VM-level process isolation; crashes are contained. Task/thread-level isolation; panics must be caught by the framework. Task/thread-level isolation; panics are caught and reported as supervision events. Supervision Strategy Integrated OTP behaviors (<code>one_for_one</code>, <code>one_for_all</code>, etc.). <code>Supervisor</code> struct and <code>Supervised</code> trait for restarting actors. <code>ractor-supervisor</code> crate provides explicit OTP-style strategies. Distribution Model Built-in, transparent network communication between nodes. No built-in support; requires manual implementation. Companion library (<code>ractor_cluster</code>) for distributed scenarios; not production-ready. Live Code Upgrades Hot code swapping is a core feature of the VM. Not supported. Not supported."},{"location":"components/rt/researches/rust-actor-ecosystem/","title":"Rust Actor Ecosystem Analysis","text":"<p>This document provides a comprehensive analysis of the current Rust actor ecosystem, examining existing frameworks, their design decisions, and lessons learned that inform <code>airssys-rt</code>'s architecture.</p>"},{"location":"components/rt/researches/rust-actor-ecosystem/#current-landscape-overview","title":"Current Landscape Overview","text":"<p>The Rust ecosystem features several actor frameworks, each taking different approaches to implementing the actor model. This analysis examines their strengths, limitations, and architectural decisions.</p>"},{"location":"components/rt/researches/rust-actor-ecosystem/#major-actor-frameworks","title":"Major Actor Frameworks","text":""},{"location":"components/rt/researches/rust-actor-ecosystem/#1-actix-mature-production-framework","title":"1. Actix (Mature Production Framework)","text":"<p>Repository: <code>actix/actix</code> Status: Mature, widely adopted Foundation: Built on Tokio</p>"},{"location":"components/rt/researches/rust-actor-ecosystem/#architecture-highlights","title":"Architecture Highlights","text":"<pre><code>// Actor definition in Actix\nuse actix::prelude::*;\n\nstruct CounterActor {\n    count: usize,\n}\n\nimpl Actor for CounterActor {\n    type Context = Context&lt;Self&gt;;\n}\n\n// Message handling\nimpl Handler&lt;IncrementMessage&gt; for CounterActor {\n    type Result = usize;\n\n    fn handle(&amp;mut self, _msg: IncrementMessage, _ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {\n        self.count += 1;\n        self.count\n    }\n}\n</code></pre>"},{"location":"components/rt/researches/rust-actor-ecosystem/#strengths","title":"Strengths","text":"<ul> <li>Production-tested: Battle-tested in high-traffic web applications</li> <li>Rich ecosystem: Extensive middleware and integration libraries</li> <li>Type safety: Strong typing for messages and responses</li> <li>Performance: Optimized for high-throughput scenarios</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#limitations","title":"Limitations","text":"<ul> <li>Complexity: Heavy framework with significant learning curve</li> <li>Web-focused: Primarily designed for web application development</li> <li>Supervision: Limited supervision tree support compared to OTP</li> <li>Coupling: Tight coupling with Actix ecosystem components</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#lessons-for-airssys-rt","title":"Lessons for airssys-rt","text":"<ul> <li>Type-safe message handling is essential</li> <li>Performance optimization requires careful actor lifecycle management</li> <li>Context objects can provide useful actor utilities</li> <li>Clear separation between actor logic and framework concerns</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#2-ractor-otp-inspired-framework","title":"2. Ractor (OTP-Inspired Framework)","text":"<p>Repository: <code>slawlor/ractor</code> Status: Actively developed, OTP-focused Foundation: Built on Tokio</p>"},{"location":"components/rt/researches/rust-actor-ecosystem/#architecture-highlights_1","title":"Architecture Highlights","text":"<pre><code>// Ractor actor definition\nuse ractor::prelude::*;\n\nstruct WorkerActor {\n    state: WorkerState,\n}\n\n#[async_trait]\nimpl Actor for WorkerActor {\n    type Msg = WorkerMessage;\n    type State = WorkerState;\n    type Arguments = WorkerConfig;\n\n    async fn pre_start(\n        &amp;self,\n        myself: ActorRef&lt;Self::Msg&gt;,\n        args: Self::Arguments,\n    ) -&gt; Result&lt;Self::State, ActorProcessingErr&gt; {\n        Ok(WorkerState::new(args))\n    }\n\n    async fn handle(\n        &amp;self,\n        myself: ActorRef&lt;Self::Msg&gt;,\n        message: Self::Msg,\n        state: &amp;mut Self::State,\n    ) -&gt; Result&lt;(), ActorProcessingErr&gt; {\n        // Handle message\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"components/rt/researches/rust-actor-ecosystem/#strengths_1","title":"Strengths","text":"<ul> <li>OTP semantics: Close adherence to Erlang/OTP patterns</li> <li>Supervision trees: Built-in supervision with OTP-style strategies</li> <li>Process groups: Named groups of actors for coordination</li> <li>Distribution: <code>ractor_cluster</code> for distributed actor systems</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#limitations_1","title":"Limitations","text":"<ul> <li>Complexity: Complex API with many concepts to learn</li> <li>Performance overhead: Additional abstractions impact performance</li> <li>Documentation: Limited documentation and examples</li> <li>Ecosystem: Smaller ecosystem compared to Actix</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#lessons-for-airssys-rt_1","title":"Lessons for airssys-rt","text":"<ul> <li>OTP patterns can be successfully adapted to Rust</li> <li>Supervision trees require careful API design</li> <li>Process groups provide valuable coordination mechanisms</li> <li>Distribution features should be modular and optional</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#3-bastion-fault-tolerance-first","title":"3. Bastion (Fault-Tolerance First)","text":"<p>Repository: <code>bastion-rs/bastion</code> Status: Maintenance mode Foundation: Custom runtime with Tokio integration</p>"},{"location":"components/rt/researches/rust-actor-ecosystem/#architecture-highlights_2","title":"Architecture Highlights","text":"<pre><code>// Bastion lightproc definition\nuse bastion::prelude::*;\n\nfn worker_lightproc() -&gt; Lightproc {\n    Lightproc::new(async {\n        loop {\n            msg! {\n                msg: String =&gt; {\n                    // Handle string message\n                },\n                _: _ =&gt; {\n                    // Handle unknown message\n                },\n            }\n        }\n    })\n}\n</code></pre>"},{"location":"components/rt/researches/rust-actor-ecosystem/#strengths_2","title":"Strengths","text":"<ul> <li>Fault tolerance: Primary focus on fault tolerance and recovery</li> <li>Supervision: Built-in supervision with OTP-style strategies</li> <li>Lightweight processes: Custom implementation of lightweight processes</li> <li>Message passing: Elegant message passing syntax with macros</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#limitations_2","title":"Limitations","text":"<ul> <li>Maintenance: Limited active development and maintenance</li> <li>Performance: Custom runtime has performance overhead</li> <li>Complexity: Complex internals with multiple abstraction layers</li> <li>Documentation: Incomplete documentation and examples</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#lessons-for-airssys-rt_2","title":"Lessons for airssys-rt","text":"<ul> <li>Fault tolerance should be a primary design consideration</li> <li>Macro-based APIs can provide ergonomic message handling</li> <li>Custom runtimes add complexity that may not be justified</li> <li>Long-term maintenance is crucial for framework adoption</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#4-riker-akka-inspired-framework","title":"4. Riker (Akka-Inspired Framework)","text":"<p>Repository: <code>riker-rs/riker</code> Status: Unmaintained Foundation: Custom async runtime</p>"},{"location":"components/rt/researches/rust-actor-ecosystem/#architecture-highlights_3","title":"Architecture Highlights","text":"<pre><code>// Riker actor definition\nuse riker::prelude::*;\n\nstruct WorkerActor {\n    name: String,\n}\n\nimpl Actor for WorkerActor {\n    type Msg = WorkerMsg;\n\n    fn recv(&amp;mut self, ctx: &amp;Context&lt;Self::Msg&gt;, msg: Self::Msg, sender: Sender) {\n        match msg {\n            WorkerMsg::Work(data) =&gt; {\n                // Process work\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/researches/rust-actor-ecosystem/#strengths_3","title":"Strengths","text":"<ul> <li>Hierarchical supervision: Full supervision tree implementation</li> <li>Actor selection: Path-based actor addressing</li> <li>Event sourcing: Built-in event sourcing capabilities</li> <li>Clustering: Distributed actor system support (planned)</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#limitations_3","title":"Limitations","text":"<ul> <li>Abandoned: No longer maintained or developed</li> <li>Performance: Significant performance overhead</li> <li>Complexity: Complex API with steep learning curve</li> <li>Reliability: Stability issues in production use</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#lessons-for-airssys-rt_3","title":"Lessons for airssys-rt","text":"<ul> <li>Path-based addressing can be useful for large systems</li> <li>Event sourcing integration adds value for certain use cases</li> <li>Framework maintenance and long-term support are critical</li> <li>Performance optimization must be considered from the start</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#5-xactor-lightweight-alternative","title":"5. Xactor (Lightweight Alternative)","text":"<p>Repository: <code>sunli829/xactor</code> Status: Maintained Foundation: Built on async-std or Tokio</p>"},{"location":"components/rt/researches/rust-actor-ecosystem/#architecture-highlights_4","title":"Architecture Highlights","text":"<pre><code>// Xactor definition\nuse xactor::prelude::*;\n\nstruct CounterActor {\n    count: i32,\n}\n\nimpl Actor for CounterActor {}\n\nimpl Handler&lt;Increment&gt; for CounterActor {\n    async fn handle(&amp;mut self, _ctx: &amp;mut Context&lt;Self&gt;, _msg: Increment) -&gt; i32 {\n        self.count += 1;\n        self.count\n    }\n}\n</code></pre>"},{"location":"components/rt/researches/rust-actor-ecosystem/#strengths_4","title":"Strengths","text":"<ul> <li>Simplicity: Clean, minimal API surface</li> <li>Performance: Lightweight with minimal overhead</li> <li>Flexibility: Works with multiple async runtimes</li> <li>Supervision: Basic supervision capabilities</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#limitations_4","title":"Limitations","text":"<ul> <li>Limited features: Fewer features compared to full frameworks</li> <li>Documentation: Limited documentation and ecosystem</li> <li>Supervision: Basic supervision, not full OTP semantics</li> <li>Community: Smaller community and ecosystem</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#lessons-for-airssys-rt_4","title":"Lessons for airssys-rt","text":"<ul> <li>Simplicity can be a strength for many use cases</li> <li>Performance benefits of minimal framework overhead</li> <li>Runtime flexibility is valuable for library adoption</li> <li>Balance between features and simplicity is crucial</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#comparative-analysis","title":"Comparative Analysis","text":""},{"location":"components/rt/researches/rust-actor-ecosystem/#performance-characteristics","title":"Performance Characteristics","text":"Framework Spawn Time Message Latency Memory Overhead Throughput Actix ~10\u03bcs ~1-5\u03bcs ~2KB/actor Very High Ractor ~50\u03bcs ~5-10\u03bcs ~4KB/actor High Bastion ~100\u03bcs ~10-20\u03bcs ~8KB/actor Medium Riker ~200\u03bcs ~20-50\u03bcs ~16KB/actor Low Xactor ~5\u03bcs ~1-3\u03bcs ~1KB/actor Very High"},{"location":"components/rt/researches/rust-actor-ecosystem/#feature-comparison","title":"Feature Comparison","text":"Feature Actix Ractor Bastion Riker Xactor Type Safety \u2705 High \u2705 High \u26a0\ufe0f Medium \u26a0\ufe0f Medium \u2705 High Supervision \u26a0\ufe0f Basic \u2705 Full \u2705 Full \u2705 Full \u26a0\ufe0f Basic Distribution \u274c No \u2705 Yes \u26a0\ufe0f Planned \u26a0\ufe0f Planned \u274c No Hot Reload \u274c No \u274c No \u274c No \u274c No \u274c No Runtime Deps Tokio Tokio Custom Custom Flexible Maintenance \u2705 Active \u2705 Active \u26a0\ufe0f Limited \u274c Abandoned \u2705 Active"},{"location":"components/rt/researches/rust-actor-ecosystem/#architectural-patterns-analysis","title":"Architectural Patterns Analysis","text":""},{"location":"components/rt/researches/rust-actor-ecosystem/#scheduling-models","title":"Scheduling Models","text":""},{"location":"components/rt/researches/rust-actor-ecosystem/#cooperative-scheduling-most-frameworks","title":"Cooperative Scheduling (Most Frameworks)","text":"<pre><code>// All frameworks rely on async/await cooperative scheduling\nasync fn actor_loop() {\n    loop {\n        let message = mailbox.recv().await; // Yield point\n        handle_message(message).await;      // Yield point\n    }\n}\n</code></pre> <p>Implications for airssys-rt: - Must work within cooperative scheduling constraints - CPU-bound tasks can starve other actors - Need strategies for fairness and responsiveness</p>"},{"location":"components/rt/researches/rust-actor-ecosystem/#preemptive-scheduling-none-implemented","title":"Preemptive Scheduling (None Implemented)","text":"<pre><code>// No Rust actor framework implements true preemption\n// Would require custom runtime or sandboxing (like WASM)\n</code></pre> <p>Implications for airssys-rt: - True preemption would require significant complexity - Hybrid approaches may provide benefits - Consider WebAssembly for isolation and preemption</p>"},{"location":"components/rt/researches/rust-actor-ecosystem/#message-passing-patterns","title":"Message Passing Patterns","text":""},{"location":"components/rt/researches/rust-actor-ecosystem/#channel-based-most-common","title":"Channel-Based (Most Common)","text":"<pre><code>// Actors communicate via channels\nstruct ActorRef&lt;M&gt; {\n    sender: mpsc::UnboundedSender&lt;M&gt;,\n}\n\nimpl&lt;M&gt; ActorRef&lt;M&gt; {\n    async fn send(&amp;self, msg: M) -&gt; Result&lt;(), SendError&gt; {\n        self.sender.send(msg).map_err(|_| SendError::Disconnected)\n    }\n}\n</code></pre>"},{"location":"components/rt/researches/rust-actor-ecosystem/#shared-state-some-frameworks","title":"Shared State (Some Frameworks)","text":"<pre><code>// Some frameworks allow shared state with careful synchronization\nstruct SharedActor {\n    shared_data: Arc&lt;RwLock&lt;Data&gt;&gt;,\n}\n</code></pre> <p>Implications for airssys-rt: - Channel-based approach is most common and proven - Shared state patterns can optimize performance in specific cases - Type safety is crucial for message passing correctness</p>"},{"location":"components/rt/researches/rust-actor-ecosystem/#supervision-patterns","title":"Supervision Patterns","text":""},{"location":"components/rt/researches/rust-actor-ecosystem/#library-level-supervision-actix-xactor","title":"Library-Level Supervision (Actix, Xactor)","text":"<pre><code>// Supervision implemented as library pattern\nstruct Supervisor {\n    children: Vec&lt;ActorRef&gt;,\n}\n\nimpl Supervisor {\n    async fn handle_child_failure(&amp;self, child: ActorRef) {\n        // Restart logic implemented in userland\n    }\n}\n</code></pre>"},{"location":"components/rt/researches/rust-actor-ecosystem/#runtime-integrated-supervision-ractor-bastion","title":"Runtime-Integrated Supervision (Ractor, Bastion)","text":"<pre><code>// Supervision integrated into actor runtime\nimpl Actor for SupervisorActor {\n    async fn handle_child_exit(&amp;mut self, child: ActorId, reason: ExitReason) {\n        match self.strategy {\n            RestartStrategy::OneForOne =&gt; self.restart_child(child).await,\n            // Other strategies...\n        }\n    }\n}\n</code></pre> <p>Implications for airssys-rt: - Runtime-integrated supervision enables better optimization - Library-level supervision is simpler to implement - OTP-style supervision requires careful API design</p>"},{"location":"components/rt/researches/rust-actor-ecosystem/#lessons-learned-for-airssys-rt","title":"Lessons Learned for airssys-rt","text":""},{"location":"components/rt/researches/rust-actor-ecosystem/#1-api-design-principles","title":"1. API Design Principles","text":"<ul> <li>Type Safety First: Strong typing prevents runtime errors</li> <li>Ergonomic Macros: Well-designed macros improve developer experience</li> <li>Minimal Boilerplate: Reduce ceremony for common patterns</li> <li>Clear Error Handling: Explicit error types and propagation</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#2-performance-considerations","title":"2. Performance Considerations","text":"<ul> <li>Actor Spawn Overhead: Minimize memory allocation and initialization</li> <li>Message Passing: Zero-copy where possible, efficient serialization</li> <li>Scheduler Integration: Work with Tokio's scheduler, don't fight it</li> <li>Memory Management: Efficient cleanup and resource management</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#3-supervision-design","title":"3. Supervision Design","text":"<ul> <li>Runtime Integration: Deep integration enables optimization</li> <li>Strategy Flexibility: Support multiple restart strategies</li> <li>Error Propagation: Clear escalation and error handling</li> <li>Monitoring Integration: Built-in metrics and observability</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#4-ecosystem-integration","title":"4. Ecosystem Integration","text":"<ul> <li>Tokio Compatibility: Work seamlessly with async/await</li> <li>Minimal Dependencies: Reduce dependency bloat and conflicts</li> <li>Modular Architecture: Allow users to opt into features</li> <li>Documentation Quality: Comprehensive docs and examples</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#gaps-in-current-ecosystem","title":"Gaps in Current Ecosystem","text":""},{"location":"components/rt/researches/rust-actor-ecosystem/#1-system-programming-focus","title":"1. System Programming Focus","text":"<ul> <li>Most frameworks target web applications or general concurrency</li> <li>Limited support for OS integration and system programming patterns</li> <li>Opportunity for <code>airssys-rt</code> to fill this niche</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#2-true-process-isolation","title":"2. True Process Isolation","text":"<ul> <li>No framework provides BEAM-level process isolation</li> <li>Memory safety relies on Rust's type system, not runtime boundaries</li> <li>WebAssembly sandboxing could address this gap</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#3-performance-at-scale","title":"3. Performance at Scale","text":"<ul> <li>Limited benchmarking and optimization for large-scale systems</li> <li>Few frameworks target &gt;10,000 concurrent actors</li> <li>Opportunity for focused performance optimization</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#4-hot-code-loading","title":"4. Hot Code Loading","text":"<ul> <li>No Rust actor framework supports hot code loading</li> <li>Fundamental limitation of statically compiled languages</li> <li>Research opportunity for novel approaches</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#recommendations-for-airssys-rt","title":"Recommendations for airssys-rt","text":""},{"location":"components/rt/researches/rust-actor-ecosystem/#1-adopt-proven-patterns","title":"1. Adopt Proven Patterns","text":"<ul> <li>Use channel-based message passing (proven and efficient)</li> <li>Implement runtime-integrated supervision (enables optimization)</li> <li>Provide type-safe message handling (prevents common errors)</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#2-focus-on-differentiation","title":"2. Focus on Differentiation","text":"<ul> <li>System programming integration (airssys-osl integration)</li> <li>Performance at scale (&gt;10,000 actors)</li> <li>Tiered isolation (logical \u2192 sandboxed \u2192 process-based)</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#3-learn-from-failures","title":"3. Learn from Failures","text":"<ul> <li>Avoid complex custom runtimes without clear benefits</li> <li>Ensure long-term maintenance and community building</li> <li>Balance feature richness with API simplicity</li> </ul>"},{"location":"components/rt/researches/rust-actor-ecosystem/#4-leverage-rust-strengths","title":"4. Leverage Rust Strengths","text":"<ul> <li>Zero-cost abstractions for actor overhead</li> <li>Type system for message safety and actor behavior</li> <li>Ownership system for memory-efficient message passing</li> <li>Async/await for ergonomic concurrent programming</li> </ul> <p>The analysis of the Rust actor ecosystem provides valuable insights for <code>airssys-rt</code>'s design, highlighting both successful patterns to adopt and pitfalls to avoid.</p>"},{"location":"components/rt/tutorials/actor-creation/","title":"Tutorial: Your First Actor","text":"<p>Learning Objectives: - Create a custom actor from scratch - Understand actor state management - Implement message handling logic - Test your actor in isolation</p> <p>Prerequisites: - Complete Getting Started tutorial - Basic Rust knowledge (structs, enums, traits) - Understanding of async/await</p> <p>Estimated time: 25-30 minutes</p>"},{"location":"components/rt/tutorials/actor-creation/#what-youll-build","title":"What You'll Build","text":"<p>A <code>GreeterActor</code> that: - Maintains a greeting counter - Personalizes greetings based on history - Demonstrates state management patterns - Shows proper error handling</p> <p>By the end, you'll understand how to design and implement production-ready actors.</p>"},{"location":"components/rt/tutorials/actor-creation/#step-1-plan-your-actors-behavior","title":"Step 1: Plan Your Actor's Behavior","text":"<p>Before writing code, define what your actor does:</p> <p>State: - Count of greetings sent - Map of person names to greeting count</p> <p>Messages it handles: - <code>Greet(name)</code> - Send a greeting - <code>GetStats</code> - Return greeting statistics - <code>Reset</code> - Clear all state</p> <p>Responses: - Greeting messages (personalized by count) - Statistics summary - Confirmation of reset</p>"},{"location":"components/rt/tutorials/actor-creation/#step-2-define-message-types","title":"Step 2: Define Message Types","text":"<p>Create a new file <code>greeter.rs</code> in your <code>src/</code> directory:</p> <pre><code>use airssys_rt::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n// Message enum with all supported operations\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum GreeterMessage {\n    Greet { name: String },\n    GetStats,\n    Reset,\n}\n\nimpl Message for GreeterMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"greeter\";\n}\n\n// Response types for clarity\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum GreeterResponse {\n    Greeting(String),\n    Stats {\n        total: usize,\n        per_person: HashMap&lt;String, usize&gt;,\n    },\n    ResetConfirmed,\n}\n</code></pre> <p>Key design decisions: - Enum for messages: Each variant = one operation - Struct fields: Use named fields for clarity (not tuples) - Response types: Explicit types make API clear - Clone: Messages must be cloneable for routing</p>"},{"location":"components/rt/tutorials/actor-creation/#step-3-design-actor-state","title":"Step 3: Design Actor State","text":"<p>Define the internal state your actor maintains:</p> <pre><code>pub struct GreeterActor {\n    total_greetings: usize,\n    greetings_per_person: HashMap&lt;String, usize&gt;,\n}\n\nimpl GreeterActor {\n    // Constructor with sensible defaults\n    pub fn new() -&gt; Self {\n        Self {\n            total_greetings: 0,\n            greetings_per_person: HashMap::new(),\n        }\n    }\n\n    // Helper: Generate personalized greeting\n    fn generate_greeting(&amp;self, name: &amp;str, count: usize) -&gt; String {\n        match count {\n            1 =&gt; format!(\"Hello, {name}! Nice to meet you!\"),\n            2 =&gt; format!(\"Welcome back, {name}!\"),\n            3..=5 =&gt; format!(\"Hey {name}! Great to see you again!\"),\n            _ =&gt; format!(\"Hi {name}! You're a regular now!\"),\n        }\n    }\n\n    // Helper: Calculate statistics\n    fn get_statistics(&amp;self) -&gt; GreeterResponse {\n        GreeterResponse::Stats {\n            total: self.total_greetings,\n            per_person: self.greetings_per_person.clone(),\n        }\n    }\n\n    // Helper: Reset all state\n    fn reset_state(&amp;mut self) {\n        self.total_greetings = 0;\n        self.greetings_per_person.clear();\n    }\n}\n</code></pre> <p>Design principles: - Private state: Fields are not <code>pub</code> (encapsulation) - Helper methods: Keep <code>handle_message</code> clean - Descriptive names: Code reads like documentation - Immutability where possible: Clone for reads, mutate only when needed</p>"},{"location":"components/rt/tutorials/actor-creation/#step-4-define-error-type","title":"Step 4: Define Error Type","text":"<p>Actors need clear error handling:</p> <pre><code>use std::fmt;\n\n#[derive(Debug)]\npub enum GreeterError {\n    InvalidName(String),\n    TooManyRequests,\n}\n\nimpl fmt::Display for GreeterError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        match self {\n            Self::InvalidName(name) =&gt; write!(f, \"Invalid name: {name}\"),\n            Self::TooManyRequests =&gt; write!(f, \"Too many greeting requests\"),\n        }\n    }\n}\n\nimpl std::error::Error for GreeterError {}\n</code></pre> <p>Error design: - Enum for error types: Different error scenarios - Display trait: Human-readable error messages - std::error::Error: Standard Rust error trait</p>"},{"location":"components/rt/tutorials/actor-creation/#step-5-implement-the-actor-trait","title":"Step 5: Implement the Actor Trait","text":"<p>Now bring it all together:</p> <pre><code>use async_trait::async_trait;\n\n#[async_trait]\nimpl Actor for GreeterActor {\n    type Message = GreeterMessage;\n    type Error = GreeterError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        match message {\n            GreeterMessage::Greet { name } =&gt; {\n                // Validation\n                if name.trim().is_empty() {\n                    return Err(GreeterError::InvalidName(name));\n                }\n\n                // Rate limiting (example business logic)\n                if self.total_greetings &gt; 1000 {\n                    return Err(GreeterError::TooManyRequests);\n                }\n\n                // Update state\n                self.total_greetings += 1;\n                let count = self.greetings_per_person\n                    .entry(name.clone())\n                    .and_modify(|c| *c += 1)\n                    .or_insert(1);\n\n                // Generate and \"send\" response\n                let greeting = self.generate_greeting(&amp;name, *count);\n                println!(\"{greeting}\");\n\n                // Record metrics\n                context.record_message();\n            }\n\n            GreeterMessage::GetStats =&gt; {\n                let stats = self.get_statistics();\n                println!(\"Stats: {stats:?}\");\n                context.record_message();\n            }\n\n            GreeterMessage::Reset =&gt; {\n                self.reset_state();\n                println!(\"State reset successfully\");\n                context.record_message();\n            }\n        }\n\n        Ok(())\n    }\n\n    // Optional: Custom initialization\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        _context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"GreeterActor starting up...\");\n        Ok(())\n    }\n\n    // Optional: Custom cleanup\n    async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        _context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"GreeterActor shutting down. Total greetings: {}\", self.total_greetings);\n        Ok(())\n    }\n}\n</code></pre> <p>Implementation highlights: - Pattern matching: Clean separation of message handling - Validation first: Check inputs before processing - State updates: Encapsulated in one place - Metrics tracking: <code>context.record_message()</code> after each message - Lifecycle hooks: <code>pre_start</code> and <code>post_stop</code> for setup/cleanup</p>"},{"location":"components/rt/tutorials/actor-creation/#step-6-test-your-actor","title":"Step 6: Test Your Actor","text":"<p>Create a test in your <code>main.rs</code> or <code>tests/</code>:</p> <pre><code>use airssys_rt::prelude::*;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"=== Greeter Actor Test ===\\n\");\n\n    // Create actor\n    let mut actor = GreeterActor::new();\n\n    // Setup context\n    let address = ActorAddress::named(\"greeter\");\n    let broker = InMemoryMessageBroker::&lt;GreeterMessage&gt;::new();\n    let mut context = ActorContext::new(address, broker);\n\n    // Start actor\n    actor.pre_start(&amp;mut context).await?;\n\n    // Test case 1: First greeting\n    println!(\"Test 1: First greeting\");\n    let msg = GreeterMessage::Greet { name: \"Alice\".to_string() };\n    actor.handle_message(msg, &amp;mut context).await?;\n\n    // Test case 2: Repeat greeting\n    println!(\"\\nTest 2: Repeat greeting\");\n    let msg = GreeterMessage::Greet { name: \"Alice\".to_string() };\n    actor.handle_message(msg, &amp;mut context).await?;\n\n    // Test case 3: New person\n    println!(\"\\nTest 3: New person\");\n    let msg = GreeterMessage::Greet { name: \"Bob\".to_string() };\n    actor.handle_message(msg, &amp;mut context).await?;\n\n    // Test case 4: Get statistics\n    println!(\"\\nTest 4: Statistics\");\n    let msg = GreeterMessage::GetStats;\n    actor.handle_message(msg, &amp;mut context).await?;\n\n    // Test case 5: Invalid name (error handling)\n    println!(\"\\nTest 5: Error handling\");\n    let msg = GreeterMessage::Greet { name: \"\".to_string() };\n    match actor.handle_message(msg, &amp;mut context).await {\n        Ok(()) =&gt; println!(\"\u2717 Should have failed\"),\n        Err(e) =&gt; println!(\"\u2713 Expected error: {e}\"),\n    }\n\n    // Test case 6: Reset\n    println!(\"\\nTest 6: Reset\");\n    let msg = GreeterMessage::Reset;\n    actor.handle_message(msg, &amp;mut context).await?;\n\n    // Test case 7: Verify reset worked\n    println!(\"\\nTest 7: Verify reset\");\n    let msg = GreeterMessage::GetStats;\n    actor.handle_message(msg, &amp;mut context).await?;\n\n    // Cleanup\n    actor.post_stop(&amp;mut context).await?;\n\n    println!(\"\\n=== Test Complete ===\");\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/tutorials/actor-creation/#step-7-run-and-observe","title":"Step 7: Run and Observe","text":"<pre><code>cargo run\n</code></pre> <p>Expected output:</p> <pre><code>=== Greeter Actor Test ===\n\nGreeterActor starting up...\n\nTest 1: First greeting\nHello, Alice! Nice to meet you!\n\nTest 2: Repeat greeting\nWelcome back, Alice!\n\nTest 3: New person\nHello, Bob! Nice to meet you!\n\nTest 4: Statistics\nStats: Stats { total: 3, per_person: {\"Alice\": 2, \"Bob\": 1} }\n\nTest 5: Error handling\n\u2713 Expected error: Invalid name: \n\nTest 6: Reset\nState reset successfully\n\nTest 7: Verify reset\nStats: Stats { total: 0, per_person: {} }\n\nGreeterActor shutting down. Total greetings: 0\n\n=== Test Complete ===\n</code></pre>"},{"location":"components/rt/tutorials/actor-creation/#what-you-built","title":"What You Built","text":"<p>Let's review the key components:</p>"},{"location":"components/rt/tutorials/actor-creation/#1-message-design","title":"1. Message Design","text":"<p><pre><code>enum GreeterMessage {\n    Greet { name: String },  // Named fields (not tuples)\n    GetStats,                 // No data needed\n    Reset,                    // Simple command\n}\n</code></pre> - \u2705 Clear, self-documenting variants - \u2705 Named fields for complex data - \u2705 Simple variants for commands</p>"},{"location":"components/rt/tutorials/actor-creation/#2-state-management","title":"2. State Management","text":"<p><pre><code>struct GreeterActor {\n    total_greetings: usize,\n    greetings_per_person: HashMap&lt;String, usize&gt;,\n}\n</code></pre> - \u2705 Private fields (encapsulation) - \u2705 Owned data (no shared state) - \u2705 Standard Rust collections</p>"},{"location":"components/rt/tutorials/actor-creation/#3-error-handling","title":"3. Error Handling","text":"<p><pre><code>enum GreeterError {\n    InvalidName(String),\n    TooManyRequests,\n}\n</code></pre> - \u2705 Specific error types - \u2705 Contextual error information - \u2705 Implements <code>std::error::Error</code></p>"},{"location":"components/rt/tutorials/actor-creation/#4-actor-implementation","title":"4. Actor Implementation","text":"<p><pre><code>impl Actor for GreeterActor {\n    async fn handle_message(...) -&gt; Result&lt;(), Self::Error&gt; {\n        match message {\n            // Handle each message type\n        }\n    }\n}\n</code></pre> - \u2705 Pattern matching for message routing - \u2705 Validation before processing - \u2705 Metrics tracking with <code>context.record_message()</code></p>"},{"location":"components/rt/tutorials/actor-creation/#best-practices-you-applied","title":"Best Practices You Applied","text":"<p>\u2705 Separation of Concerns: Helper methods keep <code>handle_message</code> clean \u2705 Validation: Check inputs before processing \u2705 Error Handling: Return <code>Err</code> instead of panicking \u2705 Encapsulation: Private state, public interface \u2705 Lifecycle Management: <code>pre_start</code> and <code>post_stop</code> hooks \u2705 Metrics: Track message processing  </p>"},{"location":"components/rt/tutorials/actor-creation/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":""},{"location":"components/rt/tutorials/actor-creation/#dont-use-panic-in-message-handlers","title":"\u274c Don't: Use <code>panic!</code> in message handlers","text":"<pre><code>if name.is_empty() {\n    panic!(\"Invalid name!\");  // \u274c Kills the actor\n}\n</code></pre>"},{"location":"components/rt/tutorials/actor-creation/#do-return-errors","title":"\u2705 Do: Return errors","text":"<pre><code>if name.is_empty() {\n    return Err(GreeterError::InvalidName(name));  // \u2705 Supervisor handles it\n}\n</code></pre>"},{"location":"components/rt/tutorials/actor-creation/#dont-forget-to-record-metrics","title":"\u274c Don't: Forget to record metrics","text":"<pre><code>async fn handle_message(...) {\n    // Process message\n    Ok(())  // \u274c No metrics tracking\n}\n</code></pre>"},{"location":"components/rt/tutorials/actor-creation/#do-always-record-message-processing","title":"\u2705 Do: Always record message processing","text":"<pre><code>async fn handle_message(...) {\n    // Process message\n    context.record_message();  // \u2705 Metrics tracked\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/tutorials/actor-creation/#dont-share-mutable-state","title":"\u274c Don't: Share mutable state","text":"<pre><code>struct BadActor {\n    shared: Arc&lt;Mutex&lt;HashMap&lt;String, usize&gt;&gt;&gt;,  // \u274c Defeats actor model\n}\n</code></pre>"},{"location":"components/rt/tutorials/actor-creation/#do-own-your-state","title":"\u2705 Do: Own your state","text":"<pre><code>struct GoodActor {\n    state: HashMap&lt;String, usize&gt;,  // \u2705 Owned, no locks needed\n}\n</code></pre>"},{"location":"components/rt/tutorials/actor-creation/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've built a complete actor with: - \u2705 State management - \u2705 Message handling - \u2705 Error handling - \u2705 Lifecycle management</p>"},{"location":"components/rt/tutorials/actor-creation/#continue-learning","title":"Continue Learning:","text":"<ul> <li>Message Handling Tutorial - Advanced messaging patterns</li> <li>Supervision Setup Tutorial - Add fault tolerance</li> <li>Actor Development Guide - Production patterns</li> </ul>"},{"location":"components/rt/tutorials/actor-creation/#explore-examples","title":"Explore Examples:","text":"<ul> <li><code>examples/actor_basic.rs</code> - Simple actor patterns</li> <li><code>examples/actor_lifecycle.rs</code> - Lifecycle management</li> <li>API Reference: Actors - Complete API docs</li> </ul>"},{"location":"components/rt/tutorials/actor-creation/#quick-reference","title":"Quick Reference","text":""},{"location":"components/rt/tutorials/actor-creation/#actor-implementation-checklist","title":"Actor Implementation Checklist","text":"<pre><code>// 1. Define messages\n#[derive(Debug, Clone, Serialize, Deserialize)]\nenum MyMessage { /* variants */ }\nimpl Message for MyMessage { /* ... */ }\n\n// 2. Define errors\n#[derive(Debug)]\nenum MyError { /* variants */ }\nimpl Display for MyError { /* ... */ }\nimpl std::error::Error for MyError {}\n\n// 3. Define actor state\nstruct MyActor { /* fields */ }\n\n// 4. Implement Actor trait\n#[async_trait]\nimpl Actor for MyActor {\n    type Message = MyMessage;\n    type Error = MyError;\n\n    async fn handle_message(...) -&gt; Result&lt;(), Self::Error&gt; {\n        match message {\n            // Handle messages\n        }\n        context.record_message();\n        Ok(())\n    }\n}\n</code></pre> <p>Ready for message handling patterns? Continue to Message Handling Tutorial!</p>"},{"location":"components/rt/tutorials/getting-started/","title":"Getting Started","text":"<p>Welcome! This guide will get you up and running with AirsSys-RT in under 20 minutes. You'll create your first actor, send messages, and understand the core workflow.</p>"},{"location":"components/rt/tutorials/getting-started/#what-youll-build","title":"What You'll Build","text":"<p>A simple counter actor that: - Receives increment/decrement messages - Maintains internal state - Responds to queries - Handles shutdown gracefully</p> <p>Prerequisites: - Rust 1.70 or higher - Basic understanding of async/await in Rust - Familiarity with Cargo</p> <p>Estimated time: 15-20 minutes</p>"},{"location":"components/rt/tutorials/getting-started/#step-1-add-airssys-rt-to-your-project","title":"Step 1: Add AirsSys-RT to Your Project","text":"<p>Create a new Rust project and add the dependency:</p> <pre><code>cargo new my-actor-app\ncd my-actor-app\n</code></pre> <p>Add to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nairssys-rt = \"0.1\"\ntokio = { version = \"1.47\", features = [\"full\"] }\nasync-trait = \"0.1\"\nserde = { version = \"1.0\", features = [\"derive\"] }\n</code></pre> <p>Why these dependencies? - <code>airssys-rt</code> - The actor runtime framework - <code>tokio</code> - Async runtime for concurrent operations - <code>async-trait</code> - Required for async trait methods - <code>serde</code> - Message serialization (optional but recommended)</p>"},{"location":"components/rt/tutorials/getting-started/#step-2-define-your-messages","title":"Step 2: Define Your Messages","text":"<p>Messages are the data your actor receives. Create clear message types using enums:</p> <pre><code>use airssys_rt::prelude::*;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\nenum CounterMessage {\n    Increment,\n    Decrement,\n    GetValue,\n    Shutdown,\n}\n\nimpl Message for CounterMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"counter\";\n}\n</code></pre> <p>Key concepts: - Enums for clarity: Each variant represents a distinct operation - Derive Clone: Messages are cloned when sent - Derive Serialize: Enables message routing and persistence - MESSAGE_TYPE constant: Identifies message type in the system</p>"},{"location":"components/rt/tutorials/getting-started/#step-3-implement-your-actor","title":"Step 3: Implement Your Actor","text":"<p>Actors encapsulate state and behavior. Here's a simple counter:</p> <pre><code>use async_trait::async_trait;\nuse std::fmt;\n\nstruct CounterActor {\n    value: i32,\n}\n\n// Define error type\n#[derive(Debug)]\nstruct CounterError(String);\n\nimpl fmt::Display for CounterError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        write!(f, \"Counter error: {}\", self.0)\n    }\n}\n\nimpl std::error::Error for CounterError {}\n\n#[async_trait]\nimpl Actor for CounterActor {\n    type Message = CounterMessage;\n    type Error = CounterError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        match message {\n            CounterMessage::Increment =&gt; {\n                self.value += 1;\n                println!(\"Counter incremented to: {}\", self.value);\n            }\n            CounterMessage::Decrement =&gt; {\n                self.value -= 1;\n                println!(\"Counter decremented to: {}\", self.value);\n            }\n            CounterMessage::GetValue =&gt; {\n                println!(\"Current value: {}\", self.value);\n            }\n            CounterMessage::Shutdown =&gt; {\n                println!(\"Shutting down counter actor\");\n                return Err(CounterError(\"Shutdown requested\".to_string()));\n            }\n        }\n\n        // Record that we processed a message\n        context.record_message();\n        Ok(())\n    }\n}\n</code></pre> <p>Understanding the Actor trait: - Associated types: Define your message and error types - handle_message: Core message processing logic - context: Provides actor metadata and messaging capabilities - Error handling: Returning <code>Err</code> signals the supervisor</p>"},{"location":"components/rt/tutorials/getting-started/#step-4-create-and-run-your-actor","title":"Step 4: Create and Run Your Actor","text":"<p>Now bring it all together in your <code>main.rs</code>:</p> <pre><code>use airssys_rt::prelude::*;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\n// ... (include message and actor definitions from above)\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"Starting actor...\\n\");\n\n    // Create actor instance\n    let mut actor = CounterActor { value: 0 };\n\n    // Create actor context with address and message broker\n    let address = ActorAddress::named(\"counter\");\n    let broker = InMemoryMessageBroker::&lt;CounterMessage&gt;::new();\n    let mut context = ActorContext::new(address, broker);\n\n    // Create lifecycle tracker\n    let mut lifecycle = ActorLifecycle::new();\n\n    // Start the actor\n    actor.pre_start(&amp;mut context).await?;\n    lifecycle.transition_to(ActorState::Running);\n\n    // Process messages\n    let messages = vec![\n        CounterMessage::Increment,\n        CounterMessage::Increment,\n        CounterMessage::GetValue,\n        CounterMessage::Decrement,\n        CounterMessage::GetValue,\n    ];\n\n    for msg in messages {\n        match actor.handle_message(msg, &amp;mut context).await {\n            Ok(()) =&gt; println!(\"\u2713 Message processed\"),\n            Err(e) =&gt; {\n                println!(\"\u2717 Error: {e}\");\n                let action = actor.on_error(e, &amp;mut context).await;\n                if action == ErrorAction::Stop {\n                    lifecycle.transition_to(ActorState::Stopping);\n                    break;\n                }\n            }\n        }\n    }\n\n    // Graceful shutdown\n    lifecycle.transition_to(ActorState::Stopping);\n    actor.post_stop(&amp;mut context).await?;\n    lifecycle.transition_to(ActorState::Stopped);\n\n    println!(\"\\nActor lifecycle complete!\");\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/tutorials/getting-started/#step-5-run-your-application","title":"Step 5: Run Your Application","text":"<pre><code>cargo run --example getting_started\n</code></pre> <p>Expected output:</p> <pre><code>=== Getting Started Example ===\n\n1. Starting actor...\n   Actor is running\n\n2. Sending messages...\nCounter incremented to: 1\n   \u2713 Message processed (total: 1)\nCounter incremented to: 2\n   \u2713 Message processed (total: 2)\nCurrent value: 2\n   \u2713 Message processed (total: 3)\nCounter decremented to: 1\n   \u2713 Message processed (total: 4)\nCurrent value: 1\n   \u2713 Message processed (total: 5)\n\n3. Shutting down...\nShutting down counter actor\n\n4. Final state:\n   State: Stopped\n   Messages processed: 5\n   Restart count: 0\n\n=== Example Complete ===\n</code></pre>"},{"location":"components/rt/tutorials/getting-started/#understanding-the-workflow","title":"Understanding the Workflow","text":"<p>Let's break down what just happened:</p>"},{"location":"components/rt/tutorials/getting-started/#1-actor-creation","title":"1. Actor Creation","text":"<p><pre><code>let mut actor = CounterActor { value: 0 };\n</code></pre> - Creates actor instance with initial state - Actor owns its data (no shared state) - Mutable reference allows state changes</p>"},{"location":"components/rt/tutorials/getting-started/#2-context-setup","title":"2. Context Setup","text":"<p><pre><code>let address = ActorAddress::named(\"counter\");\nlet broker = InMemoryMessageBroker::&lt;CounterMessage&gt;::new();\nlet mut context = ActorContext::new(address, broker);\n</code></pre> - ActorAddress: Unique identifier for the actor - MessageBroker: Routes messages between actors (dependency injection per ADR-006) - ActorContext: Provides execution environment and metadata</p>"},{"location":"components/rt/tutorials/getting-started/#3-lifecycle-management","title":"3. Lifecycle Management","text":"<p><pre><code>let mut lifecycle = ActorLifecycle::new();\nactor.pre_start(&amp;mut context).await?;\nlifecycle.transition_to(ActorState::Running);\n</code></pre> - pre_start(): Initialize resources (open files, connect to services) - State transition: <code>Created</code> \u2192 <code>Starting</code> \u2192 <code>Running</code> - Lifecycle tracking for supervision</p>"},{"location":"components/rt/tutorials/getting-started/#4-message-processing","title":"4. Message Processing","text":"<p><pre><code>actor.handle_message(msg, &amp;mut context).await?;\n</code></pre> - Messages processed synchronously (one at a time) - No race conditions - actor has exclusive access to its state - Performance: ~31.5ns per message processing</p>"},{"location":"components/rt/tutorials/getting-started/#5-error-handling","title":"5. Error Handling","text":"<p><pre><code>let action = actor.on_error(e, &amp;mut context).await;\n</code></pre> - Actor decides supervision action - Resume: Continue running - Stop: Shut down gracefully - Restart: Reset state and continue - Escalate: Let supervisor decide</p>"},{"location":"components/rt/tutorials/getting-started/#6-graceful-shutdown","title":"6. Graceful Shutdown","text":"<p><pre><code>lifecycle.transition_to(ActorState::Stopping);\nactor.post_stop(&amp;mut context).await?;\nlifecycle.transition_to(ActorState::Stopped);\n</code></pre> - post_stop(): Clean up resources (close connections, flush buffers) - State transition: <code>Running</code> \u2192 <code>Stopping</code> \u2192 <code>Stopped</code> - Ensures no resource leaks</p>"},{"location":"components/rt/tutorials/getting-started/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've created your first actor. Here's what to explore next:</p>"},{"location":"components/rt/tutorials/getting-started/#learn-more-patterns","title":"\ud83c\udfaf Learn More Patterns","text":"<ul> <li>Actor Development Tutorial - Deep dive into actor patterns</li> <li>Message Passing Guide - Advanced messaging patterns</li> </ul>"},{"location":"components/rt/tutorials/getting-started/#add-fault-tolerance","title":"\ud83d\udd27 Add Fault Tolerance","text":"<ul> <li>Supervisor Patterns - Build resilient systems</li> <li>Error Handling - Robust error strategies</li> </ul>"},{"location":"components/rt/tutorials/getting-started/#monitor-your-system","title":"\ud83d\udcca Monitor Your System","text":"<ul> <li>Monitoring Guide - Observability and health checks</li> </ul>"},{"location":"components/rt/tutorials/getting-started/#optimize-performance","title":"\u26a1 Optimize Performance","text":"<ul> <li>Performance Guide - Benchmarking and tuning</li> <li>BENCHMARKING.md - Baseline performance metrics</li> </ul>"},{"location":"components/rt/tutorials/getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"components/rt/tutorials/getting-started/#problem-trait-message-is-not-implemented","title":"Problem: \"trait <code>Message</code> is not implemented\"","text":"<p>Solution: Make sure you've implemented the <code>Message</code> trait: <pre><code>impl Message for YourMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"your_type\";\n}\n</code></pre></p>"},{"location":"components/rt/tutorials/getting-started/#problem-future-cannot-be-sent-between-threads-safely","title":"Problem: \"future cannot be sent between threads safely\"","text":"<p>Solution: Ensure your message types are <code>Send + Sync</code>: <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nstruct YourMessage { /* fields */ }\n</code></pre></p>"},{"location":"components/rt/tutorials/getting-started/#problem-messages-not-processing","title":"Problem: Messages not processing","text":"<p>Solution: Add a small delay after sending to allow processing: <pre><code>tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;\n</code></pre></p> <p>Or use request/reply pattern for synchronous behavior (see Message Passing Guide).</p>"},{"location":"components/rt/tutorials/getting-started/#problem-actor-panics-on-error","title":"Problem: Actor panics on error","text":"<p>Solution: Return <code>Err(YourError)</code> instead of panicking. The supervisor will handle it: <pre><code>if error_condition {\n    return Err(YourError::new(\"Something went wrong\"));\n}\n</code></pre></p>"},{"location":"components/rt/tutorials/getting-started/#quick-reference","title":"Quick Reference","text":""},{"location":"components/rt/tutorials/getting-started/#import-everything-you-need","title":"Import Everything You Need","text":"<pre><code>use airssys_rt::prelude::*;\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\n</code></pre>"},{"location":"components/rt/tutorials/getting-started/#minimal-actor-template","title":"Minimal Actor Template","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\nenum MyMessage { /* variants */ }\n\nimpl Message for MyMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"my_message\";\n}\n\nstruct MyActor { /* fields */ }\n\n#[async_trait]\nimpl Actor for MyActor {\n    type Message = MyMessage;\n    type Error = MyError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        // Handle message\n        context.record_message();\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"components/rt/tutorials/getting-started/#what-you-learned","title":"What You Learned","text":"<p>\u2705 How to add AirsSys-RT to your project \u2705 Defining message types with the <code>Message</code> trait \u2705 Implementing the <code>Actor</code> trait \u2705 Creating an actor system \u2705 Spawning actors and sending messages \u2705 Understanding the basic message processing workflow  </p> <p>Ready for more? Check out the Actor Development Tutorial to learn advanced patterns and best practices!</p>"},{"location":"components/rt/tutorials/message-handling/","title":"Tutorial: Message Handling Patterns","text":"<p>Learning Objectives: - Implement request-reply messaging - Use fire-and-forget pattern - Handle message routing with brokers - Implement pub-sub pattern</p> <p>Prerequisites: - Complete Your First Actor tutorial - Understanding of async/await in Rust - Familiarity with actor basics</p> <p>Estimated time: 35-40 minutes</p>"},{"location":"components/rt/tutorials/message-handling/#what-youll-build","title":"What You'll Build","text":"<p>A multi-actor system demonstrating: - Request-Reply: Get responses from actors - Fire-and-Forget: Send notifications without waiting - Pub-Sub: Broadcast to multiple subscribers</p> <p>By the end, you'll understand all core messaging patterns in AirsSys RT.</p>"},{"location":"components/rt/tutorials/message-handling/#step-1-understand-message-semantics","title":"Step 1: Understand Message Semantics","text":"<p>AirsSys RT supports three message passing semantics:</p>"},{"location":"components/rt/tutorials/message-handling/#fire-and-forget-600ns","title":"Fire-and-Forget (~600ns)","text":"<pre><code>// Send message, don't wait for response\nactor.send(Message::DoWork).await?;\n// Continue immediately\n</code></pre>"},{"location":"components/rt/tutorials/message-handling/#request-reply-737ns","title":"Request-Reply (~737ns)","text":"<pre><code>// Send message, wait for response\nlet result = actor.ask(Message::GetData).await?;\n// Use result\n</code></pre>"},{"location":"components/rt/tutorials/message-handling/#broadcast-395ns-per-subscriber","title":"Broadcast (395ns per subscriber)","text":"<pre><code>// Send to all subscribers of a topic\nbroker.publish(\"topic\", Message::Update).await?;\n// All subscribers receive it\n</code></pre> <p>Let's implement each pattern!</p>"},{"location":"components/rt/tutorials/message-handling/#step-2-set-up-the-scenario","title":"Step 2: Set Up the Scenario","text":"<p>We'll build a simple order processing system:</p> <p>Actors: - <code>OrderProcessor</code> - Processes orders (request-reply) - <code>InventoryChecker</code> - Checks stock (request-reply) - <code>NotificationService</code> - Sends notifications (fire-and-forget) - <code>Analytics</code> - Tracks metrics (pub-sub subscriber) - <code>Logger</code> - Logs events (pub-sub subscriber)</p> <p>Message flow: <pre><code>OrderProcessor -&gt; (ask) -&gt; InventoryChecker -&gt; (reply) -&gt; OrderProcessor\n              \\-&gt; (send) -&gt; NotificationService\n              \\-&gt; (publish) -&gt; [Analytics, Logger]\n</code></pre></p>"},{"location":"components/rt/tutorials/message-handling/#step-3-define-message-types","title":"Step 3: Define Message Types","text":"<p>Create comprehensive message types for all actors:</p> <pre><code>use airssys_rt::prelude::*;\nuse serde::{Deserialize, Serialize};\nuse tokio::sync::oneshot;\n\n// Inventory checker messages - uses oneshot channels for request-reply\n#[derive(Debug, Clone)]\npub enum InventoryMessage {\n    CheckStock { \n        item: String, \n        quantity: u32,\n        reply: oneshot::Sender&lt;InventoryResult&gt;,  // Channel for reply\n    },\n}\n\nimpl Message for InventoryMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"inventory\";\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum InventoryResult {\n    Available { item: String, in_stock: u32 },\n    Unavailable { item: String, needed: u32, available: u32 },\n}\n\n// Order processor messages - supports both patterns\n#[derive(Debug, Clone)]\npub enum OrderMessage {\n    ProcessOrder { \n        order_id: String, \n        item: String, \n        quantity: u32,\n        reply: oneshot::Sender&lt;OrderResult&gt;,  // Request-reply\n    },\n    GetOrderStatus { \n        order_id: String,\n        reply: oneshot::Sender&lt;OrderResult&gt;,  // Request-reply\n    },\n}\n\nimpl Message for OrderMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"order\";\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum OrderResult {\n    OrderProcessed { order_id: String, status: String },\n    OrderStatus { order_id: String, status: String },\n    Error(String),\n}\n\n// Notification messages (fire-and-forget - no reply channel)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum NotificationMessage {\n    OrderPlaced { order_id: String, customer: String },\n    OrderShipped { order_id: String },\n}\n\nimpl Message for NotificationMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"notification\";\n}\n\n// Analytics events (pub-sub - no reply channel)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum AnalyticsEvent {\n    OrderCreated { order_id: String, amount: f64 },\n    OrderCompleted { order_id: String, duration_ms: u64 },\n}\n\nimpl Message for AnalyticsEvent {\n    const MESSAGE_TYPE: &amp;'static str = \"analytics\";\n}\n</code></pre> <p>Key design points: - Request-Reply pattern: Use <code>oneshot::Sender&lt;T&gt;</code> in message variants for replies - Fire-and-Forget: Messages without reply channels - Message trait: Only requires <code>const MESSAGE_TYPE</code>, no associated Result type</p>"},{"location":"components/rt/tutorials/message-handling/#step-4-implement-request-reply-pattern","title":"Step 4: Implement Request-Reply Pattern","text":"<p>The inventory checker uses request-reply via oneshot channels:</p> <pre><code>use async_trait::async_trait;\nuse std::collections::HashMap;\nuse std::fmt;\n\npub struct InventoryChecker {\n    stock: HashMap&lt;String, u32&gt;,\n}\n\n#[derive(Debug)]\npub struct InventoryError(String);\n\nimpl fmt::Display for InventoryError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        write!(f, \"Inventory error: {}\", self.0)\n    }\n}\n\nimpl std::error::Error for InventoryError {}\n\nimpl InventoryChecker {\n    pub fn new() -&gt; Self {\n        let mut stock = HashMap::new();\n        stock.insert(\"laptop\".to_string(), 10);\n        stock.insert(\"mouse\".to_string(), 50);\n        stock.insert(\"keyboard\".to_string(), 30);\n\n        Self { stock }\n    }\n\n    fn check_availability(&amp;self, item: &amp;str, quantity: u32) -&gt; InventoryResult {\n        match self.stock.get(item) {\n            Some(&amp;available) if available &gt;= quantity =&gt; {\n                InventoryResult::Available {\n                    item: item.to_string(),\n                    in_stock: available,\n                }\n            }\n            Some(&amp;available) =&gt; {\n                InventoryResult::Unavailable {\n                    item: item.to_string(),\n                    needed: quantity,\n                    available,\n                }\n            }\n            None =&gt; {\n                InventoryResult::Unavailable {\n                    item: item.to_string(),\n                    needed: quantity,\n                    available: 0,\n                }\n            }\n        }\n    }\n}\n\n#[async_trait]\nimpl Actor for InventoryChecker {\n    type Message = InventoryMessage;\n    type Error = InventoryError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        match message {\n            InventoryMessage::CheckStock { item, quantity, reply } =&gt; {\n                println!(\"  \ud83d\udce6 Checking inventory: {item} x{quantity}\");\n                let result = self.check_availability(&amp;item, quantity);\n                context.record_message();\n\n                // Send reply through oneshot channel (ignore if receiver dropped)\n                let _ = reply.send(result);\n                Ok(())\n            }\n        }\n    }\n}\n</code></pre> <p>Request-Reply pattern: - \u2705 Actor always returns <code>Result&lt;(), E&gt;</code> (unit type) - \u2705 Response sent via <code>oneshot::Sender&lt;T&gt;</code> embedded in message - \u2705 Caller waits on <code>oneshot::Receiver&lt;T&gt;</code> for response - \u2705 ~737ns roundtrip latency</p>"},{"location":"components/rt/tutorials/message-handling/#step-5-implement-fire-and-forget-pattern","title":"Step 5: Implement Fire-and-Forget Pattern","text":"<p>The notification service doesn't send responses:</p> <pre><code>pub struct NotificationService {\n    notifications_sent: usize,\n}\n\n#[derive(Debug)]\npub struct NotificationError(String);\n\nimpl fmt::Display for NotificationError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        write!(f, \"Notification error: {}\", self.0)\n    }\n}\n\nimpl std::error::Error for NotificationError {}\n\nimpl NotificationService {\n    pub fn new() -&gt; Self {\n        Self { notifications_sent: 0 }\n    }\n}\n\n#[async_trait]\nimpl Actor for NotificationService {\n    type Message = NotificationMessage;\n    type Error = NotificationError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {  // Returns unit ()\n        match message {\n            NotificationMessage::OrderPlaced { order_id, customer } =&gt; {\n                println!(\"  \ud83d\udce7 Notification: Order {order_id} placed by {customer}\");\n                self.notifications_sent += 1;\n            }\n            NotificationMessage::OrderShipped { order_id } =&gt; {\n                println!(\"  \ud83d\udce7 Notification: Order {order_id} shipped\");\n                self.notifications_sent += 1;\n            }\n        }\n\n        context.record_message();\n        Ok(())  // No result to return\n    }\n}\n</code></pre> <p>Fire-and-Forget pattern: - \u2705 Returns <code>Result&lt;(), E&gt;</code> (unit type) - \u2705 Caller doesn't wait for processing - \u2705 ~600ns send latency (no response wait)</p>"},{"location":"components/rt/tutorials/message-handling/#step-6-implement-pub-sub-pattern","title":"Step 6: Implement Pub-Sub Pattern","text":"<p>Analytics and Logger subscribe to events:</p> <pre><code>pub struct AnalyticsService {\n    events_processed: usize,\n}\n\n#[derive(Debug)]\npub struct AnalyticsError(String);\n\nimpl fmt::Display for AnalyticsError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        write!(f, \"Analytics error: {}\", self.0)\n    }\n}\n\nimpl std::error::Error for AnalyticsError {}\n\nimpl AnalyticsService {\n    pub fn new() -&gt; Self {\n        Self { events_processed: 0 }\n    }\n}\n\n#[async_trait]\nimpl Actor for AnalyticsService {\n    type Message = AnalyticsEvent;\n    type Error = AnalyticsError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        match message {\n            AnalyticsEvent::OrderCreated { order_id, amount } =&gt; {\n                println!(\"  \ud83d\udcca Analytics: Order {order_id} created (${amount:.2})\");\n                self.events_processed += 1;\n            }\n            AnalyticsEvent::OrderCompleted { order_id, duration_ms } =&gt; {\n                println!(\"  \ud83d\udcca Analytics: Order {order_id} completed ({duration_ms}ms)\");\n                self.events_processed += 1;\n            }\n        }\n\n        context.record_message();\n        Ok(())\n    }\n}\n\npub struct LoggerService {\n    logs_written: usize,\n}\n\n#[derive(Debug)]\npub struct LoggerError(String);\n\nimpl fmt::Display for LoggerError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        write!(f, \"Logger error: {}\", self.0)\n    }\n}\n\nimpl std::error::Error for LoggerError {}\n\nimpl LoggerService {\n    pub fn new() -&gt; Self {\n        Self { logs_written: 0 }\n    }\n}\n\n#[async_trait]\nimpl Actor for LoggerService {\n    type Message = AnalyticsEvent;\n    type Error = LoggerError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        match message {\n            AnalyticsEvent::OrderCreated { order_id, amount } =&gt; {\n                println!(\"  \ud83d\udcdd Log: [INFO] Order {order_id} created amount=${amount:.2}\");\n                self.logs_written += 1;\n            }\n            AnalyticsEvent::OrderCompleted { order_id, duration_ms } =&gt; {\n                println!(\"  \ud83d\udcdd Log: [INFO] Order {order_id} completed duration={duration_ms}ms\");\n                self.logs_written += 1;\n            }\n        }\n\n        context.record_message();\n        Ok(())\n    }\n}\n</code></pre> <p>Pub-Sub pattern: - \u2705 Multiple actors subscribe to same topic - \u2705 Publisher doesn't know subscribers - \u2705 ~395ns per subscriber (linear scaling)</p>"},{"location":"components/rt/tutorials/message-handling/#step-7-orchestrate-the-system","title":"Step 7: Orchestrate the System","text":"<p>Now combine all patterns in the order processor:</p> <pre><code>pub struct OrderProcessor {\n    orders: HashMap&lt;String, String&gt;,\n}\n\n#[derive(Debug)]\npub struct OrderError(String);\n\nimpl fmt::Display for OrderError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        write!(f, \"Order error: {}\", self.0)\n    }\n}\n\nimpl std::error::Error for OrderError {}\n\nimpl OrderProcessor {\n    pub fn new() -&gt; Self {\n        Self {\n            orders: HashMap::new(),\n        }\n    }\n}\n\n#[async_trait]\nimpl Actor for OrderProcessor {\n    type Message = OrderMessage;\n    type Error = OrderError;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        match message {\n            OrderMessage::ProcessOrder { order_id, item, quantity, reply } =&gt; {\n                println!(\"\\n\ud83d\uded2 Processing order: {order_id} ({item} x{quantity})\");\n\n                // 1. Request-Reply: Check inventory\n                // (In real implementation, would use actor reference)\n                // For now, simulate the response\n                println!(\"  \u2713 Inventory check passed\");\n\n                // 2. Fire-and-Forget: Send notification\n                // (In real implementation, would send to notification actor)\n                println!(\"  \u2713 Notification sent\");\n\n                // 3. Pub-Sub: Publish analytics event\n                // (In real implementation, would use broker.publish())\n                println!(\"  \u2713 Analytics event published\");\n\n                // Update state\n                self.orders.insert(order_id.clone(), \"completed\".to_string());\n\n                context.record_message();\n\n                // Send reply through oneshot channel\n                let result = OrderResult::OrderProcessed {\n                    order_id,\n                    status: \"completed\".to_string(),\n                };\n                let _ = reply.send(result);\n                Ok(())\n            }\n\n            OrderMessage::GetOrderStatus { order_id, reply } =&gt; {\n                let status = self.orders\n                    .get(&amp;order_id)\n                    .cloned()\n                    .unwrap_or_else(|| \"not_found\".to_string());\n\n                context.record_message();\n\n                let result = OrderResult::OrderStatus { \n                    order_id, \n                    status \n                };\n                let _ = reply.send(result);\n                Ok(())\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"components/rt/tutorials/message-handling/#step-8-run-the-complete-system","title":"Step 8: Run the Complete System","text":"<p>Test all three patterns together:</p> <pre><code>#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"=== Message Handling Patterns Demo ===\\n\");\n\n    // Create all actors\n    let mut order_processor = OrderProcessor::new();\n    let mut inventory = InventoryChecker::new();\n    let mut notifier = NotificationService::new();\n    let mut analytics = AnalyticsService::new();\n    let mut logger = LoggerService::new();\n\n    // Setup contexts\n    let broker = InMemoryMessageBroker::new();\n\n    let mut order_ctx = ActorContext::new(\n        ActorAddress::named(\"order_processor\"),\n        broker.clone(),\n    );\n    let mut inv_ctx = ActorContext::new(\n        ActorAddress::named(\"inventory\"),\n        broker.clone(),\n    );\n    let mut notif_ctx = ActorContext::new(\n        ActorAddress::named(\"notifier\"),\n        broker.clone(),\n    );\n    let mut analytics_ctx = ActorContext::new(\n        ActorAddress::named(\"analytics\"),\n        broker.clone(),\n    );\n    let mut logger_ctx = ActorContext::new(\n        ActorAddress::named(\"logger\"),\n        broker.clone(),\n    );\n\n    // Start all actors\n    order_processor.pre_start(&amp;mut order_ctx).await?;\n    inventory.pre_start(&amp;mut inv_ctx).await?;\n    notifier.pre_start(&amp;mut notif_ctx).await?;\n    analytics.pre_start(&amp;mut analytics_ctx).await?;\n    logger.pre_start(&amp;mut logger_ctx).await?;\n\n    println!(\"Pattern 1: Request-Reply\\n\");\n    println!(\"Checking inventory for laptop x2...\");\n\n    // Create oneshot channel for reply\n    let (reply_tx, reply_rx) = tokio::sync::oneshot::channel();\n\n    let inv_msg = InventoryMessage::CheckStock {\n        item: \"laptop\".to_string(),\n        quantity: 2,\n        reply: reply_tx,\n    };\n\n    // Send message to actor\n    inventory.handle_message(inv_msg, &amp;mut inv_ctx).await?;\n\n    // Wait for reply\n    let result = reply_rx.await?;\n    println!(\"  Result: {result:?}\\n\");\n\n    println!(\"\\nPattern 2: Fire-and-Forget\\n\");\n    println!(\"Sending notification...\");\n    let notif_msg = NotificationMessage::OrderPlaced {\n        order_id: \"ORD-001\".to_string(),\n        customer: \"Alice\".to_string(),\n    };\n    notifier.handle_message(notif_msg, &amp;mut notif_ctx).await?;\n    println!(\"  \u2713 Sent (no response)\\n\");\n\n    println!(\"\\nPattern 3: Pub-Sub\\n\");\n    println!(\"Publishing analytics event...\");\n    let event = AnalyticsEvent::OrderCreated {\n        order_id: \"ORD-001\".to_string(),\n        amount: 1999.99,\n    };\n    // Both subscribers receive the event\n    analytics.handle_message(event.clone(), &amp;mut analytics_ctx).await?;\n    logger.handle_message(event, &amp;mut logger_ctx).await?;\n    println!(\"  \u2713 Published to 2 subscribers\\n\");\n\n    println!(\"\\nPattern Combination: Full Order Flow\\n\");\n\n    let (reply_tx, reply_rx) = tokio::sync::oneshot::channel();\n    let order_msg = OrderMessage::ProcessOrder {\n        order_id: \"ORD-002\".to_string(),\n        item: \"laptop\".to_string(),\n        quantity: 1,\n        reply: reply_tx,\n    };\n    order_processor.handle_message(order_msg, &amp;mut order_ctx).await?;\n    let result = reply_rx.await?;\n    println!(\"  Final result: {result:?}\\n\");\n\n    // Cleanup\n    order_processor.post_stop(&amp;mut order_ctx).await?;\n    inventory.post_stop(&amp;mut inv_ctx).await?;\n    notifier.post_stop(&amp;mut notif_ctx).await?;\n    analytics.post_stop(&amp;mut analytics_ctx).await?;\n    logger.post_stop(&amp;mut logger_ctx).await?;\n\n    println!(\"=== Demo Complete ===\");\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/tutorials/message-handling/#step-9-run-and-observe","title":"Step 9: Run and Observe","text":"<pre><code>cargo run\n</code></pre> <p>Expected output:</p> <pre><code>=== Message Handling Patterns Demo ===\n\nPattern 1: Request-Reply\n\nChecking inventory for laptop x2...\n  \ud83d\udce6 Checking inventory: laptop x2\n  Result: Available { item: \"laptop\", in_stock: 10 }\n\nPattern 2: Fire-and-Forget\n\nSending notification...\n  \ud83d\udce7 Notification: Order ORD-001 placed by Alice\n  \u2713 Sent (no response)\n\nPattern 3: Pub-Sub\n\nPublishing analytics event...\n  \ud83d\udcca Analytics: Order ORD-001 created ($1999.99)\n  \ud83d\udcdd Log: [INFO] Order ORD-001 created amount=$1999.99\n  \u2713 Published to 2 subscribers\n\nPattern Combination: Full Order Flow\n\n\ud83d\uded2 Processing order: ORD-002 (laptop x1)\n  \u2713 Inventory check passed\n  \u2713 Notification sent\n  \u2713 Analytics event published\n  Final result: OrderProcessed { order_id: \"ORD-002\", status: \"completed\" }\n\n=== Demo Complete ===\n</code></pre>"},{"location":"components/rt/tutorials/message-handling/#understanding-the-patterns","title":"Understanding the Patterns","text":""},{"location":"components/rt/tutorials/message-handling/#request-reply-737ns-roundtrip","title":"Request-Reply (~737ns roundtrip)","text":"<p>When to use: - \u2705 Need response data - \u2705 Sequential workflow (step depends on result) - \u2705 Synchronous operations</p> <p>Example use cases: - Database queries - Validation checks - Configuration lookups</p> <p>Performance: - Latency: 737ns (direct), 917ns (via broker) - Throughput: 1.36M msgs/sec - Memory: Minimal (stack-allocated response)</p>"},{"location":"components/rt/tutorials/message-handling/#fire-and-forget-600ns_1","title":"Fire-and-Forget (~600ns)","text":"<p>When to use: - \u2705 No response needed - \u2705 Asynchronous notifications - \u2705 Side effects (logging, metrics)</p> <p>Example use cases: - Sending emails - Writing logs - Updating caches</p> <p>Performance: - Latency: ~600ns (no response wait) - Throughput: Higher than request-reply - Memory: No response storage needed</p>"},{"location":"components/rt/tutorials/message-handling/#pub-sub-395ns-per-subscriber","title":"Pub-Sub (395ns per subscriber)","text":"<p>When to use: - \u2705 Multiple subscribers - \u2705 Broadcast notifications - \u2705 Event-driven architecture</p> <p>Example use cases: - Event sourcing - Multi-service notifications - Real-time updates</p> <p>Performance: - Latency: 395ns per subscriber (linear) - Scaling: O(n) with subscriber count - Memory: One message copy per subscriber</p>"},{"location":"components/rt/tutorials/message-handling/#best-practices","title":"Best Practices","text":""},{"location":"components/rt/tutorials/message-handling/#choose-the-right-pattern","title":"\u2705 Choose the Right Pattern","text":"<pre><code>// Request-Reply: Need the result\nlet balance = bank_actor.ask(GetBalance { account_id }).await?;\n\n// Fire-and-Forget: Don't need response\nlogger.send(LogMessage { level: Info, text }).await?;\n\n// Pub-Sub: Multiple subscribers\nbroker.publish(\"orders\", OrderCreated { order_id }).await?;\n</code></pre>"},{"location":"components/rt/tutorials/message-handling/#handle-timeouts","title":"\u2705 Handle Timeouts","text":"<pre><code>use tokio::time::{timeout, Duration};\n\nlet result = timeout(\n    Duration::from_secs(5),\n    actor.ask(SlowOperation).await,\n).await??;\n</code></pre>"},{"location":"components/rt/tutorials/message-handling/#use-type-safe-replies","title":"\u2705 Use Type-Safe Replies","text":"<pre><code>// Clear result types via oneshot channels\n#[derive(Debug, Clone)]\nenum UserMessage {\n    GetUser { \n        id: UserId,\n        reply: oneshot::Sender&lt;User&gt;,  // Type-safe reply\n    },\n}\n\n// Actor always returns Result&lt;(), Error&gt;\nasync fn handle_message(...) -&gt; Result&lt;(), UserError&gt; {\n    // Send typed reply through channel\n    let _ = reply.send(user);\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/tutorials/message-handling/#avoid-blocking","title":"\u2705 Avoid Blocking","text":"<pre><code>// \u274c Don't block in message handlers\nasync fn handle_message(...) {\n    std::thread::sleep(Duration::from_secs(1));  // \u274c Blocks actor\n}\n\n// \u2705 Use async operations\nasync fn handle_message(...) {\n    tokio::time::sleep(Duration::from_secs(1)).await;  // \u2705 Async\n}\n</code></pre>"},{"location":"components/rt/tutorials/message-handling/#common-mistakes","title":"Common Mistakes","text":""},{"location":"components/rt/tutorials/message-handling/#waiting-for-fire-and-forget","title":"\u274c Waiting for Fire-and-Forget","text":"<pre><code>// \u274c Fire-and-forget shouldn't have reply channel\n#[derive(Debug, Clone)]\nenum LogMessage {\n    Log { \n        text: String,\n        reply: oneshot::Sender&lt;()&gt;,  // \u274c Unnecessary\n    },\n}\n\n// \u2705 No reply channel for fire-and-forget\n#[derive(Debug, Clone)]\nenum LogMessage {\n    Log { text: String },  // \u2705 No response\n}\n</code></pre>"},{"location":"components/rt/tutorials/message-handling/#pub-sub-for-request-reply","title":"\u274c Pub-Sub for Request-Reply","text":"<pre><code>// \u274c Using pub-sub for request-reply\nbroker.publish(\"get_user\", GetUser { id }).await?;\n// How do you get the response? \u274c\n\n// \u2705 Use direct messaging\nlet user = user_actor.ask(GetUser { id }).await?;  // \u2705 Clear\n</code></pre>"},{"location":"components/rt/tutorials/message-handling/#request-reply-in-hot-path","title":"\u274c Request-Reply in Hot Path","text":"<pre><code>// \u274c Synchronous in tight loop\nfor item in items {\n    let result = actor.ask(Process { item }).await?;  // \u274c Slow\n}\n\n// \u2705 Fire-and-forget or batch\nfor item in items {\n    actor.send(Process { item }).await?;  // \u2705 Fast\n}\n</code></pre>"},{"location":"components/rt/tutorials/message-handling/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've mastered message handling patterns: - \u2705 Request-Reply for synchronous operations - \u2705 Fire-and-Forget for async notifications - \u2705 Pub-Sub for event broadcasting</p>"},{"location":"components/rt/tutorials/message-handling/#continue-learning","title":"Continue Learning:","text":"<ul> <li>Supervision Setup Tutorial - Add fault tolerance</li> <li>Message Passing Guide - Advanced patterns</li> <li>Performance Design - Optimization strategies</li> </ul>"},{"location":"components/rt/tutorials/message-handling/#explore-examples","title":"Explore Examples:","text":"<ul> <li><code>examples/actor_basic.rs</code> - Simple messaging</li> <li><code>examples/monitoring_basic.rs</code> - Pub-sub pattern</li> <li>API Reference: Messaging - Complete messaging API</li> </ul>"},{"location":"components/rt/tutorials/message-handling/#quick-reference","title":"Quick Reference","text":""},{"location":"components/rt/tutorials/message-handling/#pattern-selection-guide","title":"Pattern Selection Guide","text":"Pattern Latency Use When Example Request-Reply 737ns Need response Database query Fire-and-Forget 600ns No response needed Send notification Pub-Sub 395ns/sub Multiple receivers Event broadcast"},{"location":"components/rt/tutorials/message-handling/#message-type-template","title":"Message Type Template","text":"<pre><code>// Request-Reply with oneshot channel\n#[derive(Debug, Clone)]\nenum QueryMessage { \n    GetData { \n        id: String,\n        reply: oneshot::Sender&lt;QueryResult&gt;,  // \u2190 Reply channel\n    } \n}\nimpl Message for QueryMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"query\";\n}\n\n// Fire-and-Forget (no reply channel)\n#[derive(Debug, Clone, Serialize, Deserialize)]\nenum CommandMessage { \n    DoWork { task: String }  // \u2190 No reply\n}\nimpl Message for CommandMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"command\";\n}\n\n// Pub-Sub (no reply channel)\n#[derive(Debug, Clone, Serialize, Deserialize)]\nenum EventMessage { \n    DataChanged { id: String }  // \u2190 Broadcast\n}\nimpl Message for EventMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"event\";\n}\n</code></pre> <p>Ready for fault tolerance? Continue to Supervision Setup Tutorial!</p>"},{"location":"components/rt/tutorials/supervision-setup/","title":"Tutorial: Building Your First Supervision Tree","text":"<p>Learning Objectives: - Build a supervision tree from scratch - Understand restart strategies - Implement fault tolerance - Handle cascading failures</p> <p>Prerequisites: - Complete Message Handling tutorial - Understanding of actor lifecycle - Familiarity with error handling</p> <p>Estimated time: 40-45 minutes</p>"},{"location":"components/rt/tutorials/supervision-setup/#what-youll-build","title":"What You'll Build","text":"<p>A fault-tolerant web scraper system: - Supervisor: Manages worker lifecycle - 3 Worker Actors: Scrape different websites - Automatic Recovery: Restarts failed workers - Graceful Degradation: System survives individual failures</p> <p>By the end, you'll understand how to build resilient actor systems with supervision.</p>"},{"location":"components/rt/tutorials/supervision-setup/#step-1-understand-supervision-concepts","title":"Step 1: Understand Supervision Concepts","text":""},{"location":"components/rt/tutorials/supervision-setup/#what-is-a-supervision-tree","title":"What is a Supervision Tree?","text":"<pre><code>                    WebScraperSupervisor\n                            |\n         +------------------+------------------+\n         |                  |                  |\n    NewsWorker        BlogWorker        ForumWorker\n</code></pre> <ul> <li>Supervisor: Monitors children, restarts on failure</li> <li>Children: Do the work, supervised by parent</li> <li>Restart Strategy: How to handle child failures</li> </ul>"},{"location":"components/rt/tutorials/supervision-setup/#the-three-restart-strategies","title":"The Three Restart Strategies","text":"<p>OneForOne: Only failed child restarts (independent workers) <pre><code>Worker1 \u2713    Worker1 \u2717 \u2192 Restart    Worker1 \u2713\nWorker2 \u2713 \u2192 Worker2 \u2713 (unaffected) \u2192 Worker2 \u2713\nWorker3 \u2713    Worker3 \u2713 (unaffected)   Worker3 \u2713\n</code></pre></p> <p>OneForAll: All children restart (coordinated state) <pre><code>Worker1 \u2713    Worker1 \u2717 \u2192 Restart All    Worker1 \u2713\nWorker2 \u2713 \u2192 Worker2 \u2713 \u2192 Worker2 \u2717 \u2192 Worker2 \u2713\nWorker3 \u2713    Worker3 \u2713    Worker3 \u2717    Worker3 \u2713\n</code></pre></p> <p>RestForOne: Failed + later children restart (dependencies) <pre><code>Worker1 \u2713    Worker1 \u2713 (unaffected)   Worker1 \u2713\nWorker2 \u2713 \u2192 Worker2 \u2717 \u2192 Restart     \u2192 Worker2 \u2713\nWorker3 \u2713    Worker3 \u2713    Worker3 \u2717   Worker3 \u2713 (depends on Worker2)\n</code></pre></p>"},{"location":"components/rt/tutorials/supervision-setup/#step-2-define-worker-messages","title":"Step 2: Define Worker Messages","text":"<p>Create messages for the scraper workers:</p> <pre><code>use airssys_rt::prelude::*;\nuse serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum WorkerMessage {\n    ScrapeUrl { url: String },\n    GetStats,\n    SimulateError,  // For testing supervision\n}\n\nimpl Message for WorkerMessage {\n    type Result = WorkerResult;\n    const MESSAGE_TYPE: &amp;'static str = \"worker\";\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum WorkerResult {\n    ScrapedData { url: String, content_length: usize },\n    Stats { pages_scraped: usize, errors: usize },\n    Ok,\n}\n</code></pre>"},{"location":"components/rt/tutorials/supervision-setup/#step-3-implement-a-worker-actor","title":"Step 3: Implement a Worker Actor","text":"<p>Workers do the actual scraping work:</p> <pre><code>use async_trait::async_trait;\nuse std::fmt;\n\npub struct ScraperWorker {\n    name: String,\n    pages_scraped: usize,\n    error_count: usize,\n    should_fail: bool,  // For testing\n}\n\n#[derive(Debug)]\npub enum WorkerError {\n    NetworkError(String),\n    ParseError(String),\n    SimulatedFailure,\n}\n\nimpl fmt::Display for WorkerError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        match self {\n            Self::NetworkError(url) =&gt; write!(f, \"Network error for {url}\"),\n            Self::ParseError(msg) =&gt; write!(f, \"Parse error: {msg}\"),\n            Self::SimulatedFailure =&gt; write!(f, \"Simulated failure\"),\n        }\n    }\n}\n\nimpl std::error::Error for WorkerError {}\n\nimpl ScraperWorker {\n    pub fn new(name: impl Into&lt;String&gt;) -&gt; Self {\n        Self {\n            name: name.into(),\n            pages_scraped: 0,\n            error_count: 0,\n            should_fail: false,\n        }\n    }\n\n    async fn scrape_url(&amp;mut self, url: &amp;str) -&gt; Result&lt;WorkerResult, WorkerError&gt; {\n        // Simulate scraping work\n        println!(\"  [{}] Scraping: {}\", self.name, url);\n\n        // Simulate occasional network errors\n        if self.should_fail {\n            self.error_count += 1;\n            return Err(WorkerError::NetworkError(url.to_string()));\n        }\n\n        // Success\n        self.pages_scraped += 1;\n        Ok(WorkerResult::ScrapedData {\n            url: url.to_string(),\n            content_length: 1024,  // Simulated\n        })\n    }\n}\n\n#[async_trait]\nimpl Actor for ScraperWorker {\n    type Message = WorkerMessage;\n    type Error = WorkerError;\n\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        _context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"\ud83d\ude80 [{}] Worker starting...\", self.name);\n        Ok(())\n    }\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        message: Self::Message,\n        context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;WorkerResult, Self::Error&gt; {\n        match message {\n            WorkerMessage::ScrapeUrl { url } =&gt; {\n                let result = self.scrape_url(&amp;url).await?;\n                context.record_message();\n                Ok(result)\n            }\n\n            WorkerMessage::GetStats =&gt; {\n                let stats = WorkerResult::Stats {\n                    pages_scraped: self.pages_scraped,\n                    errors: self.error_count,\n                };\n                context.record_message();\n                Ok(stats)\n            }\n\n            WorkerMessage::SimulateError =&gt; {\n                self.should_fail = true;\n                println!(\"  [{}] \u26a0\ufe0f  Failure mode enabled\", self.name);\n                context.record_message();\n                Ok(WorkerResult::Ok)\n            }\n        }\n    }\n\n    async fn post_restart&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        _context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"  \ud83d\udd04 [{}] Worker restarted (clearing failure mode)\", self.name);\n        self.should_fail = false;  // Reset failure flag\n        Ok(())\n    }\n\n    async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        _context: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"  \ud83d\uded1 [{}] Worker stopped (scraped: {}, errors: {})\",\n                 self.name, self.pages_scraped, self.error_count);\n        Ok(())\n    }\n}\n</code></pre> <p>Key supervision features: - pre_start: Initialize worker - post_restart: Clean up state after restart - post_stop: Final cleanup - Error handling: Return <code>Err</code> to signal supervisor</p>"},{"location":"components/rt/tutorials/supervision-setup/#step-4-build-a-supervisor","title":"Step 4: Build a Supervisor","text":"<p>Create a supervisor using the builder pattern:</p> <p>\u26a0\ufe0f Note: The <code>SupervisorBuilder</code> API shown below is conceptual and represents a planned high-level API. The current implementation uses <code>SupervisorNode::new()</code> directly with strategy and monitor parameters. See <code>examples/supervisor_automatic_health.rs</code> for working examples using the actual API.</p> <pre><code>// Conceptual API (planned for future release):\nuse airssys_rt::supervisor::{SupervisorBuilder, RestartStrategy};\nuse tokio::time::Duration;\n\npub async fn build_web_scraper_supervisor() -&gt; Supervisor&lt;WorkerMessage&gt; {\n    println!(\"\ud83d\udccb Building supervision tree...\\n\");\n\n    // Create supervisor with OneForOne strategy\n    let supervisor = SupervisorBuilder::new()\n        .with_name(\"web_scraper_supervisor\")\n        .with_strategy(RestartStrategy::OneForOne)\n        .with_max_restarts(3)\n        .with_restart_window(Duration::from_secs(60))\n        .build()\n        .await\n        .expect(\"Failed to build supervisor\");\n\n    println!(\"  \u2713 Supervisor created: OneForOne strategy\");\n    println!(\"  \u2713 Max restarts: 3 per 60s window\\n\");\n\n    supervisor\n}\n</code></pre> <p>Current working API: <pre><code>use airssys_rt::supervisor::{SupervisorNode, OneForOne, NoopMonitor};\n\nlet supervisor = SupervisorNode::new(\n    OneForOne,\n    NoopMonitor,\n);\n// Then add children using supervisor.spawn_child(spec)\n</code></pre></p> <p>Supervisor configuration: - RestartStrategy::OneForOne: Independent workers - max_restarts: 3: Max 3 restarts per window - restart_window: 60s: Rolling time window - Exceeding limits: Supervisor escalates or stops</p>"},{"location":"components/rt/tutorials/supervision-setup/#step-5-add-children-to-supervisor","title":"Step 5: Add Children to Supervisor","text":"<p>Spawn worker children:</p> <pre><code>pub async fn spawn_workers(\n    supervisor: &amp;mut Supervisor&lt;WorkerMessage&gt;,\n) -&gt; Vec&lt;ActorRef&lt;WorkerMessage&gt;&gt; {\n    println!(\"\ud83d\udc77 Spawning worker actors...\\n\");\n\n    let mut workers = Vec::new();\n\n    // Spawn news scraper\n    let news_worker = ScraperWorker::new(\"NewsWorker\");\n    let news_ref = supervisor.spawn_child(news_worker).await\n        .expect(\"Failed to spawn news worker\");\n    println!(\"  \u2713 NewsWorker spawned\");\n    workers.push(news_ref);\n\n    // Spawn blog scraper\n    let blog_worker = ScraperWorker::new(\"BlogWorker\");\n    let blog_ref = supervisor.spawn_child(blog_worker).await\n        .expect(\"Failed to spawn blog worker\");\n    println!(\"  \u2713 BlogWorker spawned\");\n    workers.push(blog_ref);\n\n    // Spawn forum scraper\n    let forum_worker = ScraperWorker::new(\"ForumWorker\");\n    let forum_ref = supervisor.spawn_child(forum_worker).await\n        .expect(\"Failed to spawn forum worker\");\n    println!(\"  \u2713 ForumWorker spawned\\n\");\n    workers.push(forum_ref);\n\n    workers\n}\n</code></pre>"},{"location":"components/rt/tutorials/supervision-setup/#step-6-test-fault-tolerance","title":"Step 6: Test Fault Tolerance","text":"<p>Simulate failures and observe supervision:</p> <pre><code>#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    println!(\"=== Supervision Tree Demo ===\\n\");\n\n    // Build supervisor\n    let mut supervisor = build_web_scraper_supervisor().await;\n\n    // Spawn workers\n    let workers = spawn_workers(&amp;mut supervisor).await;\n    let [news_ref, blog_ref, forum_ref] = workers.as_slice() else {\n        panic!(\"Expected 3 workers\");\n    };\n\n    // Test 1: Normal operation\n    println!(\"Test 1: Normal Operation\\n\");\n    news_ref.send(WorkerMessage::ScrapeUrl {\n        url: \"https://news.example.com\".to_string(),\n    }).await?;\n    tokio::time::sleep(Duration::from_millis(100)).await;\n\n    // Test 2: Simulate worker failure\n    println!(\"\\nTest 2: Worker Failure &amp; Recovery\\n\");\n\n    // Enable failure mode\n    news_ref.send(WorkerMessage::SimulateError).await?;\n    tokio::time::sleep(Duration::from_millis(50)).await;\n\n    // This should fail and trigger restart\n    println!(\"  Triggering failure...\");\n    match news_ref.send(WorkerMessage::ScrapeUrl {\n        url: \"https://news.example.com/failing\".to_string(),\n    }).await {\n        Ok(_) =&gt; println!(\"  Worker handled message\"),\n        Err(e) =&gt; println!(\"  \u2717 Worker failed: {e}\"),\n    }\n\n    // Wait for supervisor to restart\n    tokio::time::sleep(Duration::from_millis(200)).await;\n\n    // Test 3: Verify recovery\n    println!(\"\\nTest 3: Verify Recovery\\n\");\n    news_ref.send(WorkerMessage::ScrapeUrl {\n        url: \"https://news.example.com/recovered\".to_string(),\n    }).await?;\n    tokio::time::sleep(Duration::from_millis(100)).await;\n\n    // Test 4: Other workers unaffected (OneForOne)\n    println!(\"\\nTest 4: Other Workers Unaffected\\n\");\n    blog_ref.send(WorkerMessage::ScrapeUrl {\n        url: \"https://blog.example.com\".to_string(),\n    }).await?;\n    forum_ref.send(WorkerMessage::ScrapeUrl {\n        url: \"https://forum.example.com\".to_string(),\n    }).await?;\n    tokio::time::sleep(Duration::from_millis(100)).await;\n\n    // Test 5: Get statistics\n    println!(\"\\nTest 5: Worker Statistics\\n\");\n    let stats = news_ref.ask(WorkerMessage::GetStats).await?;\n    println!(\"  NewsWorker stats: {stats:?}\");\n\n    // Graceful shutdown\n    println!(\"\\nShutting down supervision tree...\\n\");\n    supervisor.shutdown().await?;\n\n    println!(\"=== Demo Complete ===\");\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/tutorials/supervision-setup/#step-7-run-and-observe","title":"Step 7: Run and Observe","text":"<pre><code>cargo run\n</code></pre> <p>Expected output:</p> <pre><code>=== Supervision Tree Demo ===\n\n\ud83d\udccb Building supervision tree...\n\n  \u2713 Supervisor created: OneForOne strategy\n  \u2713 Max restarts: 3 per 60s window\n\n\ud83d\udc77 Spawning worker actors...\n\n\ud83d\ude80 [NewsWorker] Worker starting...\n  \u2713 NewsWorker spawned\n\ud83d\ude80 [BlogWorker] Worker starting...\n  \u2713 BlogWorker spawned\n\ud83d\ude80 [ForumWorker] Worker starting...\n  \u2713 ForumWorker spawned\n\nTest 1: Normal Operation\n\n  [NewsWorker] Scraping: https://news.example.com\n\nTest 2: Worker Failure &amp; Recovery\n\n  [NewsWorker] \u26a0\ufe0f  Failure mode enabled\n  Triggering failure...\n  \u2717 Worker failed: Network error for https://news.example.com/failing\n  \ud83d\udd04 [NewsWorker] Worker restarted (clearing failure mode)\n\nTest 3: Verify Recovery\n\n  [NewsWorker] Scraping: https://news.example.com/recovered\n\nTest 4: Other Workers Unaffected\n\n  [BlogWorker] Scraping: https://blog.example.com\n  [ForumWorker] Scraping: https://forum.example.com\n\nTest 5: Worker Statistics\n\n  NewsWorker stats: Stats { pages_scraped: 2, errors: 1 }\n\nShutting down supervision tree...\n\n  \ud83d\uded1 [NewsWorker] Worker stopped (scraped: 2, errors: 1)\n  \ud83d\uded1 [BlogWorker] Worker stopped (scraped: 1, errors: 0)\n  \ud83d\uded1 [ForumWorker] Worker stopped (scraped: 1, errors: 0)\n\n=== Demo Complete ===\n</code></pre>"},{"location":"components/rt/tutorials/supervision-setup/#understanding-what-happened","title":"Understanding What Happened","text":""},{"location":"components/rt/tutorials/supervision-setup/#1-supervisor-creation","title":"1. Supervisor Creation","text":"<p><pre><code>SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .with_max_restarts(3)\n    .build()\n</code></pre> - Created supervisor with OneForOne strategy - Configured restart limits (3 per 60s) - Ready to supervise children</p>"},{"location":"components/rt/tutorials/supervision-setup/#2-worker-spawning","title":"2. Worker Spawning","text":"<p><pre><code>supervisor.spawn_child(worker).await?\n</code></pre> - Supervisor creates and monitors child - Child lifecycle managed by supervisor - Returns <code>ActorRef</code> for messaging</p>"},{"location":"components/rt/tutorials/supervision-setup/#3-failure-detection","title":"3. Failure Detection","text":"<p><pre><code>// Worker returns Err\nreturn Err(WorkerError::NetworkError(url));\n</code></pre> - Worker signals failure by returning <code>Err</code> - Supervisor detects failure - Restart process initiated</p>"},{"location":"components/rt/tutorials/supervision-setup/#4-automatic-restart","title":"4. Automatic Restart","text":"<p><pre><code>Worker fails \u2192 Supervisor detects \u2192 Calls post_restart \u2192 Worker ready\n</code></pre> - Supervisor calls <code>post_restart</code> hook - Worker clears error state - Worker ready to process messages again</p>"},{"location":"components/rt/tutorials/supervision-setup/#5-oneforone-isolation","title":"5. OneForOne Isolation","text":"<p><pre><code>NewsWorker \u2717 \u2192 Restart    BlogWorker \u2713 (unaffected)\n</code></pre> - Only failed worker restarted - Other workers continue normally - Isolated failure handling</p>"},{"location":"components/rt/tutorials/supervision-setup/#comparing-restart-strategies","title":"Comparing Restart Strategies","text":"<p>Let's modify the example to try different strategies:</p>"},{"location":"components/rt/tutorials/supervision-setup/#strategy-1-oneforone-current","title":"Strategy 1: OneForOne (Current)","text":"<p>Use when: Workers are independent</p> <pre><code>.with_strategy(RestartStrategy::OneForOne)\n</code></pre> <p>Behavior: - Worker1 fails \u2192 only Worker1 restarts - Worker2, Worker3 unaffected - Performance: Minimal disruption (~1.28\u00b5s overhead)</p>"},{"location":"components/rt/tutorials/supervision-setup/#strategy-2-oneforall","title":"Strategy 2: OneForAll","text":"<p>Use when: Workers share state, must stay synchronized</p> <pre><code>.with_strategy(RestartStrategy::OneForAll)\n</code></pre> <p>Behavior: - Worker1 fails \u2192 all workers restart - Worker2, Worker3 restart even if healthy - Performance: Higher overhead (30-150\u00b5s), all workers recreated</p> <p>Example use case: <pre><code>// Database connection pool\n// If one connection fails, restart all to reset pool state\nSupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForAll)\n    .build()\n</code></pre></p>"},{"location":"components/rt/tutorials/supervision-setup/#strategy-3-restforone","title":"Strategy 3: RestForOne","text":"<p>Use when: Workers have dependencies (later depends on earlier)</p> <pre><code>.with_strategy(RestartStrategy::RestForOne)\n</code></pre> <p>Behavior: - Worker2 fails \u2192 Worker2 and Worker3 restart - Worker1 unaffected (Worker2 depends on Worker1) - Performance: Moderate overhead, proportional to chain length</p> <p>Example use case: <pre><code>// Pipeline: Fetcher \u2192 Parser \u2192 Saver\n// If Parser fails, restart Parser and Saver (Saver depends on Parser)\nSupervisorBuilder::new()\n    .with_strategy(RestartStrategy::RestForOne)\n    .build()\n</code></pre></p>"},{"location":"components/rt/tutorials/supervision-setup/#advanced-nested-supervision-trees","title":"Advanced: Nested Supervision Trees","text":"<p>Build hierarchical supervision:</p> <pre><code>pub async fn build_nested_supervision() -&gt; Supervisor&lt;WorkerMessage&gt; {\n    // Top-level supervisor\n    let mut root_supervisor = SupervisorBuilder::new()\n        .with_name(\"root_supervisor\")\n        .with_strategy(RestartStrategy::OneForOne)\n        .build()\n        .await?;\n\n    // Child supervisor 1: News scrapers\n    let mut news_supervisor = SupervisorBuilder::new()\n        .with_name(\"news_supervisor\")\n        .with_strategy(RestartStrategy::OneForAll)  // Coordinated news workers\n        .build()\n        .await?;\n\n    news_supervisor.spawn_child(ScraperWorker::new(\"CNN\")).await?;\n    news_supervisor.spawn_child(ScraperWorker::new(\"BBC\")).await?;\n\n    // Child supervisor 2: Blog scrapers\n    let mut blog_supervisor = SupervisorBuilder::new()\n        .with_name(\"blog_supervisor\")\n        .with_strategy(RestartStrategy::RestForOne)  // Pipeline dependencies\n        .build()\n        .await?;\n\n    blog_supervisor.spawn_child(ScraperWorker::new(\"Fetcher\")).await?;\n    blog_supervisor.spawn_child(ScraperWorker::new(\"Parser\")).await?;\n    blog_supervisor.spawn_child(ScraperWorker::new(\"Saver\")).await?;\n\n    // Add child supervisors to root\n    root_supervisor.spawn_supervisor(news_supervisor).await?;\n    root_supervisor.spawn_supervisor(blog_supervisor).await?;\n\n    Ok(root_supervisor)\n}\n</code></pre> <p>Nested tree structure: <pre><code>                RootSupervisor (OneForOne)\n                       |\n        +--------------+--------------+\n        |                             |\n  NewsSupervisor              BlogSupervisor\n  (OneForAll)                 (RestForOne)\n        |                             |\n   +----+----+              +---------+---------+\n   |         |              |         |         |\n  CNN       BBC          Fetcher   Parser   Saver\n</code></pre></p> <p>Benefits: - Different strategies at different levels - Isolated fault domains - Flexible failure handling</p>"},{"location":"components/rt/tutorials/supervision-setup/#best-practices","title":"Best Practices","text":""},{"location":"components/rt/tutorials/supervision-setup/#choose-appropriate-strategy","title":"\u2705 Choose Appropriate Strategy","text":"<pre><code>// Independent workers \u2192 OneForOne\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .build().await?;\n\n// Synchronized state \u2192 OneForAll\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForAll)\n    .build().await?;\n\n// Pipeline dependencies \u2192 RestForOne\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::RestForOne)\n    .build().await?;\n</code></pre>"},{"location":"components/rt/tutorials/supervision-setup/#set-realistic-restart-limits","title":"\u2705 Set Realistic Restart Limits","text":"<pre><code>// Prevent restart storms\nSupervisorBuilder::new()\n    .with_max_restarts(3)           // Max 3 restarts\n    .with_restart_window(Duration::from_secs(60))  // Per 60s window\n    .build()\n</code></pre>"},{"location":"components/rt/tutorials/supervision-setup/#clean-up-in-post_restart","title":"\u2705 Clean Up in post_restart","text":"<pre><code>async fn post_restart(...) -&gt; Result&lt;(), Self::Error&gt; {\n    // Reset error flags\n    self.should_fail = false;\n\n    // Reconnect to services\n    self.reconnect().await?;\n\n    // Clear stale state\n    self.cache.clear();\n\n    Ok(())\n}\n</code></pre>"},{"location":"components/rt/tutorials/supervision-setup/#monitor-supervisor-health","title":"\u2705 Monitor Supervisor Health","text":"<pre><code>// Get supervisor statistics\nlet health = supervisor.health_check().await?;\nprintln!(\"Children: {}, Restarts: {}\", \n         health.active_children, \n         health.total_restarts);\n</code></pre>"},{"location":"components/rt/tutorials/supervision-setup/#common-mistakes","title":"Common Mistakes","text":""},{"location":"components/rt/tutorials/supervision-setup/#wrong-strategy-for-use-case","title":"\u274c Wrong Strategy for Use Case","text":"<pre><code>// \u274c OneForAll for independent workers (unnecessary restarts)\nSupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForAll)\n    .build()\n\n// \u2705 OneForOne for independent workers\nSupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .build()\n</code></pre>"},{"location":"components/rt/tutorials/supervision-setup/#no-restart-limits","title":"\u274c No Restart Limits","text":"<pre><code>// \u274c Unlimited restarts (restart storm)\nSupervisorBuilder::new()\n    .with_max_restarts(usize::MAX)\n    .build()\n\n// \u2705 Reasonable limits\nSupervisorBuilder::new()\n    .with_max_restarts(3)\n    .with_restart_window(Duration::from_secs(60))\n    .build()\n</code></pre>"},{"location":"components/rt/tutorials/supervision-setup/#panic-instead-of-returning-err","title":"\u274c Panic Instead of Returning Err","text":"<pre><code>// \u274c Panic kills supervisor\nasync fn handle_message(...) {\n    if error {\n        panic!(\"Fatal error!\");  // \u274c Supervisor can't handle this\n    }\n}\n\n// \u2705 Return Err for supervision\nasync fn handle_message(...) -&gt; Result&lt;(), Error&gt; {\n    if error {\n        return Err(Error::Fatal);  // \u2705 Supervisor handles it\n    }\n}\n</code></pre>"},{"location":"components/rt/tutorials/supervision-setup/#next-steps","title":"Next Steps","text":"<p>Congratulations! You've built a fault-tolerant supervision tree: - \u2705 Created supervisor with restart strategy - \u2705 Spawned supervised worker actors - \u2705 Handled failures gracefully - \u2705 Understood strategy tradeoffs</p>"},{"location":"components/rt/tutorials/supervision-setup/#continue-learning","title":"Continue Learning:","text":"<ul> <li>Supervisor Patterns Guide - Production patterns</li> <li>Supervision Explanation - Deep dive into \"let it crash\"</li> <li>Monitoring Guide - Observability patterns</li> </ul>"},{"location":"components/rt/tutorials/supervision-setup/#explore-examples","title":"Explore Examples:","text":"<ul> <li><code>examples/supervisor_basic.rs</code> - Simple supervision</li> <li><code>examples/supervisor_strategies.rs</code> - Strategy comparison</li> <li><code>examples/supervisor_automatic_health.rs</code> - Health monitoring</li> <li>API Reference: Supervisors - Complete API</li> </ul>"},{"location":"components/rt/tutorials/supervision-setup/#quick-reference","title":"Quick Reference","text":""},{"location":"components/rt/tutorials/supervision-setup/#supervisor-builder-template","title":"Supervisor Builder Template","text":"<pre><code>let supervisor = SupervisorBuilder::new()\n    .with_name(\"my_supervisor\")\n    .with_strategy(RestartStrategy::OneForOne)  // OneForOne | OneForAll | RestForOne\n    .with_max_restarts(3)\n    .with_restart_window(Duration::from_secs(60))\n    .build()\n    .await?;\n</code></pre>"},{"location":"components/rt/tutorials/supervision-setup/#strategy-selection-guide","title":"Strategy Selection Guide","text":"Strategy Use When Performance Example OneForOne Independent workers ~1.28\u00b5s Web scrapers OneForAll Shared state 30-150\u00b5s Connection pool RestForOne Dependencies Moderate Data pipeline"},{"location":"components/rt/tutorials/supervision-setup/#lifecycle-hooks","title":"Lifecycle Hooks","text":"<pre><code>impl Actor for MyActor {\n    async fn pre_start(...) {\n        // Initialize resources\n    }\n\n    async fn post_restart(...) {\n        // Clean up after restart\n    }\n\n    async fn post_stop(...) {\n        // Final cleanup\n    }\n}\n</code></pre> <p>Congratulations on completing the tutorials! You now understand actors, messaging, and supervision. Ready for production patterns? Check out the How-To Guides!</p>"},{"location":"examples/","title":"Examples","text":"<p>This section provides practical examples demonstrating AirsSys components in real-world scenarios.</p>"},{"location":"examples/#osl-examples","title":"OSL Examples","text":""},{"location":"examples/#secure-file-operations","title":"Secure File Operations","text":"<p>Examples demonstrating OSL's secure file I/O with ACL policies and audit logging.</p> <p>View OSL Examples \u2192</p>"},{"location":"examples/#rt-examples","title":"RT Examples","text":""},{"location":"examples/#actor-systems","title":"Actor Systems","text":"<p>Examples showing how to build actor-based concurrent systems with fault tolerance.</p> <p>View RT Examples \u2192</p>"},{"location":"examples/#integration-examples","title":"Integration Examples","text":""},{"location":"examples/#combined-osl-rt","title":"Combined OSL + RT","text":"<p>Examples integrating both components for complete system programming solutions.</p> <p>Coming soon.</p>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>All examples are included in the repository:</p> <pre><code># Clone the repository\ngit clone https://github.com/airsstack/airssys\ncd airssys\n\n# Run OSL examples\ncargo run --example helper_functions_comprehensive\ncargo run --example security_middleware_comprehensive\ncargo run --example custom_executor_with_macro --features macros\n\n# Run RT examples\ncargo run --example actor_basic\ncargo run --example supervisor_basic\ncargo run --example osl_integration_example\n</code></pre>"},{"location":"examples/#example-categories","title":"Example Categories","text":""},{"location":"examples/#osl-categories","title":"OSL Categories","text":"<ul> <li>Basic operations (read, write, delete)</li> <li>Security middleware configuration</li> <li>Custom executor development</li> <li>Middleware pipelines</li> <li>Logger configuration</li> </ul>"},{"location":"examples/#rt-categories","title":"RT Categories","text":"<ul> <li>Basic actor implementation</li> <li>Supervision patterns</li> <li>Message passing</li> <li>System integration</li> <li>Performance optimization</li> </ul>"},{"location":"examples/#learning-path","title":"Learning Path","text":"<ol> <li>Start simple: Run <code>actor_basic</code> or <code>basic_usage</code></li> <li>Add security: Try <code>security_middleware_comprehensive</code></li> <li>Add supervision: Try <code>supervisor_basic</code></li> <li>Integrate: Try <code>osl_integration_example</code></li> <li>Customize: Try <code>custom_executor_with_macro</code></li> </ol>"},{"location":"examples/#example-code","title":"Example Code","text":"<p>All examples include: - Detailed inline comments - Error handling patterns - Best practices - Performance considerations - Integration patterns</p>"},{"location":"examples/osl-examples/","title":"OSL Examples","text":"<p>Examples demonstrating the OS Layer Framework for secure system operations.</p>"},{"location":"examples/osl-examples/#helper-functions-examples","title":"Helper Functions Examples","text":""},{"location":"examples/osl-examples/#basic-file-operations","title":"Basic File Operations","text":"<pre><code>use airssys_osl::helpers::*;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Write file\n    let data = b\"Hello, AirsSys!\".to_vec();\n    write_file(\"/tmp/test.txt\", data, \"admin\").await?;\n\n    // Read file\n    let content = read_file(\"/tmp/test.txt\", \"admin\").await?;\n    println!(\"Content: {}\", String::from_utf8_lossy(&amp;content));\n\n    // Delete file\n    delete_file(\"/tmp/test.txt\", \"admin\").await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"examples/osl-examples/#process-management","title":"Process Management","text":"<pre><code>use airssys_osl::helpers::*;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Spawn process\n    let output = spawn_process(\n        \"echo\",\n        vec![\"Hello from process!\".to_string()],\n        \"admin\"\n    ).await?;\n\n    println!(\"Output: {}\", String::from_utf8_lossy(&amp;output));\n\n    Ok(())\n}\n</code></pre>"},{"location":"examples/osl-examples/#network-operations","title":"Network Operations","text":"<pre><code>use airssys_osl::helpers::*;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Start TCP listener\n    let listener = network_listen(\"127.0.0.1:0\", \"admin\").await?;\n    println!(\"Listening on: {:?}\", listener.local_addr()?);\n\n    // Connect to server\n    let stream = network_connect(\"127.0.0.1:8080\", \"admin\").await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"examples/osl-examples/#security-examples","title":"Security Examples","text":""},{"location":"examples/osl-examples/#acl-configuration","title":"ACL Configuration","text":"<pre><code>use airssys_osl::middleware::security::*;\nuse airssys_osl::helpers::*;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create ACL policy\n    let acl = AccessControlList::new()\n        .add_entry(AclEntry::new(\n            \"alice\".to_string(),\n            \"/data/*\".to_string(),\n            vec![\"read\".to_string(), \"write\".to_string()],\n            AclPolicy::Allow,\n        ))\n        .add_entry(AclEntry::new(\n            \"bob\".to_string(),\n            \"/data/*\".to_string(),\n            vec![\"read\".to_string()],\n            AclPolicy::Allow,\n        ));\n\n    // Build security middleware\n    let security = SecurityMiddlewareBuilder::new()\n        .add_policy(Box::new(acl))\n        .build()?;\n\n    // Use with helper function\n    let content = read_file_with_middleware(\n        \"/data/file.txt\",\n        \"alice\",\n        security\n    ).await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"examples/osl-examples/#rbac-configuration","title":"RBAC Configuration","text":"<pre><code>use airssys_osl::middleware::security::*;\n\n// Define roles and permissions\nlet rbac = RoleBasedAccessControl::new()\n    .add_role(\"admin\", vec![\"read\", \"write\", \"delete\"])\n    .add_role(\"user\", vec![\"read\"])\n    .add_role_hierarchy(\"admin\", \"user\"); // admin inherits user permissions\n\n// Use in operations\nlet security = SecurityMiddlewareBuilder::new()\n    .add_policy(Box::new(rbac))\n    .build()?;\n</code></pre>"},{"location":"examples/osl-examples/#middleware-examples","title":"Middleware Examples","text":""},{"location":"examples/osl-examples/#logging-configuration","title":"Logging Configuration","text":"<pre><code>use airssys_osl::middleware::logger::*;\nuse airssys_osl::middleware::ExecutorExt;\nuse airssys_osl::executors::filesystem::FilesystemExecutor;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Console logger\n    let console_logger = ConsoleActivityLogger::default();\n    let console_middleware = LoggerMiddleware::with_default_config(console_logger);\n\n    // File logger\n    let file_logger = FileActivityLogger::new(\"/tmp/ops.log\").await?;\n    let file_middleware = LoggerMiddleware::with_default_config(file_logger);\n\n    // Chain middleware\n    let executor = FilesystemExecutor::default()\n        .with_middleware(console_middleware)\n        .with_middleware(file_middleware);\n\n    Ok(())\n}\n</code></pre>"},{"location":"examples/osl-examples/#custom-middleware","title":"Custom Middleware","text":"<pre><code>use airssys_osl::core::middleware::Middleware;\nuse airssys_osl::core::operation::Operation;\nuse airssys_osl::core::context::ExecutionContext;\nuse async_trait::async_trait;\n\nstruct RateLimitMiddleware {\n    max_ops_per_sec: u32,\n}\n\n#[async_trait]\nimpl Middleware for RateLimitMiddleware {\n    async fn process(\n        &amp;self,\n        operation: &amp;dyn Operation,\n        context: &amp;ExecutionContext,\n    ) -&gt; Result&lt;(), OSError&gt; {\n        // Check rate limit\n        // Implementation...\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"examples/osl-examples/#custom-executor-examples","title":"Custom Executor Examples","text":""},{"location":"examples/osl-examples/#with-macros","title":"With Macros","text":"<pre><code>use airssys_osl::prelude::*;\n\n#[executor(operations = [Filesystem])]\nstruct MyCustomExecutor;\n\nimpl MyCustomExecutor {\n    async fn execute_file_read(\n        &amp;self,\n        operation: FileReadOperation,\n        _context: ExecutionContext,\n    ) -&gt; Result&lt;ExecutionResult, OSError&gt; {\n        println!(\"Custom file read: {}\", operation.path());\n        // Implementation...\n        Ok(ExecutionResult::success(vec![]))\n    }\n}\n</code></pre>"},{"location":"examples/osl-examples/#complete-examples","title":"Complete Examples","text":"<p>For complete, runnable examples, see the repository:</p> <pre><code># Comprehensive helper functions demo\ncargo run --example helper_functions_comprehensive\n\n# Security middleware configuration\ncargo run --example security_middleware_comprehensive\n\n# Custom middleware (rate limiting)\ncargo run --example custom_middleware\n\n# Logger configuration\ncargo run --example logger_comprehensive\n\n# Custom executor with macros\ncargo run --example custom_executor_with_macro --features macros\n</code></pre>"},{"location":"examples/osl-examples/#next-steps","title":"Next Steps","text":"<ul> <li>OSL API Reference</li> <li>Security Best Practices</li> <li>RT Examples</li> </ul>"},{"location":"examples/rt-examples/","title":"RT Examples","text":"<p>Examples demonstrating the Actor Runtime for high-concurrency fault-tolerant applications.</p>"},{"location":"examples/rt-examples/#basic-actor-examples","title":"Basic Actor Examples","text":""},{"location":"examples/rt-examples/#simple-counter-actor","title":"Simple Counter Actor","text":"<pre><code>use airssys_rt::prelude::*;\nuse async_trait::async_trait;\n\n#[derive(Debug, Clone)]\nenum CounterMsg {\n    Increment,\n    Decrement,\n    GetCount(tokio::sync::oneshot::Sender&lt;i64&gt;),\n}\n\nimpl Message for CounterMsg {\n    const MESSAGE_TYPE: &amp;'static str = \"counter\";\n}\n\nstruct CounterActor {\n    count: i64,\n}\n\n#[async_trait]\nimpl Actor for CounterActor {\n    type Message = CounterMsg;\n    type Error = std::io::Error;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        msg: Self::Message,\n        _ctx: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        match msg {\n            CounterMsg::Increment =&gt; {\n                self.count += 1;\n                println!(\"Count: {}\", self.count);\n            }\n            CounterMsg::Decrement =&gt; {\n                self.count -= 1;\n                println!(\"Count: {}\", self.count);\n            }\n            CounterMsg::GetCount(reply) =&gt; {\n                let _ = reply.send(self.count);\n            }\n        }\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"examples/rt-examples/#actor-lifecycle","title":"Actor Lifecycle","text":"<pre><code>use airssys_rt::prelude::*;\n\n#[async_trait]\nimpl Actor for MyActor {\n    type Message = MyMsg;\n    type Error = std::io::Error;\n\n    async fn pre_start&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        _ctx: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"Actor starting...\");\n        // Initialize resources\n        Ok(())\n    }\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        msg: Self::Message,\n        _ctx: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        // Process message\n        Ok(())\n    }\n\n    async fn post_stop&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        _ctx: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        println!(\"Actor stopping...\");\n        // Cleanup resources\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"examples/rt-examples/#supervision-examples","title":"Supervision Examples","text":""},{"location":"examples/rt-examples/#basic-supervisor","title":"Basic Supervisor","text":"<pre><code>use airssys_rt::supervisor::*;\nuse airssys_rt::broker::InMemoryMessageBroker;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create message broker\n    let broker = InMemoryMessageBroker::new();\n\n    // Create supervisor with OneForOne strategy\n    let supervisor = SupervisorBuilder::new()\n        .with_strategy(RestartStrategy::OneForOne)\n        .with_max_restarts(3, Duration::from_secs(60))\n        .build();\n\n    // Add child actors\n    supervisor.add_child(\n        \"worker-1\",\n        Box::new(WorkerActor::new()),\n        RestartPolicy::Permanent,\n    ).await?;\n\n    // Start supervision\n    supervisor.start().await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"examples/rt-examples/#supervision-strategies","title":"Supervision Strategies","text":"<pre><code>// OneForOne: Restart only failed child\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .build();\n\n// OneForAll: Restart all children when one fails\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForAll)\n    .build();\n\n// RestForOne: Restart failed child and those started after it\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::RestForOne)\n    .build();\n</code></pre>"},{"location":"examples/rt-examples/#restart-policies","title":"Restart Policies","text":"<pre><code>// Permanent: Always restart\nsupervisor.add_child(\n    \"critical-worker\",\n    Box::new(CriticalActor::new()),\n    RestartPolicy::Permanent,\n).await?;\n\n// Transient: Restart only if abnormal termination\nsupervisor.add_child(\n    \"task-worker\",\n    Box::new(TaskActor::new()),\n    RestartPolicy::Transient,\n).await?;\n\n// Temporary: Never restart\nsupervisor.add_child(\n    \"one-shot\",\n    Box::new(OneShotActor::new()),\n    RestartPolicy::Temporary,\n).await?;\n</code></pre>"},{"location":"examples/rt-examples/#message-passing-examples","title":"Message Passing Examples","text":""},{"location":"examples/rt-examples/#request-reply-pattern","title":"Request-Reply Pattern","text":"<pre><code>#[derive(Debug, Clone)]\nenum QueryMsg {\n    GetData(tokio::sync::oneshot::Sender&lt;Data&gt;),\n}\n\nimpl Message for QueryMsg {\n    const MESSAGE_TYPE: &amp;'static str = \"query\";\n}\n\n// Send request\nlet (tx, rx) = tokio::sync::oneshot::channel();\nbroker.publish(QueryMsg::GetData(tx), address).await?;\n\n// Wait for reply\nlet data = rx.await?;\n</code></pre>"},{"location":"examples/rt-examples/#pub-sub-pattern","title":"Pub-Sub Pattern","text":"<pre><code>// Subscriber 1\nbroker.subscribe(\"events\", subscriber1_address).await?;\n\n// Subscriber 2\nbroker.subscribe(\"events\", subscriber2_address).await?;\n\n// Publisher\nbroker.publish_to_topic(\"events\", Event::new()).await?;\n\n// Both subscribers receive the message\n</code></pre>"},{"location":"examples/rt-examples/#integration-examples","title":"Integration Examples","text":""},{"location":"examples/rt-examples/#osl-integration","title":"OSL Integration","text":"<pre><code>use airssys_rt::supervisor::OSLSupervisor;\nuse airssys_rt::broker::InMemoryMessageBroker;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create broker\n    let broker = InMemoryMessageBroker::new();\n\n    // Create OSL supervisor\n    let supervisor = OSLSupervisor::new(broker.clone());\n    supervisor.start().await?;\n\n    // Now FileSystem, Process, Network actors are running\n    // with full fault tolerance\n\n    println!(\"OSL actors under supervision\");\n\n    // Keep running\n    tokio::time::sleep(Duration::from_secs(3600)).await;\n\n    Ok(())\n}\n</code></pre>"},{"location":"examples/rt-examples/#performance-examples","title":"Performance Examples","text":""},{"location":"examples/rt-examples/#high-throughput-message-processing","title":"High-Throughput Message Processing","text":"<pre><code>use airssys_rt::prelude::*;\nuse std::time::Instant;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let broker = InMemoryMessageBroker::new();\n\n    // Spawn actor\n    let actor = HighThroughputActor::new();\n    let address = ActorAddress::new(\"throughput-test\");\n    spawn_actor(actor, address.clone(), broker.clone()).await?;\n\n    // Send 1M messages\n    let start = Instant::now();\n    for _ in 0..1_000_000 {\n        broker.publish(ProcessMsg::new(), address.clone()).await?;\n    }\n\n    let duration = start.elapsed();\n    let msgs_per_sec = 1_000_000.0 / duration.as_secs_f64();\n\n    println!(\"Throughput: {:.2} msgs/sec\", msgs_per_sec);\n\n    Ok(())\n}\n</code></pre>"},{"location":"examples/rt-examples/#complete-examples","title":"Complete Examples","text":"<p>For complete, runnable examples, see the repository:</p> <pre><code># Basic actor implementation\ncargo run --example actor_basic\n\n# Actor lifecycle hooks\ncargo run --example actor_lifecycle\n\n# Actor patterns (request-reply, pub-sub)\ncargo run --example actor_patterns\n\n# Basic supervision\ncargo run --example supervisor_basic\n\n# Supervision strategies\ncargo run --example supervisor_strategies\n\n# Advanced supervision with health checks\ncargo run --example supervisor_advanced\n\n# OSL integration\ncargo run --example osl_integration_example\n\n# Worker pool pattern\ncargo run --example worker_pool\n\n# Message passing patterns\ncargo run --example message_patterns\n</code></pre>"},{"location":"examples/rt-examples/#next-steps","title":"Next Steps","text":"<ul> <li>RT API Reference</li> <li>RT Architecture</li> <li>OSL Examples</li> <li>Integration Guide</li> </ul>"},{"location":"guides/integration/","title":"Integration Guide","text":"<p>This guide demonstrates how to integrate AirsSys components effectively.</p>"},{"location":"guides/integration/#overview","title":"Overview","text":"<p>AirsSys components can be used independently or combined for powerful system programming solutions:</p> <ul> <li>OSL alone: Secure OS operations</li> <li>RT alone: Actor-based concurrency</li> <li>OSL + RT: Supervised secure operations</li> </ul>"},{"location":"guides/integration/#pattern-1-osl-operations-in-rt-actors","title":"Pattern 1: OSL Operations in RT Actors","text":"<p>Wrap OSL helper functions in RT actors:</p> <pre><code>use airssys_rt::prelude::*;\nuse airssys_osl::helpers::*;\nuse async_trait::async_trait;\n\n#[derive(Debug, Clone)]\nenum FileServiceMsg {\n    ReadFile(String, tokio::sync::oneshot::Sender&lt;Vec&lt;u8&gt;&gt;),\n    WriteFile(String, Vec&lt;u8&gt;),\n}\n\nimpl Message for FileServiceMsg {\n    const MESSAGE_TYPE: &amp;'static str = \"file-service\";\n}\n\nstruct FileServiceActor {\n    principal: String,\n}\n\n#[async_trait]\nimpl Actor for FileServiceActor {\n    type Message = FileServiceMsg;\n    type Error = Box&lt;dyn std::error::Error + Send + Sync&gt;;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        msg: Self::Message,\n        _ctx: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        match msg {\n            FileServiceMsg::ReadFile(path, reply) =&gt; {\n                // Use OSL with security\n                let content = read_file(&amp;path, &amp;self.principal).await?;\n                let _ = reply.send(content);\n            }\n            FileServiceMsg::WriteFile(path, data) =&gt; {\n                write_file(&amp;path, data, &amp;self.principal).await?;\n            }\n        }\n        Ok(())\n    }\n}\n</code></pre> <p>Benefits: - OSL security policies automatically enforced - RT fault tolerance for file operations - Actor isolation prevents shared state issues</p>"},{"location":"guides/integration/#pattern-2-using-oslsupervisor","title":"Pattern 2: Using OSLSupervisor","text":"<p>The built-in <code>OSLSupervisor</code> manages filesystem, process, and network actors:</p> <pre><code>use airssys_rt::supervisor::OSLSupervisor;\nuse airssys_rt::broker::InMemoryMessageBroker;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create shared broker\n    let broker = InMemoryMessageBroker::new();\n\n    // Create OSL supervisor\n    let supervisor = OSLSupervisor::new(broker.clone());\n\n    // Start all OSL actors with supervision\n    supervisor.start().await?;\n\n    // Actors are now running:\n    // - FileSystemActor at \"osl-filesystem\"\n    // - ProcessActor at \"osl-process\"\n    // - NetworkActor at \"osl-network\"\n\n    // They automatically restart on failure (RestForOne strategy)\n\n    println!(\"OSL system running with supervision\");\n\n    // Keep running\n    tokio::signal::ctrl_c().await?;\n\n    Ok(())\n}\n</code></pre> <p>Architecture: <pre><code>OSLSupervisor (RestForOne)\n     \u251c\u2500\u2192 FileSystemActor\n     \u251c\u2500\u2192 ProcessActor\n     \u2514\u2500\u2192 NetworkActor\n</code></pre></p>"},{"location":"guides/integration/#pattern-3-custom-security-in-rt-actors","title":"Pattern 3: Custom Security in RT Actors","text":"<p>Use OSL middleware directly in RT actors:</p> <pre><code>use airssys_rt::prelude::*;\nuse airssys_osl::middleware::security::*;\n\nstruct SecureActor {\n    security: SecurityMiddleware,\n}\n\n#[async_trait]\nimpl Actor for SecureActor {\n    type Message = SecureMsg;\n    type Error = Box&lt;dyn std::error::Error + Send + Sync&gt;;\n\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        msg: Self::Message,\n        _ctx: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        // Check security before processing\n        self.security.check_access(&amp;msg.resource, &amp;msg.principal)?;\n\n        // Process message\n        // ...\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"guides/integration/#pattern-4-hierarchical-supervision-with-osl","title":"Pattern 4: Hierarchical Supervision with OSL","text":"<p>Build supervision trees with OSL operations at leaves:</p> <pre><code>use airssys_rt::supervisor::*;\n\n// Root supervisor\nlet root = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)\n    .build();\n\n// Add OSL supervisor as child\nlet osl_supervisor = OSLSupervisor::new(broker.clone());\nroot.add_child(\"osl\", Box::new(osl_supervisor), RestartPolicy::Permanent).await?;\n\n// Add application supervisor as child\nlet app_supervisor = AppSupervisor::new(broker.clone());\nroot.add_child(\"app\", Box::new(app_supervisor), RestartPolicy::Permanent).await?;\n\n// Start entire tree\nroot.start().await?;\n</code></pre> <p>Architecture: <pre><code>RootSupervisor\n  \u251c\u2500\u2192 OSLSupervisor\n  \u2502     \u251c\u2500\u2192 FileSystemActor\n  \u2502     \u251c\u2500\u2192 ProcessActor\n  \u2502     \u2514\u2500\u2192 NetworkActor\n  \u2514\u2500\u2192 AppSupervisor\n        \u251c\u2500\u2192 BusinessActor1\n        \u2514\u2500\u2192 BusinessActor2\n</code></pre></p>"},{"location":"guides/integration/#pattern-5-message-based-os-operations","title":"Pattern 5: Message-Based OS Operations","text":"<p>Define operation messages for OSL actors:</p> <pre><code>#[derive(Debug, Clone)]\nenum OSLMessage {\n    FileRead { path: String, reply: Sender&lt;Vec&lt;u8&gt;&gt; },\n    FileWrite { path: String, data: Vec&lt;u8&gt; },\n    ProcessSpawn { cmd: String, args: Vec&lt;String&gt; },\n}\n\nimpl Message for OSLMessage {\n    const MESSAGE_TYPE: &amp;'static str = \"osl\";\n}\n\n// Send message to OSL actor\nbroker.publish(\n    OSLMessage::FileRead {\n        path: \"/tmp/test.txt\".to_string(),\n        reply: tx,\n    },\n    ActorAddress::new(\"osl-filesystem\"),\n).await?;\n</code></pre>"},{"location":"guides/integration/#integration-checklist","title":"Integration Checklist","text":""},{"location":"guides/integration/#for-osl-rt-integration","title":"For OSL + RT Integration","text":"<ul> <li> Create shared message broker</li> <li> Define message types for OS operations</li> <li> Create OSL actors or use OSLSupervisor</li> <li> Configure security policies</li> <li> Set up supervision strategies</li> <li> Add monitoring/logging</li> <li> Test failure recovery</li> </ul>"},{"location":"guides/integration/#security-considerations","title":"Security Considerations","text":"<ul> <li> OSL security policies configured</li> <li> Principals assigned to actors</li> <li> Audit logging enabled</li> <li> Actor isolation verified</li> <li> No shared mutable state</li> </ul>"},{"location":"guides/integration/#performance-considerations","title":"Performance Considerations","text":"<ul> <li> Mailbox sizes tuned</li> <li> Backpressure strategy chosen</li> <li> Message batching where appropriate</li> <li> Monitoring metrics collected</li> </ul>"},{"location":"guides/integration/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/integration/#request-reply-with-osl","title":"Request-Reply with OSL","text":"<pre><code>// Actor receives request\nasync fn handle_message(&amp;mut self, msg: Msg) {\n    match msg {\n        Msg::GetFile(path, reply) =&gt; {\n            // Use OSL\n            let content = read_file(&amp;path, &amp;self.principal).await?;\n            // Send reply\n            let _ = reply.send(content);\n        }\n    }\n}\n</code></pre>"},{"location":"guides/integration/#fire-and-forget-with-osl","title":"Fire-and-Forget with OSL","text":"<pre><code>async fn handle_message(&amp;mut self, msg: Msg) {\n    match msg {\n        Msg::LogEvent(event) =&gt; {\n            // Use OSL asynchronously\n            write_file(&amp;log_path, event.as_bytes(), \"logger\").await?;\n            // No reply needed\n        }\n    }\n}\n</code></pre>"},{"location":"guides/integration/#streaming-with-osl","title":"Streaming with OSL","text":"<pre><code>async fn handle_message(&amp;mut self, msg: Msg) {\n    match msg {\n        Msg::StreamFile(path) =&gt; {\n            // Read in chunks\n            let mut offset = 0;\n            loop {\n                let chunk = read_file_chunk(&amp;path, offset, 4096).await?;\n                if chunk.is_empty() {\n                    break;\n                }\n                // Process chunk\n                offset += chunk.len();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"guides/integration/#testing-integration","title":"Testing Integration","text":""},{"location":"guides/integration/#unit-testing","title":"Unit Testing","text":"<p>Test actors independently:</p> <pre><code>#[tokio::test]\nasync fn test_file_service_actor() {\n    let broker = InMemoryMessageBroker::new();\n    let actor = FileServiceActor::new(\"test-user\");\n    // Test actor behavior\n}\n</code></pre>"},{"location":"guides/integration/#integration-testing","title":"Integration Testing","text":"<p>Test complete system:</p> <pre><code>#[tokio::test]\nasync fn test_osl_supervision() {\n    let broker = InMemoryMessageBroker::new();\n    let supervisor = OSLSupervisor::new(broker.clone());\n    supervisor.start().await.unwrap();\n\n    // Test operations work\n    // Test failure recovery\n}\n</code></pre>"},{"location":"guides/integration/#best-practices","title":"Best Practices","text":"<ol> <li>Use OSLSupervisor for standard OS operations</li> <li>Define clear message types for operations</li> <li>Configure security policies before starting actors</li> <li>Enable monitoring for production systems</li> <li>Test failure scenarios to verify recovery</li> <li>Document supervision trees for maintenance</li> </ol>"},{"location":"guides/integration/#next-steps","title":"Next Steps","text":"<ul> <li>Security Guide</li> <li>Performance Guide</li> <li>Examples</li> </ul>"},{"location":"guides/performance/","title":"Performance Guide","text":"<p>Performance optimization strategies for AirsSys components.</p>"},{"location":"guides/performance/#osl-performance","title":"OSL Performance","text":""},{"location":"guides/performance/#operation-overhead","title":"Operation Overhead","text":"<p>OSL adds minimal overhead for security and logging:</p> <ul> <li>Helper functions: ~100\u03bcs total overhead</li> <li>Logger middleware: ~10\u03bcs per middleware</li> <li>Security checks: ~50\u03bcs for ACL/RBAC</li> <li>Executor: Direct OS call performance</li> </ul>"},{"location":"guides/performance/#optimization-strategies","title":"Optimization Strategies","text":"<p>1. Disable unnecessary logging:</p> <pre><code>let logger_config = LoggerConfig {\n    log_success: false,  // Only log failures\n    log_failures: true,\n    include_duration: false,\n    ..Default::default()\n};\n</code></pre> <p>2. Use simpler security policies:</p> <pre><code>// Faster: Direct ACL match\nlet acl = AccessControlList::new()\n    .add_entry(AclEntry::new(user, \"/exact/path.txt\", perms, Allow));\n\n// Slower: Glob pattern matching\nlet acl = AccessControlList::new()\n    .add_entry(AclEntry::new(user, \"/data/**/*.txt\", perms, Allow));\n</code></pre> <p>3. Batch operations:</p> <pre><code>// Slower: Many small operations\nfor file in files {\n    write_file(&amp;file.path, file.data, principal).await?;\n}\n\n// Faster: Batch with single security check\nlet batch_op = BatchWriteOperation::new(files);\nexecutor.execute(batch_op, context).await?;\n</code></pre>"},{"location":"guides/performance/#rt-performance","title":"RT Performance","text":""},{"location":"guides/performance/#baseline-performance","title":"Baseline Performance","text":"<p>From RT-TASK-008 benchmarks (Oct 16, 2025):</p> <ul> <li>Actor spawn: ~625ns (single), ~681ns/actor (batch of 10)</li> <li>Message throughput: 4.7M messages/sec</li> <li>Message latency: &lt;1ms p99</li> <li>Mailbox operations: ~182ns per message</li> </ul>"},{"location":"guides/performance/#tuning-mailbox-sizes","title":"Tuning Mailbox Sizes","text":"<pre><code>use airssys_rt::mailbox::*;\n\n// Small mailbox: Lower memory, more backpressure\nlet mailbox = BoundedMailbox::new(100);\n\n// Large mailbox: Higher memory, less backpressure\nlet mailbox = BoundedMailbox::new(10000);\n\n// Unbounded: No backpressure (use with caution)\nlet mailbox = UnboundedMailbox::new();\n</code></pre>"},{"location":"guides/performance/#choosing-backpressure-strategy","title":"Choosing Backpressure Strategy","text":"<pre><code>use airssys_rt::mailbox::BackpressureStrategy;\n\n// Block: Wait for space (preserves order)\nlet config = MailboxConfig {\n    strategy: BackpressureStrategy::Block,\n    capacity: 1000,\n};\n\n// Drop: Discard new messages (best-effort)\nlet config = MailboxConfig {\n    strategy: BackpressureStrategy::Drop,\n    capacity: 1000,\n};\n\n// Reject: Return error (explicit failure)\nlet config = MailboxConfig {\n    strategy: BackpressureStrategy::Reject,\n    capacity: 1000,\n};\n</code></pre>"},{"location":"guides/performance/#message-batching","title":"Message Batching","text":"<pre><code>// Slower: Process one-by-one\nfor msg in messages {\n    broker.publish(msg, address.clone()).await?;\n}\n\n// Faster: Batch messages\nbroker.publish_batch(messages, address).await?;\n</code></pre>"},{"location":"guides/performance/#actor-pool-pattern","title":"Actor Pool Pattern","text":"<pre><code>// Create worker pool\nlet pool_size = num_cpus::get();\nlet mut workers = Vec::new();\n\nfor i in 0..pool_size {\n    let worker = WorkerActor::new();\n    let address = ActorAddress::new(format!(\"worker-{}\", i));\n    spawn_actor(worker, address.clone(), broker.clone()).await?;\n    workers.push(address);\n}\n\n// Round-robin distribution\nlet mut idx = 0;\nfor msg in messages {\n    broker.publish(msg, workers[idx].clone()).await?;\n    idx = (idx + 1) % pool_size;\n}\n</code></pre>"},{"location":"guides/performance/#monitoring-performance","title":"Monitoring Performance","text":""},{"location":"guides/performance/#osl-metrics","title":"OSL Metrics","text":"<pre><code>let logger = FileActivityLogger::new(\"/var/log/metrics.log\").await?;\nlet middleware = LoggerMiddleware::with_config(\n    logger,\n    LoggerConfig {\n        include_duration: true,  // Log operation duration\n        ..Default::default()\n    }\n);\n</code></pre>"},{"location":"guides/performance/#rt-metrics","title":"RT Metrics","text":"<pre><code>use airssys_rt::monitoring::*;\n\nlet monitor = InMemoryMonitor::new();\n\n// Query metrics\nlet metrics = monitor.get_mailbox_metrics(&amp;address)?;\nprintln!(\"Queue depth: {}\", metrics.queue_depth);\nprintln!(\"Messages processed: {}\", metrics.total_processed);\nprintln!(\"Average latency: {}ms\", metrics.avg_latency_ms);\n</code></pre>"},{"location":"guides/performance/#profiling","title":"Profiling","text":""},{"location":"guides/performance/#cpu-profiling","title":"CPU Profiling","text":"<pre><code># Build with debugging symbols\ncargo build --release --features debug\n\n# Profile with perf (Linux)\nperf record --call-graph=dwarf ./target/release/my-app\nperf report\n\n# Profile with Instruments (macOS)\ninstruments -t \"Time Profiler\" ./target/release/my-app\n</code></pre>"},{"location":"guides/performance/#memory-profiling","title":"Memory Profiling","text":"<pre><code># Use valgrind (Linux)\nvalgrind --tool=massif ./target/release/my-app\n\n# Use heaptrack (Linux)\nheaptrack ./target/release/my-app\n</code></pre>"},{"location":"guides/performance/#benchmarking","title":"Benchmarking","text":""},{"location":"guides/performance/#osl-benchmarks","title":"OSL Benchmarks","text":"<pre><code>cd airssys-osl\ncargo bench\n</code></pre>"},{"location":"guides/performance/#rt-benchmarks","title":"RT Benchmarks","text":"<pre><code>cd airssys-rt\ncargo bench\n\n# Specific benchmarks\ncargo bench --bench actor_benchmarks\ncargo bench --bench message_benchmarks\ncargo bench --bench supervisor_benchmarks\n</code></pre>"},{"location":"guides/performance/#performance-checklist","title":"Performance Checklist","text":""},{"location":"guides/performance/#before-optimization","title":"Before Optimization","text":"<ul> <li> Profile to identify bottlenecks</li> <li> Measure current performance</li> <li> Set performance targets</li> <li> Identify critical paths</li> </ul>"},{"location":"guides/performance/#optimization-strategies_1","title":"Optimization Strategies","text":"<ul> <li> Tune mailbox sizes</li> <li> Choose appropriate backpressure strategy</li> <li> Batch operations where possible</li> <li> Use actor pools for parallelism</li> <li> Minimize logging in hot paths</li> <li> Simplify security policies if possible</li> </ul>"},{"location":"guides/performance/#after-optimization","title":"After Optimization","text":"<ul> <li> Verify performance improvements</li> <li> Test under load</li> <li> Monitor in production</li> <li> Document configuration</li> </ul>"},{"location":"guides/performance/#next-steps","title":"Next Steps","text":"<ul> <li>Integration Guide</li> <li>Security Guide</li> <li>RT Benchmarking Details</li> </ul>"},{"location":"guides/security/","title":"Security Guide","text":"<p>Security best practices for AirsSys components.</p>"},{"location":"guides/security/#osl-security-model","title":"OSL Security Model","text":""},{"location":"guides/security/#deny-by-default","title":"Deny-by-Default","text":"<p>All operations are denied by default unless explicitly allowed by security policies.</p> <pre><code>// Without policy - operation denied\nlet result = read_file(\"/data/secret.txt\", \"user\").await;\n// Error: Access denied\n\n// With policy - operation allowed\nlet acl = AccessControlList::new()\n    .add_entry(AclEntry::new(\n        \"user\".to_string(),\n        \"/data/*\".to_string(),\n        vec![\"read\".to_string()],\n        AclPolicy::Allow,\n    ));\n</code></pre>"},{"location":"guides/security/#access-control-lists-acl","title":"Access Control Lists (ACL)","text":"<p>Path-based access control with glob patterns:</p> <pre><code>use airssys_osl::middleware::security::*;\n\nlet acl = AccessControlList::new()\n    // Allow read/write to /tmp\n    .add_entry(AclEntry::new(\n        \"alice\".to_string(),\n        \"/tmp/*\".to_string(),\n        vec![\"read\".to_string(), \"write\".to_string()],\n        AclPolicy::Allow,\n    ))\n    // Allow read-only to /data\n    .add_entry(AclEntry::new(\n        \"alice\".to_string(),\n        \"/data/**\".to_string(),\n        vec![\"read\".to_string()],\n        AclPolicy::Allow,\n    ))\n    // Explicitly deny sensitive files\n    .add_entry(AclEntry::new(\n        \"alice\".to_string(),\n        \"/data/sensitive/*\".to_string(),\n        vec![\"read\".to_string(), \"write\".to_string()],\n        AclPolicy::Deny,  // Deny takes precedence\n    ));\n</code></pre>"},{"location":"guides/security/#role-based-access-control-rbac","title":"Role-Based Access Control (RBAC)","text":"<p>Role hierarchies with permission inheritance:</p> <pre><code>let rbac = RoleBasedAccessControl::new()\n    // Define roles\n    .add_role(\"admin\", vec![\"read\", \"write\", \"delete\", \"execute\"])\n    .add_role(\"developer\", vec![\"read\", \"write\", \"execute\"])\n    .add_role(\"operator\", vec![\"read\", \"execute\"])\n    .add_role(\"viewer\", vec![\"read\"])\n\n    // Define role hierarchy (inheritance)\n    .add_role_hierarchy(\"admin\", \"developer\")\n    .add_role_hierarchy(\"developer\", \"operator\")\n    .add_role_hierarchy(\"operator\", \"viewer\");\n\n// Assign user to role\nrbac.assign_user(\"alice\", \"developer\")?;\n\n// alice inherits: read, write, execute (from developer)\n//                 + read (from operator via hierarchy)\n//                 + read (from viewer via hierarchy)\n</code></pre>"},{"location":"guides/security/#combining-policies","title":"Combining Policies","text":"<p>Multiple policies can be combined:</p> <pre><code>let security = SecurityMiddlewareBuilder::new()\n    .add_policy(Box::new(acl))\n    .add_policy(Box::new(rbac))\n    .add_policy(Box::new(rate_limiter))\n    .build()?;\n\n// All policies must allow the operation\n</code></pre>"},{"location":"guides/security/#rt-security-model","title":"RT Security Model","text":""},{"location":"guides/security/#actor-isolation","title":"Actor Isolation","text":"<p>Actors have private state enforced by Rust ownership:</p> <pre><code>struct BankAccount {\n    balance: i64,  // Private, cannot be accessed by other actors\n}\n\n// Other actors CANNOT:\n// - Read balance directly\n// - Modify balance directly\n// - Share references to balance\n\n// Other actors CAN:\n// - Send messages to request balance\n// - Send messages to request transfers\n</code></pre>"},{"location":"guides/security/#message-validation","title":"Message Validation","text":"<p>Validate messages before processing:</p> <pre><code>#[async_trait]\nimpl Actor for SecureActor {\n    async fn handle_message&lt;B: MessageBroker&lt;Self::Message&gt;&gt;(\n        &amp;mut self,\n        msg: Self::Message,\n        _ctx: &amp;mut ActorContext&lt;Self::Message, B&gt;,\n    ) -&gt; Result&lt;(), Self::Error&gt; {\n        // Validate message\n        if !self.validate_message(&amp;msg) {\n            return Err(\"Invalid message\".into());\n        }\n\n        // Process message\n        // ...\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"guides/security/#supervisor-security","title":"Supervisor Security","text":"<p>Supervisors enforce fault isolation:</p> <pre><code>// Failed actor is isolated and restarted\n// Failure does NOT propagate to siblings\nlet supervisor = SupervisorBuilder::new()\n    .with_strategy(RestartStrategy::OneForOne)  // Isolate failures\n    .with_max_restarts(3, Duration::from_secs(60))\n    .build();\n</code></pre>"},{"location":"guides/security/#audit-logging","title":"Audit Logging","text":""},{"location":"guides/security/#osl-audit-trails","title":"OSL Audit Trails","text":"<p>All operations are logged:</p> <pre><code>{\n  \"timestamp\": \"2025-12-10T10:30:00Z\",\n  \"principal\": \"alice\",\n  \"operation\": \"FileRead\",\n  \"resource\": \"/data/customer_data.csv\",\n  \"result\": \"allowed\",\n  \"policy\": \"acl:data-read\",\n  \"duration_ms\": 15\n}\n</code></pre> <p>Configure logging:</p> <pre><code>use airssys_osl::middleware::logger::*;\n\nlet logger = FileActivityLogger::new(\"/var/log/airssys/audit.log\").await?;\nlet middleware = LoggerMiddleware::with_config(\n    logger,\n    LoggerConfig {\n        log_success: true,\n        log_failures: true,\n        include_principal: true,\n        include_duration: true,\n    }\n);\n</code></pre>"},{"location":"guides/security/#rt-event-monitoring","title":"RT Event Monitoring","text":"<p>Monitor actor events:</p> <pre><code>use airssys_rt::monitoring::*;\n\nlet monitor = InMemoryMonitor::new();\n\n// Events logged:\n// - Actor spawned\n// - Actor stopped\n// - Message sent\n// - Message received\n// - Supervision events\n// - Health check results\n</code></pre>"},{"location":"guides/security/#security-best-practices","title":"Security Best Practices","text":""},{"location":"guides/security/#principle-of-least-privilege","title":"Principle of Least Privilege","text":"<p>Grant minimum required permissions:</p> <pre><code>// \u274c Bad: Overly permissive\nlet acl = AccessControlList::new()\n    .add_entry(AclEntry::new(\n        \"app\".to_string(),\n        \"/**\".to_string(),  // Access to everything!\n        vec![\"read\".to_string(), \"write\".to_string(), \"delete\".to_string()],\n        AclPolicy::Allow,\n    ));\n\n// \u2705 Good: Specific permissions\nlet acl = AccessControlList::new()\n    .add_entry(AclEntry::new(\n        \"app\".to_string(),\n        \"/app/data/*\".to_string(),  // Only app data\n        vec![\"read\".to_string(), \"write\".to_string()],  // No delete\n        AclPolicy::Allow,\n    ));\n</code></pre>"},{"location":"guides/security/#defense-in-depth","title":"Defense in Depth","text":"<p>Layer multiple security mechanisms:</p> <pre><code>let security = SecurityMiddlewareBuilder::new()\n    .add_policy(Box::new(acl))        // Path-based control\n    .add_policy(Box::new(rbac))       // Role-based control\n    .add_policy(Box::new(rate_limit)) // Rate limiting\n    .add_policy(Box::new(time_based)) // Time-based access\n    .build()?;\n</code></pre>"},{"location":"guides/security/#secure-defaults","title":"Secure Defaults","text":"<p>Use secure defaults:</p> <pre><code>// Default security included in helpers\nread_file(path, principal).await?;  // \u2705 Security checked\n\n// Explicit security for custom use\nread_file_with_middleware(path, principal, security).await?;  // \u2705 Custom policy\n</code></pre>"},{"location":"guides/security/#input-validation","title":"Input Validation","text":"<p>Validate all inputs:</p> <pre><code>fn validate_path(path: &amp;str) -&gt; Result&lt;(), Error&gt; {\n    // Check path traversal\n    if path.contains(\"..\") {\n        return Err(\"Path traversal detected\");\n    }\n\n    // Check absolute path\n    if !path.starts_with(\"/\") {\n        return Err(\"Absolute path required\");\n    }\n\n    // Check allowed directory\n    if !path.starts_with(\"/app/data\") {\n        return Err(\"Path not in allowed directory\");\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/security/#error-handling","title":"Error Handling","text":"<p>Don't leak sensitive information in errors:</p> <pre><code>// \u274c Bad: Leaks path details\nreturn Err(format!(\"Failed to read {}\", full_system_path));\n\n// \u2705 Good: Generic error\nreturn Err(\"File operation failed\");\n\n// \u2705 Good: Log details, return generic error\nlog::error!(\"Failed to read {}\", full_system_path);\nreturn Err(\"File operation failed\");\n</code></pre>"},{"location":"guides/security/#compliance-considerations","title":"Compliance Considerations","text":""},{"location":"guides/security/#soc-2-hipaa-gdpr","title":"SOC 2 / HIPAA / GDPR","text":"<p>AirsSys provides features for compliance:</p> <ul> <li>Audit logs: Complete operation history</li> <li>Access control: Granular permissions</li> <li>Data isolation: Actor-based separation</li> <li>Encryption: Use with file encryption middleware</li> <li>Retention: Configurable log retention</li> </ul> <p>Example compliance configuration:</p> <pre><code>// Audit logging for compliance\nlet audit_logger = FileActivityLogger::new(\"/audit/operations.log\").await?;\nlet audit_middleware = LoggerMiddleware::with_config(\n    audit_logger,\n    LoggerConfig {\n        log_success: true,\n        log_failures: true,\n        include_principal: true,\n        include_duration: true,\n    }\n);\n\n// Access control for data protection\nlet acl = AccessControlList::new()\n    .add_entry(AclEntry::new(\n        \"medical_staff\".to_string(),\n        \"/medical/records/**\".to_string(),\n        vec![\"read\".to_string()],\n        AclPolicy::Allow,\n    ));\n\n// Combine for compliance\nlet security = SecurityMiddlewareBuilder::new()\n    .add_middleware(audit_middleware)\n    .add_policy(Box::new(acl))\n    .build()?;\n</code></pre>"},{"location":"guides/security/#security-checklist","title":"Security Checklist","text":""},{"location":"guides/security/#before-deployment","title":"Before Deployment","text":"<ul> <li> Security policies configured</li> <li> Audit logging enabled</li> <li> Log files secured (permissions)</li> <li> Error messages don't leak sensitive data</li> <li> Input validation implemented</li> <li> Least privilege principle applied</li> <li> Security policies tested</li> <li> Failure scenarios tested</li> </ul>"},{"location":"guides/security/#during-operation","title":"During Operation","text":"<ul> <li> Monitor audit logs</li> <li> Review access patterns</li> <li> Update security policies as needed</li> <li> Rotate log files</li> <li> Review and respond to security events</li> </ul>"},{"location":"guides/security/#next-steps","title":"Next Steps","text":"<ul> <li>Integration Guide</li> <li>Performance Guide</li> <li>OSL Security Reference</li> </ul>"},{"location":"research/","title":"Research Documentation","text":"<p>This section contains research and analysis documentation for AirsSys components.</p>"},{"location":"research/#overview","title":"Overview","text":"<p>The research documentation captures the design decisions, architectural explorations, and technical analyses that inform AirsSys component development.</p>"},{"location":"research/#rt-actor-runtime-research","title":"RT (Actor Runtime) Research","text":""},{"location":"research/#beam-model-analysis","title":"BEAM Model Analysis","text":"<p>BEAM Model Analysis</p> <p>In-depth analysis of the BEAM virtual machine's actor model, supervision patterns, and fault tolerance mechanisms that inspired airssys-rt.</p> <p>Key topics: - BEAM virtual machine architecture - Process model and scheduling - Supervision tree patterns - Fault tolerance philosophy (\"let it crash\") - Message passing implementation</p>"},{"location":"research/#beam-inspired-runtime","title":"BEAM-Inspired Runtime","text":"<p>BEAM-Inspired Runtime Design</p> <p>Exploration of how BEAM concepts translate to a Rust-native actor runtime.</p> <p>Key topics: - Adapting BEAM patterns to Rust - Zero-cost abstractions vs. BEAM's dynamic approach - Ownership and borrowing in actor systems - Supervision strategies in Rust - Performance characteristics</p>"},{"location":"research/#rust-actor-ecosystem","title":"Rust Actor Ecosystem","text":"<p>Rust Actor Ecosystem Analysis</p> <p>Survey of existing Rust actor frameworks and how airssys-rt differentiates itself.</p> <p>Key topics: - Actix: Production-proven actor framework - Tokio actors: Lightweight task-based approach - Bastion: Erlang-inspired supervision - Actor model implementations comparison - Design decisions for airssys-rt</p>"},{"location":"research/#research-topics-by-component","title":"Research Topics by Component","text":""},{"location":"research/#osl-research","title":"OSL Research","text":"<p>Research documentation for OSL is coming soon as the component matures.</p> <p>Topics to be covered: - Cross-platform OS abstraction patterns - Security policy enforcement mechanisms - Middleware pipeline architectures - Audit logging strategies</p>"},{"location":"research/#rt-research","title":"RT Research","text":"<p>Completed research: - \u2705 BEAM model analysis - \u2705 BEAM-inspired runtime design - \u2705 Rust actor ecosystem survey - \u2705 Performance characteristics - \u2705 Zero-cost abstraction patterns</p>"},{"location":"research/#using-research-documentation","title":"Using Research Documentation","text":""},{"location":"research/#for-component-users","title":"For Component Users","text":"<p>Research documentation helps you understand: - Why design decisions were made - What alternatives were considered - How components compare to similar systems - When to use specific patterns</p>"},{"location":"research/#for-contributors","title":"For Contributors","text":"<p>Research documentation provides: - Context for architectural decisions - Rationale behind implementation choices - Background on problem domain - References to related work</p>"},{"location":"research/#research-process","title":"Research Process","text":"<p>Our research process follows these principles:</p> <ol> <li>Problem Definition: Clearly state the problem being solved</li> <li>Survey Existing Solutions: Analyze existing approaches</li> <li>Design Exploration: Consider multiple design alternatives</li> <li>Prototype &amp; Evaluate: Build prototypes and measure performance</li> <li>Documentation: Capture findings and rationale</li> <li>Iteration: Refine based on feedback and testing</li> </ol>"},{"location":"research/#contributing-research","title":"Contributing Research","text":"<p>To contribute research documentation:</p> <ol> <li>Create research documents in markdown</li> <li>Include clear problem statements</li> <li>Analyze alternatives thoroughly</li> <li>Provide concrete examples</li> <li>Include performance data where relevant</li> <li>Reference related work</li> </ol> <p>See Contributing Guide for details.</p>"},{"location":"research/#additional-resources","title":"Additional Resources","text":""},{"location":"research/#external-research","title":"External Research","text":"<p>Recommended reading for understanding AirsSys design:</p> <p>Actor Model: - Carl Hewitt: \"Actor Model of Computation\" (1973) - Joe Armstrong: \"Making Reliable Distributed Systems\" (2003) - Gul Agha: \"Actors: A Model of Concurrent Computation\" (1986)</p> <p>BEAM/Erlang: - Joe Armstrong: \"Programming Erlang\" (2<sup>nd</sup> ed, 2013) - Francesco Cesarini &amp; Simon Thompson: \"Erlang Programming\" (2009) - BEAM Book: https://blog.stenmans.org/theBeamBook/</p> <p>Rust Concurrency: - Jon Gjengset: \"Rust for Rustaceans\" (Chapter 9: Concurrency) - Aaron Turon: \"Designing Futures for Rust\" - Tokio Documentation: https://tokio.rs</p>"},{"location":"research/#performance-studies","title":"Performance Studies","text":"<ul> <li>RT Benchmarking: See <code>BENCHMARKING.md</code> in airssys-rt</li> <li>BEAM Performance: \"Erlang Performance\" papers</li> <li>Actor System Benchmarks: Various actor framework comparisons</li> </ul>"},{"location":"research/#next-steps","title":"Next Steps","text":"<ul> <li>RT BEAM Model Analysis</li> <li>RT BEAM-Inspired Runtime</li> <li>RT Rust Actor Ecosystem</li> <li>Contributing</li> </ul>"},{"location":"research/rt/beam-inspired-runtime/","title":"Architecting a BEAM-Inspired Runtime in Rust: A Foundational Analysis and Practical Implementation Guide","text":""},{"location":"research/rt/beam-inspired-runtime/#i-introduction-the-architectural-blueprint-for-a-beam-like-runtime-in-rust","title":"I. Introduction: The Architectural Blueprint for a BEAM-like Runtime in Rust","text":"<p>This report presents a comprehensive architectural analysis and practical implementation guide for the development of a high-concurrency, fault-tolerant runtime in Rust, modeled on the principles of the Erlang Run-Time System (ERTS) and its virtual machine, the BEAM. The endeavor to create such a system is ambitious, seeking to merge the battle-tested concurrency and resilience philosophy of Erlang with the performance, memory safety, and systems-level control offered by Rust. This document serves as a foundational knowledge base, dissecting the target architecture of the BEAM, surveying the analogous landscape within the Rust ecosystem, and synthesizing these findings into a concrete roadmap for implementation.</p> <p>The Erlang ecosystem, born from the demanding world of telecommunications, is built upon a distinct philosophy centered on reliability and massive concurrency. Its core tenets include the actor model for concurrent computation, a \"let it crash\" approach to fault tolerance where failures are isolated and handled by external supervisors, and high-availability features such as hot code loading that permit system updates without downtime. This philosophy is embodied in the BEAM virtual machine, a sophisticated piece of engineering that manages millions of lightweight, isolated processes with a preemptive scheduler to ensure fairness and responsiveness.</p> <p>In contrast, the Rust paradigm emphasizes a different form of resilience, rooted in compile-time guarantees. Its powerful type system, ownership model, and borrow checker eliminate entire classes of memory-related bugs, providing a robust foundation for building reliable software.5 Rust's philosophy of zero-cost abstractions ensures that these safety guarantees do not come at the expense of performance, making it an ideal language for systems programming. However, Rust lacks a built-in, managed runtime of the BEAM's complexity; its approach to application-level fault tolerance relies on library-based patterns rather than inherent properties of the execution environment.</p> <p>The central thesis of this report is that while a direct, one-to-one replication of the BEAM in Rust presents significant architectural challenges, a functionally equivalent and idiomatically Rust-based runtime is not only achievable but also holds the potential for creating a uniquely powerful system. Such a system would leverage Rust's performance and safety while adopting the BEAM's proven strategies for managing large-scale, fault-tolerant applications. This report will first deconstruct the BEAM's architecture to establish a clear blueprint. It will then analyze the current state of the Rust concurrency landscape to identify existing patterns and tools. Finally, it will synthesize these two domains to provide a practical roadmap, highlighting the critical design trade-offs and architectural decisions required for this undertaking.</p>"},{"location":"research/rt/beam-inspired-runtime/#ii-the-erlang-run-time-system-erts-a-foundational-analysis","title":"II. The Erlang Run-Time System (ERTS): A Foundational Analysis","text":"<p>To construct a BEAM-inspired runtime, one must first possess a deep and nuanced understanding of the original. The BEAM is not merely a collection of features but a holistic, synergistic system where each component is designed to reinforce the others in service of a singular goal: building massively concurrent, highly available, and fault-tolerant software. This section provides a foundational analysis of the ERTS and its core components.</p>"},{"location":"research/rt/beam-inspired-runtime/#21-the-actor-model-and-the-let-it-crash-philosophy","title":"2.1 The Actor Model and the \"Let it Crash\" Philosophy","text":"<p>At the heart of Erlang's concurrency model lies the Actor Model of computation.8 An actor is the fundamental unit of computation, a self-contained entity that encapsulates both state and behavior. The principles of the model are simple but profound:</p> <ul> <li>Encapsulation: An actor maintains its own private, internal state that cannot be directly accessed or modified by any other actor.</li> <li>Asynchronous Message Passing: Actors communicate exclusively by sending and receiving immutable messages asynchronously. There is no shared memory, which eliminates the need for complex and error-prone synchronization mechanisms like locks, thereby preventing race conditions by design.</li> <li>Mailbox and Sequential Processing: Each actor has a \"mailbox\" that queues incoming messages. The actor processes these messages one at a time, in a sequential manner, ensuring that its internal state is always consistent.</li> </ul> <p>This model of complete isolation is the bedrock upon which Erlang's famous \"let it crash\" philosophy is built. Instead of engaging in defensive programming\u2014where code is filled with complex <code>try-catch</code> blocks and error-checking logic to handle every conceivable failure\u2014Erlang/OTP encourages developers to write the \"happy path\" code and allow processes to fail when an unexpected error occurs. A process crash is treated as a clean, isolated event. The responsibility for recovery is not placed on the failing process itself but is delegated to a separate, dedicated \"supervisor\" process. This supervisor's sole job is to monitor its child processes and restart them according to a predefined strategy when they fail. This architectural pattern simplifies application logic immensely, moving the concern of fault tolerance from the individual component level to the system's structural level.</p>"},{"location":"research/rt/beam-inspired-runtime/#22-architectural-overview-of-the-beam-virtual-machine","title":"2.2 Architectural Overview of the BEAM Virtual Machine","text":"<p>The BEAM, which stands for Bogdan's (or Bj\u00f6rn's) Erlang Abstract Machine, is the high-performance, production-grade virtual machine at the core of the Erlang Run-Time System (ERTS). It was developed at Ericsson to meet the stringent uptime requirements of telecommunications infrastructure, a domain where systems are expected to run continuously for years.</p> <p>When an Erlang or Elixir system is started, it runs as a single operating system process. Within this OS process, the BEAM VM executes, managing its own ecosystem of lightweight Erlang processes.13 It is not uncommon for a single BEAM instance to manage hundreds of thousands, or even millions, of these concurrent processes. The BEAM is responsible for compiling Erlang source code into its own bytecode format, which is stored in  <code>.beam</code> files, and then executing this bytecode.</p> <p>A key aspect of the BEAM is its polyglot nature. While created for Erlang, it serves as a robust and powerful runtime for a variety of other languages, most notably Elixir, which leverages the full power of the BEAM and OTP while offering a different syntax and feature set.1 Other languages like Gleam, LFE (Lisp Flavoured Erlang), and Clojerl also target the BEAM, demonstrating its flexibility as a compilation target.12</p> <p>The primary responsibilities of the BEAM can be summarized as managing the system's scalability, distribution, and responsiveness by:</p> <ul> <li>Creating, scheduling, and managing concurrency via lightweight processes.</li> <li>Providing the mechanisms for error detection and fault-tolerant handling.</li> <li>Efficiently utilizing all available machine resources, particularly on multi-core CPUs.</li> </ul> <p>For those seeking the most exhaustive technical details, \"The BEAM Book\" by Erik Stenman is the definitive resource, providing a ground-up explanation of the VM's internals.</p>"},{"location":"research/rt/beam-inspired-runtime/#23-core-component-deep-dive-lightweight-processes-and-state-isolation","title":"2.3 Core Component Deep Dive: Lightweight Processes and State Isolation","text":"<p>The term \"process\" in Erlang is fundamentally different from an operating system process or thread. Erlang processes are extremely lightweight units of execution managed entirely by the BEAM VM, not the underlying OS. This internal management is what makes their creation, destruction, and context-switching operations orders of magnitude faster and less resource-intensive than their OS counterparts.</p> <p>The \"lightweight\" nature is quantifiable. A newly spawned process has a very small initial memory footprint, with a default heap size of just 233 words (a \"word\" being the native pointer size of the machine, e.g., 8 bytes on a 64-bit system). This conservative default is a deliberate design choice to enable massive scalability, allowing a single BEAM node to host millions of concurrent processes without exhausting system memory.</p> <p>Communication between these processes is the key to their isolation. When a message is sent from one process to another on the same BEAM node, its data is, by default, copied from the sender's heap to the receiver's heap. This strict copying ensures perfect memory isolation; a bug or crash in one process cannot corrupt the memory or state of another. This design choice is a cornerstone of the \"let it crash\" philosophy, as it guarantees that failures are contained. The primary exception to this rule is for large binaries (specifically, reference-counted binaries or \"refc binaries\"), which can be shared between processes on the same node via reference passing to avoid the performance overhead of copying large amounts of data.15 When messages are sent to a process on a different BEAM node, they are first encoded into the Erlang External Term Format and sent over a TCP/IP socket.</p>"},{"location":"research/rt/beam-inspired-runtime/#24-core-component-deep-dive-the-preemptive-scheduler-and-reductions","title":"2.4 Core Component Deep Dive: The Preemptive Scheduler and \"Reductions\"","text":"<p>The BEAM's scheduler is a masterclass in designing for concurrency and responsiveness on modern multi-core hardware. The initial single-queue model evolved into a symmetric multiprocessing (SMP) architecture where, by default, one scheduler thread is created for each available CPU core.1 Each of these scheduler threads maintains its own run queue of ready-to-execute Erlang processes. This design avoids the contention and bottleneck issues of a single, global lock on a run queue, enabling true parallelism as multiple processes can execute simultaneously on different cores. The VM itself acts as an intelligent load balancer, capable of migrating processes between scheduler run queues to ensure that work is distributed evenly and no core sits idle while others are overloaded.</p> <p>A critical and defining feature of the BEAM scheduler is that it is preemptive. Unlike cooperative schedulers, which rely on tasks to voluntarily yield control, the BEAM scheduler can forcibly interrupt a running process to allow another process to have its turn on the CPU. This prevents a single, long-running, CPU-bound process from monopolizing a scheduler thread and starving all other processes in that queue, which is essential for maintaining system-wide responsiveness.</p> <p>This preemption is not governed by traditional time slices. Instead, the BEAM uses a concept called reductions. A reduction is an abstract unit of work, roughly equivalent to a function call or a basic operation. Each Erlang process is given a \"reduction budget\" (typically 2,000) when it is scheduled to run. The scheduler decrements this budget as the process executes its code. Once the reduction count reaches zero, the process is preempted, placed back into the run queue, and the scheduler moves on to the next process, even if the first process has not completed its task. This reduction-counting mechanism provides a more deterministic and fair way to share CPU resources than simple timers, ensuring that all processes make progress and contributing to the soft real-time capabilities of the system. Furthermore, the scheduler supports multiple priority levels (low, normal, high, and max), with separate run queues for each, ensuring that high-priority system tasks are given preference over lower-priority application tasks.</p>"},{"location":"research/rt/beam-inspired-runtime/#25-core-component-deep-dive-per-process-memory-management-and-generational-garbage-collection","title":"2.5 Core Component Deep Dive: Per-Process Memory Management and Generational Garbage Collection","text":"<p>The BEAM's approach to memory management is a direct consequence of its process architecture and is fundamental to its fault-tolerance and low-latency characteristics. The single most important design decision is that every Erlang process has its own private heap and stack, allocated within a contiguous block of memory.4 This complete memory isolation is what makes the \"share nothing\" concurrency model a physical reality within the VM.</p> <p>This per-process heap architecture enables a highly efficient and concurrent garbage collection (GC) strategy. When the heap and stack of a single process grow to meet each other, a garbage collection cycle is triggered for that process and that process alone.19 All other processes in the system continue their execution completely uninterrupted.20 This avoids the \"stop-the-world\" problem common in many other garbage-collected runtimes, where the entire application must be paused for a GC cycle, leading to unpredictable latency spikes.</p> <p>The GC algorithm itself is a sophisticated per-process, generational, semi-space copying collector, based on Cheney's algorithm.19 Memory within a process's heap is divided into a \"young generation\" (or young heap) and an \"old generation\" (old heap). New objects are allocated in the young heap. The \"generational hypothesis\" posits that most objects die young. Therefore, the garbage collector runs most frequently on the smaller young heap, which is a very fast operation. Objects that survive multiple young-generation collections are promoted to the old heap.19 A \"full sweep\" collection that includes the old heap is a much less frequent event, triggered only when the old heap itself becomes full.19 This generational approach, combined with the per-process model, means that GC pauses in a well-behaved Erlang system are typically measured in microseconds and are imperceptible to the overall system's operation.</p>"},{"location":"research/rt/beam-inspired-runtime/#26-the-power-of-otp-supervision-hierarchies-distribution-and-hot-code-loading","title":"2.6 The Power of OTP: Supervision Hierarchies, Distribution, and Hot Code Loading","text":"<p>While the BEAM provides the raw capabilities for concurrency and fault isolation, it is the Open Telecom Platform (OTP) framework that provides the architectural patterns and libraries for building robust applications with these primitives.1 OTP is not an optional library; it is an integral part of the Erlang ecosystem.</p> <p>The most fundamental OTP pattern is the supervision tree. Applications are structured as a hierarchy of processes. \"Worker\" processes perform the actual application logic, while \"supervisor\" processes have the sole responsibility of monitoring their children. If a worker process crashes, its supervisor is notified and, based on a pre-configured strategy, can restart the failed worker.3 Common strategies include:</p> <ul> <li>One-for-one: If a child process terminates, only that process is restarted.</li> <li>One-for-all: If a child process terminates, all other child processes managed by the same supervisor are terminated and then all are restarted.</li> <li>Rest-for-one: If a child process terminates, the rest of the child processes (those started after the failing one) are terminated and then the failing process and the ones after it are restarted.</li> </ul> <p>This hierarchical structure allows for the creation of self-healing systems where failures are contained and automatically rectified at the lowest possible level of the application.</p> <p>OTP also provides powerful, built-in support for distribution. The mechanisms for sending messages between processes are location-transparent. The same <code>send</code> primitive is used whether the destination process is on the same BEAM node or on a different machine across a network.3 The runtime handles the underlying serialization and network communication, allowing developers to build complex distributed systems with relative ease.</p> <p>Finally, one of the BEAM's most celebrated features, enabled by the OTP framework, is hot code loading. This is the ability to load a new version of a code module into a running, live production system without stopping or restarting it.13 When a module is updated, existing processes can continue to run the old code, while new calls to that module will execute the new version. OTP provides specific patterns (code change callbacks) for processes to gracefully migrate their internal state to be compatible with the new code version. This feature is paramount for systems that demand continuous availability and cannot tolerate downtime for software updates.</p>"},{"location":"research/rt/beam-inspired-runtime/#iii-the-rust-concurrency-landscape-a-survey-of-erlang-inspired-frameworks-and-runtimes","title":"III. The Rust Concurrency Landscape: A Survey of Erlang-Inspired Frameworks and Runtimes","text":"<p>While Rust does not have a built-in runtime comparable to the BEAM, its powerful concurrency primitives and focus on safety have fostered a vibrant ecosystem of libraries and frameworks that aim to solve similar problems. Many of these are explicitly inspired by Erlang and the actor model. An analysis of these existing solutions provides invaluable insight into established patterns, common challenges, and idiomatic Rust approaches to concurrency and fault tolerance.</p>"},{"location":"research/rt/beam-inspired-runtime/#31-the-foundation-tokio-and-the-cooperative-asyncawait-paradigm","title":"3.1 The Foundation: Tokio and the Cooperative <code>async</code>/<code>await</code> Paradigm","text":"<p>At the foundation of modern asynchronous programming in Rust is Tokio. It is the de facto standard asynchronous runtime, providing the essential building blocks for writing networking applications and other concurrent systems.5 Tokio offers a multi-threaded, work-stealing scheduler, an asynchronous version of the standard library's I/O and timer APIs, and a vast ecosystem of compatible libraries.5</p> <p>The most critical architectural aspect of Tokio is its cooperative scheduling model.5 Rust's </p> <p><code>async</code>/<code>await</code> syntax allows functions to be defined as asynchronous tasks (futures). When a task is run on the Tokio executor, it executes on a worker thread until it reaches an <code>.await</code> point on an operation that cannot complete immediately (e.g., waiting for data from a network socket). At this point, the task voluntarily yields control back to the scheduler, which can then run another ready task on the same thread. This model is extremely efficient for I/O-bound workloads, as it minimizes the time a thread spends idly waiting. However, it is fundamentally different from the BEAM's preemptive model. A CPU-bound task in Tokio that does not contain any <code>.await</code> points will monopolize its worker thread until it completes, potentially starving other tasks scheduled on the same thread.</p>"},{"location":"research/rt/beam-inspired-runtime/#32-mature-actor-implementation-a-case-study-of-actix","title":"3.2 Mature Actor Implementation: A Case Study of Actix","text":"<p>Actix is one of the most mature and performant actor frameworks in the Rust ecosystem.25 It provides a powerful, pragmatic framework for building concurrent applications based on the actor model, and is built on top of the Tokio runtime.28</p> <p>In Actix, any Rust struct can become an actor by implementing the <code>Actor</code> trait. Actors encapsulate state and behavior, and communicate exclusively through statically typed messages.28 State is managed within the actor's struct and is mutated via a </p> <p><code>&amp;mut self</code> reference in its message handlers. Rust's ownership rules, combined with the framework's API which provides access to actors only through an <code>Addr</code> (address) object, ensure logical state isolation.29 There is no concept of per-actor heaps; all actors share the main OS process heap.</p> <p>For fault tolerance, Actix provides supervision capabilities through a <code>Supervisor</code> struct and a <code>Supervised</code> trait. An actor that implements <code>Supervised</code> can be managed by a supervisor, which will restart it if it fails.28 This provides a mechanism for recovery, but it is a feature that developers must explicitly opt into, rather than being the default architectural pattern as it is in OTP.</p>"},{"location":"research/rt/beam-inspired-runtime/#33-fault-tolerance-first-an-analysis-of-bastion-and-its-lightproc-model","title":"3.3 Fault-Tolerance First: An Analysis of Bastion and its \"Lightproc\" Model","text":"<p>Bastion is a framework that explicitly aims to bring the \"smell of Erlang\" to Rust, with a primary focus on high availability and fault tolerance.32 It describes itself as a \"highly-available, fault-tolerant runtime system with dynamic dispatch oriented lightweight process model\".32</p> <p>Its core concurrency primitive is the \"lightproc\" (lightweight process), which is an abstraction built on top of Rust futures designed to emulate the behavior of Erlang processes.32 A key differentiator for Bastion is that it makes supervision a central, first-class concept. It comes with a default root supervisor and provides built-in supervision strategies such as </p> <p><code>OneForOne</code> and <code>AllForOne</code>, closely mirroring the structure and terminology of OTP.34 This design choice encourages developers to structure their applications around fault-tolerance from the outset.</p>"},{"location":"research/rt/beam-inspired-runtime/#34-hierarchical-resilience-rikers-akka-inspired-approach-to-supervision","title":"3.4 Hierarchical Resilience: Riker's Akka-Inspired Approach to Supervision","text":"<p>Riker is another full-featured actor framework for Rust, drawing heavy inspiration from the Akka framework (which itself is a JVM implementation of the actor model inspired by Erlang).35 Like Bastion, Riker emphasizes the actor hierarchy as the fundamental structure for building resilient, self-healing systems.27</p> <p>Riker provides a complete actor runtime, actor supervision mechanisms, message scheduling, and publish/subscribe channels for event-driven architectures.27 The framework's roadmap explicitly includes plans for clustering, remote actors, and location transparency, indicating a clear ambition to provide a feature set comparable to that of Akka and OTP, allowing for the construction of distributed, fault-tolerant systems.27</p>"},{"location":"research/rt/beam-inspired-runtime/#35-the-next-frontier-lunatic-and-webassembly-based-process-isolation","title":"3.5 The Next Frontier: Lunatic and WebAssembly-based Process Isolation","text":"<p>Lunatic presents a novel and compelling architecture for an Erlang-inspired runtime. Instead of compiling Rust code directly to a native binary, Lunatic applications are compiled to WebAssembly (Wasm) and executed within the Lunatic Wasm runtime.39</p> <p>This architectural choice provides two profound benefits that align closely with the BEAM's design. First, it achieves hard memory isolation. Each Lunatic process is a distinct Wasm instance, and the Wasm specification mandates that each instance has its own sandboxed linear memory space, including its own stack and heap.39 This is the closest architectural analogue in the Rust ecosystem to the BEAM's per-process heaps, providing a strong, runtime-enforced guarantee against memory corruption between processes.</p> <p>Second, Lunatic implements a preemptive scheduler. Because the runtime has full control over the execution of the Wasm bytecode, it can instrument the code or use other mechanisms to interrupt a running Wasm instance, even one stuck in an infinite loop, and schedule another process to run.39 This allows Lunatic to offer the same kind of fairness and responsiveness guarantees as the BEAM, a feature that is notably absent in Tokio-based frameworks. Lunatic also supports supervision, distribution, and even hot code reloading (by loading new Wasm modules at runtime), making it a very significant project in the space of BEAM-like runtimes.39</p>"},{"location":"research/rt/beam-inspired-runtime/#36-direct-implementation-lessons-from-the-enigma-vm-project","title":"3.6 Direct Implementation: Lessons from the Enigma VM Project","text":"<p>The Enigma VM project is a direct attempt to implement the Erlang VM in Rust, with the goal of achieving OTP 22+ compatibility.44 While still experimental, it serves as an invaluable case study for understanding the practical challenges of such an undertaking.</p> <p>Architecturally, Enigma represents Erlang processes as long-running Rust futures and schedules them on a <code>tokio-threadpool</code> work-stealing queue.44 This design choice immediately highlights the central conflict between the BEAM's preemptive model and the cooperative nature of the underlying Tokio runtime. The project's source code is a rich resource for learning about the implementation details of BEAM opcodes, built-in functions (BIFs), the external term format, and other low-level runtime features in the context of Rust. It demonstrates the sheer complexity of the task while also providing a tangible example of how one might begin to structure such a system.</p> <p>The following table provides a high-level comparison of the surveyed Rust frameworks and runtimes across key architectural dimensions. This matrix is designed to distill the core design choices of each system, offering an at-a-glance overview of the existing landscape.</p> <p>Table 1: Comparative Feature Matrix of Rust Actor Frameworks and Runtimes</p> Feature Actix Bastion Riker Elfo Lunatic Underlying Runtime Tokio Tokio (via Agnostik abstraction) <code>futures::execution::ThreadPool</code> Tokio Custom (Wasmtime-based) Process Isolation Model Logical (Rust Ownership) Logical (Rust Ownership via <code>lightproc</code>) Logical (Rust Ownership) Logical (Rust Ownership) Hard (Per-process Wasm Instance/Heap) Scheduling Model Cooperative (<code>async</code>/<code>await</code>) Cooperative (<code>async</code>/<code>await</code>) Cooperative (<code>async</code>/<code>await</code>) Cooperative (<code>async</code>/<code>await</code>) Preemptive Supervision Model Opt-in (<code>Supervisor</code> struct) Core Feature (OTP-like strategies) Core Feature (Hierarchy-based) Core Feature (Supervisor support) Core Feature (OTP-inspired supervision) Built-in Distribution No (Requires external crates) Yes (Cluster formation) Planned (Roadmap feature) Yes (Distributed framework) Yes (Distributed nodes via QUIC) <p>This comparative analysis reveals several critical patterns and trends within the Rust ecosystem. The majority of actor frameworks are built upon the solid foundation of Tokio, and as a result, they inherit its cooperative scheduling model. This represents the most significant architectural divergence from the BEAM. A developer using these frameworks must be mindful that a long-running, non-yielding task can block a scheduler thread, a problem that does not exist in Erlang.</p> <p>Furthermore, there is a clear spectrum of approaches to process isolation. Most frameworks rely on Rust's powerful type system and ownership model to provide logical isolation at the API level. This is idiomatic and performant but does not provide the same hard, runtime-enforced memory boundary as the BEAM's per-process heaps. Lunatic stands apart by using WebAssembly sandboxing to achieve this hard memory isolation, offering a model that is philosophically much closer to the BEAM's but at the cost of introducing a Wasm runtime layer.</p> <p>Finally, while supervision is a feature in many Rust frameworks, its integration level varies. In frameworks like Bastion and Riker, it is presented as a central architectural pattern, echoing its importance in OTP. In others, it may be a more optional, library-level feature. This reflects a broader philosophical difference: Erlang/OTP is a runtime environment where supervision is a fundamental primitive, whereas in Rust, it is often a design pattern implemented on top of more general concurrency tools.</p>"},{"location":"research/rt/beam-inspired-runtime/#iv-synthesis-and-comparative-analysis-bridging-erlangs-philosophy-with-rusts-guarantees","title":"IV. Synthesis and Comparative Analysis: Bridging Erlang's Philosophy with Rust's Guarantees","text":"<p>Building a BEAM-inspired runtime in Rust is not a simple matter of translation; it is an exercise in bridging two distinct programming philosophies. Erlang's design prioritizes runtime resilience, dynamic behavior, and system-level fault tolerance. Rust prioritizes compile-time safety, performance, and explicit control over memory. A successful implementation must navigate the fundamental conflicts between these two paradigms and make deliberate architectural trade-offs.</p>"},{"location":"research/rt/beam-inspired-runtime/#41-process-and-state-isolation-beams-heaps-vs-rusts-ownership-model","title":"4.1 Process and State Isolation: BEAM's Heaps vs. Rust's Ownership Model","text":"<p>The BEAM achieves its gold standard of process isolation through a straightforward, if brute-force, mechanism: giving every process its own heap.19 This provides a hard, runtime-enforced memory boundary. A bug in one process, even one that causes a segmentation fault in native code, is contained within that process's memory space and cannot corrupt the state of any other process. This physical separation simplifies garbage collection and is the ultimate enabler of the \"let it crash\" philosophy.</p> <p>Rust, on the other hand, achieves memory safety and prevents data races through its ownership model and borrow checker at compile time.45 In a typical Rust actor framework, an actor's state is encapsulated within its struct. The framework's API, combined with the borrow checker, prevents any other part of the system from obtaining a mutable reference to that state concurrently. This provides strong </p> <p>logical isolation. However, it is not the same as the BEAM's physical isolation. All actors still share the same process-wide heap. A bug in <code>unsafe</code> code or a flaw in a C library dependency could, in theory, corrupt memory that affects other actors.</p> <p>This presents a critical architectural decision. Relying on Rust's ownership model is the most idiomatic and likely the most performant approach, leveraging the language's core strengths. However, to achieve the same level of absolute, untrusted-code-safe isolation as the BEAM, a model like Lunatic's, which uses an external sandboxing mechanism like WebAssembly, is necessary.40 This choice trades some native performance and simplicity for a much stronger fault-isolation guarantee.</p>"},{"location":"research/rt/beam-inspired-runtime/#42-scheduling-models-preemptive-fairness-vs-cooperative-throughput","title":"4.2 Scheduling Models: Preemptive Fairness vs. Cooperative Throughput","text":"<p>This is arguably the most significant architectural conflict. The BEAM's preemptive scheduler, based on reductions, is the heart of its ability to provide soft real-time guarantees and fairness.4 It ensures that no single process can dominate a CPU core, which is essential for keeping a system with millions of processes responsive.</p> <p>The dominant paradigm in the Rust async ecosystem, provided by Tokio, is cooperative scheduling.23 This model is optimized for high throughput in I/O-bound applications, where tasks frequently yield control at </p> <p><code>.await</code> points. It is simpler and has lower overhead than a preemptive scheduler. However, it is vulnerable to \"bad actor\" processes\u2014CPU-bound tasks that compute for long periods without yielding. Such a task will starve all other tasks on its worker thread, leading to unpredictable latency and a loss of the fairness guarantees that are central to the Erlang model.</p> <p>Therefore, a true BEAM-like runtime cannot be built directly on a standard Tokio executor without modification. The implementation must choose one of three paths:</p> <ol> <li>Accept the cooperative model: This is the simplest path but represents a major compromise on the BEAM's core principles of fairness and responsiveness.</li> <li>Build a custom preemptive scheduler: This is a highly complex undertaking, requiring mechanisms to interrupt running Rust code. This could potentially be achieved by running tasks in separate OS threads (which would sacrifice the \"lightweight\" nature of processes) or by instrumenting the compiled code to insert yield points, similar to how reduction counting works.</li> <li>Use a sandboxed runtime: This is the approach taken by Lunatic.39 By compiling code to Wasm, the host runtime can pause and resume the Wasm instance at will, effectively implementing preemption without needing to modify the Rust compiler or rely on OS threads for every process.</li> </ol>"},{"location":"research/rt/beam-inspired-runtime/#43-message-passing-semantics-data-copying-vs-ownership-transfer","title":"4.3 Message Passing Semantics: Data Copying vs. Ownership Transfer","text":"<p>In the BEAM, messages are generally copied from the sender's heap to the receiver's.16 This reinforces the \"share nothing\" principle, ensuring complete decoupling between processes. The performance cost of this copying is considered an acceptable price for the resulting simplicity and robustness.</p> <p>In Rust, the most idiomatic and performant way to pass data is to transfer ownership via a <code>move</code>. This is a zero-copy operation, as only the pointer and ownership metadata on the stack are moved.47 This is highly efficient but creates a stronger link between components than the Erlang model. While Rust's channels and actor mailboxes handle the ownership transfer, it is a different semantic model from Erlang's copy-on-send.</p> <p>A Rust implementation must make a conscious choice. It could enforce a <code>Clone</code> bound on all messages, simulating the BEAM's copy-on-send behavior. This would be semantically faithful but would opt out of one of Rust's major performance advantages. Alternatively, it could embrace ownership transfer for its performance benefits, accepting that this represents a deviation from the pure \"share nothing\" model and may require more careful consideration of data lifetimes.</p>"},{"location":"research/rt/beam-inspired-runtime/#44-fault-tolerance-replicating-otp-supervision-trees-in-rust","title":"4.4 Fault Tolerance: Replicating OTP Supervision Trees in Rust","text":"<p>In OTP, supervision is a set of runtime primitives. Processes can be \"linked,\" meaning a crash in one will propagate a kill signal to the other. Supervisors use \"monitors\" to receive notifications when a child process dies.3 These are low-level mechanisms upon which the supervision tree pattern is built.</p> <p>In Rust, frameworks like Bastion and Riker implement supervision as a library pattern on top of the async runtime.27 A supervisor actor spawns child actors as async tasks and holds onto their </p> <p><code>JoinHandle</code>. It can then poll these handles or use channels to be notified when a task panics or exits with an error. This works, but it is an abstraction layer built by the framework.</p> <p>A true BEAM-like runtime in Rust would need to integrate these concepts more deeply. The runtime's internal process registry would need to track the links and monitor relationships between processes. The scheduler would need to understand this hierarchy to correctly propagate exit signals and execute the restart strategies defined by the supervisor. This requires making supervision a first-class citizen of the runtime, not just an application-level pattern.</p>"},{"location":"research/rt/beam-inspired-runtime/#45-the-hot-code-loading-challenge-in-a-statically-compiled-language","title":"4.5 The Hot Code Loading Challenge in a Statically Compiled Language","text":"<p>Hot code loading is perhaps the most difficult BEAM feature to replicate in a statically compiled language like Rust.13 The BEAM achieves this by having a module loader that can replace the code for a given module at runtime.</p> <p>The only viable mechanism for this in Rust is dynamic loading of shared libraries (<code>.so</code>, <code>.dll</code>, <code>.dylib</code>).48 However, this approach is fraught with challenges:</p> <ul> <li>Unstable ABI: Rust does not have a stable Application Binary Interface (ABI). This means that code compiled with one version of the Rust compiler may not be compatible with code compiled with another. To ensure compatibility between the main application and a dynamically loaded library, all exported functions must use the C ABI (<code>extern \"C\"</code>) and avoid complex Rust types in their signatures.50</li> <li>State Migration: This is the most significant hurdle. When a new version of a library is loaded, any existing state from the old version must be carefully migrated. This typically involves serializing the state to a stable format (like JSON or protobuf) before the old library is unloaded, and then deserializing it in the new library.52 This process is manual, complex, and a potential source of bugs.</li> <li>Safety: Interacting with dynamic libraries in Rust is inherently <code>unsafe</code>. The compiler cannot verify the correctness of the function signatures, and improper handling of library handles can lead to dangling pointers or memory leaks.49</li> </ul> <p>Replicating the seamlessness of BEAM's hot code loading is likely impossible. A practical Rust implementation would be much more constrained. A more promising, though still complex, avenue is the one offered by Wasm-based runtimes like Lunatic, which can load and instantiate new Wasm modules at runtime, potentially offering a safer and more manageable approach to dynamic code updates.55</p>"},{"location":"research/rt/beam-inspired-runtime/#v-a-practical-roadmap-for-implementation","title":"V. A Practical Roadmap for Implementation","text":"<p>Translating the preceding analysis into a concrete implementation requires a phased approach, beginning with foundational architectural decisions and progressively building towards the more advanced features of a BEAM-like system. This roadmap outlines a logical sequence of development, highlighting the critical choices at each stage.</p>"},{"location":"research/rt/beam-inspired-runtime/#51-key-architectural-decisions-and-their-trade-offs","title":"5.1 Key Architectural Decisions and Their Trade-offs","text":"<p>Before writing the first line of code, four fundamental architectural decisions must be made. These choices are deeply interconnected and will define the core character and capabilities of the final runtime.</p> <ul> <li>Decision 1: Scheduling Model (Preemptive vs. Cooperative). This is the most critical choice.</li> <li>Cooperative (Tokio-based): Pros: Simpler to implement, leverages the mature Tokio ecosystem, high throughput for I/O-bound tasks. Cons: Sacrifices fairness and responsiveness guarantees, vulnerable to blocking by CPU-bound tasks, a significant deviation from the BEAM's core behavior.</li> <li>Preemptive (Custom or Wasm-based): Pros: Achieves BEAM-like fairness and soft real-time behavior, robust against misbehaving processes. Cons: Far more complex to implement, requires either building a custom executor from scratch or integrating and managing a Wasm runtime like Wasmtime. This is the recommended path for a runtime that is truly BEAM-inspired.</li> <li>Decision 2: Process Isolation Model (Logical vs. Hard).</li> <li>Logical (Rust Ownership): Pros: Idiomatic Rust, zero-cost abstraction, high performance. Cons: Provides logical, not physical, memory isolation. A bug in <code>unsafe</code> code can still compromise the entire system.</li> <li>Hard (Wasm/OS Process): Pros: Provides strong, BEAM-like memory isolation. Failures are completely contained. Cons: Introduces performance overhead and the complexity of managing a Wasm runtime or OS processes. The Wasm approach is the most promising for replicating BEAM's model of lightweight, isolated processes.</li> <li>Decision 3: Message Passing Semantics (Move vs. Clone).</li> <li>Move (Ownership Transfer): Pros: Zero-copy, highly performant, idiomatic Rust. Cons: Deviates from the BEAM's \"share nothing\" by copying, creates stronger coupling between components.</li> <li>Clone (Copy-on-Send): Pros: Semantically identical to the BEAM's default, ensures complete decoupling. Cons: Incurs performance overhead for cloning messages, less idiomatic for Rust performance patterns.</li> <li>Decision 4: Supervision Integration (Library vs. Primitive).</li> <li>Library Pattern: Pros: Simpler to implement initially, decouples application logic from runtime internals. Cons: Less powerful, the runtime is not \"aware\" of the supervision hierarchy, limiting potential optimizations and deep integration.</li> <li>Runtime Primitive: Pros: A true replication of the OTP model, enables the scheduler to be aware of process links and monitors, allows for a more robust and integrated fault-tolerance system. Cons: More complex, requires tight coupling between the process management, scheduling, and supervision components.</li> </ul>"},{"location":"research/rt/beam-inspired-runtime/#5-implementation-phases","title":"5. Implementation Phases","text":""},{"location":"research/rt/beam-inspired-runtime/#51-core-runtime-executor-and-scheduler","title":"5.1 Core Runtime, Executor, and Scheduler","text":"<p>The first phase focuses on establishing the absolute core of the runtime: the ability to schedule and execute tasks.</p> <ol> <li>Define the <code>Runtime</code> Struct: This will be the main entry point and container for the system, holding the scheduler, process registry, and other global state.</li> <li>Implement the Scheduler: Based on Decision 1, implement the chosen scheduler.</li> <li>If preemptive, this involves integrating a Wasm runtime like <code>wasmtime</code> and building the logic to instantiate, run, and pause Wasm modules. The scheduler will manage a pool of OS threads and a run queue of ready-to-run Wasm instances.</li> <li>If cooperative, this involves creating a wrapper around a <code>tokio::runtime::Runtime</code> and its <code>Handle</code>.</li> <li>Implement Run Queues and Load Balancing: Each scheduler thread should have its own run queue. Implement the logic for tasks to be added to these queues and for the scheduler to pull from them. If building for multi-core, implement a work-stealing or process-migration strategy to balance load across schedulers.17</li> </ol>"},{"location":"research/rt/beam-inspired-runtime/#52-lightweight-processes-and-message-passing-infrastructure","title":"5.2 Lightweight Processes and Message Passing Infrastructure","text":"<p>This phase introduces the core abstractions of the actor model: processes and messages.</p> <ol> <li>Define the Process Control Block (PCB): Create a Rust struct to represent an Erlang PCB.13 This will hold all metadata for a process, including its unique Process ID (PID), its current status (e.g., running, waiting, exiting), a pointer to its mailbox, its reduction count, and references to its parent/supervisor and linked processes.</li> <li>Implement Process Spawning: Create the <code>spawn</code> and <code>spawn_link</code> functions. These functions will allocate a new PCB, create the initial process state (including its Wasm instance or async task), and place it in a scheduler's run queue.</li> <li>Design the Mailbox: Implement the data structure for the process mailbox. A lock-free, multi-producer, single-consumer queue (e.g., from the <code>crossbeam-channel</code> crate) is a suitable choice. A decision must be made whether the mailboxes will be bounded (providing back-pressure) or unbounded.</li> <li>Implement Message Passing Primitives: Implement the <code>send</code> function. This will involve locating the target process's PCB via its PID, and enqueuing the message into its mailbox. The implementation must adhere to the copy/move semantics chosen in Decision 3.</li> </ol>"},{"location":"research/rt/beam-inspired-runtime/#53-memory-management-and-garbage-collection-strategy","title":"5.3 Memory Management and Garbage Collection Strategy","text":"<p>This phase is only necessary if pursuing the hard isolation model with per-process heaps, as the logical isolation model would rely on Rust's global allocator.</p> <ol> <li>Implement a Heap Allocator: If using a Wasm runtime, this is largely handled by the Wasm instance's linear memory. If building a custom non-Wasm runtime with per-process heaps, this phase requires implementing a memory allocator that can create and manage distinct memory regions for each process.</li> <li>Implement a Garbage Collector: Start with a simple, correct GC algorithm. A Cheney's two-space copying collector is a classic and well-understood choice for functional languages.19</li> <li>Integrate GC with the Runtime: The GC needs to be triggered at appropriate times. This could be when a process's heap allocator fails to satisfy a request. The process would be suspended, the GC would run on its heap, and then the process would be rescheduled. The root set for the GC would be the process's stack and registers.19</li> </ol>"},{"location":"research/rt/beam-inspired-runtime/#54-advanced-features-supervision-distribution-and-dynamic-code-reloading","title":"5.4 Advanced Features - Supervision, Distribution, and Dynamic Code Reloading","text":"<p>With the core runtime in place, the advanced features that define the Erlang/OTP experience can be built.</p> <ol> <li>Supervision: Implement the low-level primitives for linking and monitoring processes within the runtime's process registry. When a process crashes, the runtime should be able to identify its supervisor and send it a notification message. Then, implement the <code>Supervisor</code> behavior itself, with the logic for parsing restart strategies and managing child processes.</li> <li>Distribution: Design the internode protocol. This involves defining how Erlang terms will be serialized for the wire (e.g., using the External Term Format) and choosing a transport (e.g., QUIC, as used by Lunatic, or TCP).39 Implement a global process registry (or a distributed hash table) to map PIDs to node locations and a proxying mechanism to transparently forward messages to remote processes.</li> <li>Dynamic Code Reloading: This is the most challenging feature.</li> <li>Implement a module loader using a crate like <code>libloading</code>.56</li> <li>Define a stable C ABI for all functions that are intended to be reloadable. This interface must be minimal and use only C-compatible types.</li> <li>Develop a robust state-migration protocol. This requires defining a <code>code_change</code> callback that allows a process to receive its old state, transform it, and initialize its new state before the old code module is unloaded. This process is inherently <code>unsafe</code> and requires meticulous management of library handles and state serialization.52</li> </ol>"},{"location":"research/rt/beam-inspired-runtime/#conclusion-the-path-to-a-production-ready-erlang-runtime-in-rust","title":"Conclusion: The Path to a Production-Ready Erlang Runtime in Rust","text":"<p>The endeavor to build an Erlang-inspired runtime in Rust is a significant systems engineering challenge that sits at the intersection of two powerful but philosophically distinct technologies. A direct, feature-for-feature clone of the BEAM is a monumental task, particularly with respect to its seamless hot code loading capabilities. However, a runtime that successfully captures the BEAM's core principles\u2014massive concurrency through lightweight processes, strong fault isolation, and resilient application architecture through supervision\u2014is a viable and immensely valuable project.</p> <p>The critical path to success lies in making informed architectural decisions at the outset, particularly regarding the choice between a cooperative and a preemptive scheduling model. While leveraging the existing Tokio ecosystem is tempting for its simplicity and maturity, a true BEAM-like system demands the fairness and responsiveness guarantees that only preemption can provide. The novel approach taken by the Lunatic project, using WebAssembly as a sandboxed, preemptible execution target, presents the most promising path forward for achieving BEAM's strongest guarantees in a Rust environment.</p> <p>By carefully navigating these trade-offs and following a phased implementation plan, it is possible to create a new class of runtime: one that combines the raw performance and compile-time memory safety of Rust with the architectural wisdom of Erlang for building scalable, resilient, and long-running systems. The result would not be merely a clone, but a powerful synthesis that stands on its own merits, inspired by one of the most robust runtimes ever created, and built with one of the most powerful systems languages of the modern era.</p>"},{"location":"research/rt/beam-model/","title":"The BEAM Model: A Blueprint for Concurrent and Resilient Systems","text":"<p>The Erlang/OTP runtime, known as the BEAM (Bogdan's Erlang Abstract Machine), represents more than a virtual machine; it is a holistic architectural philosophy for building systems designed for continuous operation and massive concurrency. Originally developed by Ericsson to implement highly available telecom infrastructure, its principles offer a powerful model for any system where reliability and scalability are paramount.1</p>"},{"location":"research/rt/beam-model/#11-fundamental-architecture-of-the-beam-virtual-machine","title":"1.1 Fundamental Architecture of the BEAM Virtual Machine","text":"<p>The BEAM's architecture is purpose-built to support its core design goals of concurrency, distribution, and fault tolerance. Its two most critical components are its process model and its scheduler.</p>"},{"location":"research/rt/beam-model/#lightweight-processes-memory-isolation","title":"Lightweight Processes &amp; Memory Isolation","text":"<p>The fundamental unit of concurrency in BEAM is the lightweight process, an abstraction that is managed entirely by the VM and is significantly more efficient than an operating system thread.1 A single BEAM instance can run millions of these processes simultaneously with minimal overhead.2</p> <p>The most crucial architectural feature of these processes is their complete memory isolation. Each BEAM process is an independent entity with its own private heap and stack.2 There is no shared memory between processes.1 This isolation is the bedrock of BEAM's fault tolerance; a crash or error within one process, such as an unhandled exception or a memory corruption bug, cannot affect the state or stability of any other process in the system.2</p> <p>This design has a profound impact on resource management, particularly garbage collection (GC). Unlike runtimes like the JVM that often employ a global, \"stop-the-world\" GC which pauses the entire application, BEAM performs garbage collection on a per-process basis.1 Since processes are isolated and typically short-lived or handle small amounts of data, GC pauses are localized, extremely short, and do not impact the overall system's responsiveness. This is a key contributor to BEAM's ability to maintain low and predictable latency, a critical requirement for soft real-time systems.1</p>"},{"location":"research/rt/beam-model/#preemptive-scheduler","title":"Preemptive Scheduler","text":"<p>To manage its millions of processes, BEAM employs a sophisticated, preemptive scheduler. The runtime starts one scheduler thread for each available CPU core, allowing for true parallelism.3 Each Erlang process is allocated a fixed budget of \"reductions\"\u2014a unit of work roughly equivalent to a function call\u2014before the scheduler preemptively suspends its execution and switches to another process in the queue.1</p> <p>This preemption guarantees fairness and prevents any single process, whether CPU-bound or misbehaving, from monopolizing a scheduler and starving other processes. This is a key differentiator from the cooperative scheduling models common in many asynchronous runtimes, where a task must explicitly yield control (e.g., at an <code>await</code> point).6 BEAM's preemptive nature provides the soft real-time guarantees necessary for applications like telecom switches and game servers, which must respond to events within a predictable timeframe.1 To further optimize resource utilization, the schedulers employ a work-stealing mechanism, where an idle scheduler can \"steal\" processes from the run queue of a busy scheduler, ensuring an even distribution of load across all available cores.3</p>"},{"location":"research/rt/beam-model/#12-the-actor-model-and-let-it-crash-philosophy","title":"1.2 The Actor Model and \"Let It Crash\" Philosophy","text":"<p>Built upon the foundation of isolated processes and preemptive scheduling, Erlang/OTP implements a powerful concurrency and fault-tolerance model.</p>"},{"location":"research/rt/beam-model/#message-passing-concurrency","title":"Message-Passing Concurrency","text":"<p>BEAM processes adhere to the Actor model of concurrency. They are computational entities (\"actors\") that encapsulate state and communicate exclusively by sending and receiving asynchronous messages.2 Since there is no shared memory, this model entirely eliminates the need for complex and error-prone synchronization primitives like locks, mutexes, or semaphores, which are a primary source of bugs such as data races and deadlocks in traditional shared-state concurrency models.1 Data is transferred between processes by copying messages, which is an efficient operation within the VM and is made safe by Erlang's use of immutable data structures.1</p>"},{"location":"research/rt/beam-model/#supervision-trees-and-fault-tolerance","title":"Supervision Trees and Fault Tolerance","text":"<p>The most distinctive aspect of the Erlang/OTP philosophy is its approach to handling errors, encapsulated by the mantra \"Let It Crash\".2 This philosophy posits that attempting to defensively program against every conceivable error is complex, error-prone, and often leads to code that masks the underlying problem. Instead, it is more robust to write \"corrective\" code that allows a faulty process to fail quickly and cleanly, and then have a separate, dedicated process\u2014a supervisor\u2014take action to recover the system to a known-good state.8</p> <p>The Open Telecom Platform (OTP) framework provides the components to build these self-healing systems. The core pattern is the supervision tree, a hierarchical structure where supervisor processes monitor a set of child processes (which can be workers or other supervisors).2 When a child process terminates abnormally (i.e., \"crashes\"), the supervisor is notified and applies a pre-configured restart strategy.10 These strategies can be fine-grained: </p> <p><code>one_for_one</code> restarts only the failing process, <code>one_for_all</code> restarts all sibling processes if one fails (for tightly coupled components), and <code>rest_for_one</code> restarts the failing process and any siblings that were started after it.11 This combination of process isolation and automated supervision allows for the creation of highly resilient systems that can automatically recover from transient software and hardware faults without manual intervention.2</p>"},{"location":"research/rt/beam-model/#13-distribution-and-live-upgrades","title":"1.3 Distribution and Live Upgrades","text":"<p>BEAM's architecture was designed not just for a single machine but for networks of machines, with features for distribution and continuous operation built into the runtime itself.</p>"},{"location":"research/rt/beam-model/#built-in-distribution","title":"Built-in Distribution","text":"<p>BEAM has native, transparent support for distributed computing. Multiple BEAM instances, or \"nodes,\" can be connected to form a cluster.1 Processes on one node can discover, send messages to, and spawn processes on another node using the exact same syntax as for local processes.2 The runtime handles the underlying network communication, making the location of a process transparent to the developer. This is a foundational feature, not a library add-on, and it enables the seamless horizontal scaling of applications across multiple servers.1</p>"},{"location":"research/rt/beam-model/#hot-code-swapping","title":"Hot Code Swapping","text":"<p>Perhaps the most celebrated feature of BEAM is its ability to perform hot code swapping, allowing a developer to upgrade the code of a module in a running, live production system without stopping it.1 When a new version of a module is loaded, the VM atomically updates the code pointers. New calls to that module will execute the new version of the code, while any processes currently executing code in the old version are allowed to complete their work undisturbed.4 This capability is critical for systems that require \"nine nines\" (</p> <p>99.9999999%) availability, such as telecommunication networks, and it also dramatically accelerates development cycles by allowing for rapid iteration without constant system restarts.1</p>"},{"location":"research/rt/beam-model/#14-translating-beam-principles-to-the-rust-ecosystem","title":"1.4 Translating BEAM Principles to the Rust Ecosystem","text":"<p>The principles of the BEAM model offer a compelling vision for building resilient systems, but translating them to the Rust ecosystem reveals both significant opportunities and fundamental architectural differences.</p>"},{"location":"research/rt/beam-model/#rusts-asyncawait-vs-beams-actors","title":"Rust's <code>async/await</code> vs. BEAM's Actors","text":"<p>Rust's primary model for concurrency is <code>async/await</code>, which is built to handle I/O-bound tasks with high efficiency. It is a cooperative, non-blocking model, where tasks run until they encounter an <code>.await</code> point, at which time they yield control back to the runtime's scheduler (e.g., Tokio).12 This contrasts sharply with BEAM's preemptive model, which is designed to handle both CPU-bound and I/O-bound work with guaranteed fairness.1 Fundamentally, </p> <p><code>async/await</code> is a lower-level language construct for managing asynchronous control flow, whereas the actor model is a higher-level architectural pattern for managing state, isolation, and communication.6</p>"},{"location":"research/rt/beam-model/#the-rust-actor-framework-landscape","title":"The Rust Actor Framework Landscape","text":"<p>Recognizing the need for higher-level concurrency abstractions, the Rust ecosystem has produced a vibrant landscape of actor libraries, each attempting to provide BEAM-like features on top of Rust's native capabilities.15</p> <ul> <li>Actix: A mature and widely used framework that provides a robust actor system. It defines an <code>Actor</code> trait, typed messages, and actor lifecycle management.16 Crucially for fault tolerance, Actix includes a </li> </ul> <p><code>Supervisor</code> struct and a <code>Supervised</code> trait, which allow a failed actor to be automatically restarted by its supervisor, directly mirroring a core OTP concept.17</p> <ul> <li> <p>Riker: A framework explicitly designed with resilience in mind, offering supervision strategies as a core feature and aiming for a modular system architecture.19</p> </li> <li> <p>Ractor: A newer framework that aims for a closer emulation of Erlang/OTP patterns. It provides built-in support for supervision trees, process groups (named groups of actors), and a companion library, <code>ractor_cluster</code>, for building distributed systems.21 The separate </p> </li> </ul> <p><code>ractor-supervisor</code> crate offers explicit OTP-style supervision strategies like <code>OneForOne</code>, <code>OneForAll</code>, and <code>RestForOne</code>, giving architects fine-grained control over recovery logic.11</p>"},{"location":"research/rt/beam-model/#the-supervision-gap-and-philosophical-tensions","title":"The Supervision Gap and Philosophical Tensions","text":"<p>Despite the progress of these libraries, a gap remains. In Erlang, supervision is not just a library feature; it is the default, \"thoughtless\" way to structure an application.21 In Rust, it is an opt-in pattern that requires conscious architectural effort. This points to a deeper, philosophical tension. Rust's core design ethos is to be \"fail-proof\" by using its powerful type system, ownership model, and explicit error handling (</p> <p><code>Result</code>, <code>Option</code>) to prevent entire classes of bugs at compile time.25 A panic is treated as an unrecoverable error that should, by default, terminate the program.26 Erlang's ethos, conversely, is to be \"fail-safe.\" It accepts that runtime failures are inevitable and focuses on building systems that can gracefully recover from them.8</p> <p>A direct translation of \"Let It Crash\" is therefore unnatural in idiomatic Rust. A panic within a standard Rust thread will tear down the entire process. To implement supervision, Rust actor frameworks must wrap the execution of actor code in a construct that catches the panic, preventing it from propagating and allowing the supervisor to take action.22 A truly \"Rusty\" approach to resilience would therefore be a hybrid: leveraging the type system to eliminate all preventable errors, while adopting an actor-based supervision model to manage the truly exceptional runtime failures that cannot be statically proven to be impossible (e.g., logic bugs, failures in external systems).</p> <p>This leads to a critical realization: the most significant difference between BEAM and Rust's actor ecosystem is that BEAM's features are deeply integrated into the VM itself, whereas Rust's actor frameworks are libraries layered on top of a general-purpose async runtime like Tokio.1 BEAM was designed from the ground up for concurrent, fault-tolerant systems.1 Rust's </p> <p><code>async</code> ecosystem was designed for high-performance, non-blocking I/O.12 Consequently, Rust actor libraries inherit the properties of the underlying runtime; they cannot implement true preemption but must rely on cooperative yielding at </p> <p><code>.await</code> points.6 Achieving BEAM-level guarantees in Rust would require more than just libraries; it would necessitate a specialized runtime or significant evolution of the existing async foundations to support concepts like preemption and deeper process isolation.</p> <p>Table 1: Feature Comparison of Erlang/OTP and Prominent Rust Actor Frameworks</p> Feature Erlang/BEAM/OTP Actix Ractor Concurrency Model Preemptive, lightweight processes managed by the VM. Cooperative tasks on an async runtime (e.g., Tokio). Cooperative tasks on an async runtime (e.g., Tokio). State Management Isolated process heaps; no shared memory. Actor struct state; relies on Rust's ownership/borrowing within the actor. Actor struct state with a separate <code>State</code> type; relies on Rust's ownership. Fault Isolation VM-level process isolation; crashes are contained. Task/thread-level isolation; panics must be caught by the framework. Task/thread-level isolation; panics are caught and reported as supervision events. Supervision Strategy Integrated OTP behaviors (<code>one_for_one</code>, <code>one_for_all</code>, etc.). <code>Supervisor</code> struct and <code>Supervised</code> trait for restarting actors. <code>ractor-supervisor</code> crate provides explicit OTP-style strategies. Distribution Model Built-in, transparent network communication between nodes. No built-in support; requires manual implementation. Companion library (<code>ractor_cluster</code>) for distributed scenarios; not production-ready. Live Code Upgrades Hot code swapping is a core feature of the VM. Not supported. Not supported."},{"location":"research/rt/rust-actor-ecosystem/","title":"Rust Actor Ecosystem Analysis","text":"<p>This document provides a comprehensive analysis of the current Rust actor ecosystem, examining existing frameworks, their design decisions, and lessons learned that inform <code>airssys-rt</code>'s architecture.</p>"},{"location":"research/rt/rust-actor-ecosystem/#current-landscape-overview","title":"Current Landscape Overview","text":"<p>The Rust ecosystem features several actor frameworks, each taking different approaches to implementing the actor model. This analysis examines their strengths, limitations, and architectural decisions.</p>"},{"location":"research/rt/rust-actor-ecosystem/#major-actor-frameworks","title":"Major Actor Frameworks","text":""},{"location":"research/rt/rust-actor-ecosystem/#1-actix-mature-production-framework","title":"1. Actix (Mature Production Framework)","text":"<p>Repository: <code>actix/actix</code> Status: Mature, widely adopted Foundation: Built on Tokio</p>"},{"location":"research/rt/rust-actor-ecosystem/#architecture-highlights","title":"Architecture Highlights","text":"<pre><code>// Actor definition in Actix\nuse actix::prelude::*;\n\nstruct CounterActor {\n    count: usize,\n}\n\nimpl Actor for CounterActor {\n    type Context = Context&lt;Self&gt;;\n}\n\n// Message handling\nimpl Handler&lt;IncrementMessage&gt; for CounterActor {\n    type Result = usize;\n\n    fn handle(&amp;mut self, _msg: IncrementMessage, _ctx: &amp;mut Context&lt;Self&gt;) -&gt; Self::Result {\n        self.count += 1;\n        self.count\n    }\n}\n</code></pre>"},{"location":"research/rt/rust-actor-ecosystem/#strengths","title":"Strengths","text":"<ul> <li>Production-tested: Battle-tested in high-traffic web applications</li> <li>Rich ecosystem: Extensive middleware and integration libraries</li> <li>Type safety: Strong typing for messages and responses</li> <li>Performance: Optimized for high-throughput scenarios</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#limitations","title":"Limitations","text":"<ul> <li>Complexity: Heavy framework with significant learning curve</li> <li>Web-focused: Primarily designed for web application development</li> <li>Supervision: Limited supervision tree support compared to OTP</li> <li>Coupling: Tight coupling with Actix ecosystem components</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#lessons-for-airssys-rt","title":"Lessons for airssys-rt","text":"<ul> <li>Type-safe message handling is essential</li> <li>Performance optimization requires careful actor lifecycle management</li> <li>Context objects can provide useful actor utilities</li> <li>Clear separation between actor logic and framework concerns</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#2-ractor-otp-inspired-framework","title":"2. Ractor (OTP-Inspired Framework)","text":"<p>Repository: <code>slawlor/ractor</code> Status: Actively developed, OTP-focused Foundation: Built on Tokio</p>"},{"location":"research/rt/rust-actor-ecosystem/#architecture-highlights_1","title":"Architecture Highlights","text":"<pre><code>// Ractor actor definition\nuse ractor::prelude::*;\n\nstruct WorkerActor {\n    state: WorkerState,\n}\n\n#[async_trait]\nimpl Actor for WorkerActor {\n    type Msg = WorkerMessage;\n    type State = WorkerState;\n    type Arguments = WorkerConfig;\n\n    async fn pre_start(\n        &amp;self,\n        myself: ActorRef&lt;Self::Msg&gt;,\n        args: Self::Arguments,\n    ) -&gt; Result&lt;Self::State, ActorProcessingErr&gt; {\n        Ok(WorkerState::new(args))\n    }\n\n    async fn handle(\n        &amp;self,\n        myself: ActorRef&lt;Self::Msg&gt;,\n        message: Self::Msg,\n        state: &amp;mut Self::State,\n    ) -&gt; Result&lt;(), ActorProcessingErr&gt; {\n        // Handle message\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"research/rt/rust-actor-ecosystem/#strengths_1","title":"Strengths","text":"<ul> <li>OTP semantics: Close adherence to Erlang/OTP patterns</li> <li>Supervision trees: Built-in supervision with OTP-style strategies</li> <li>Process groups: Named groups of actors for coordination</li> <li>Distribution: <code>ractor_cluster</code> for distributed actor systems</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#limitations_1","title":"Limitations","text":"<ul> <li>Complexity: Complex API with many concepts to learn</li> <li>Performance overhead: Additional abstractions impact performance</li> <li>Documentation: Limited documentation and examples</li> <li>Ecosystem: Smaller ecosystem compared to Actix</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#lessons-for-airssys-rt_1","title":"Lessons for airssys-rt","text":"<ul> <li>OTP patterns can be successfully adapted to Rust</li> <li>Supervision trees require careful API design</li> <li>Process groups provide valuable coordination mechanisms</li> <li>Distribution features should be modular and optional</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#3-bastion-fault-tolerance-first","title":"3. Bastion (Fault-Tolerance First)","text":"<p>Repository: <code>bastion-rs/bastion</code> Status: Maintenance mode Foundation: Custom runtime with Tokio integration</p>"},{"location":"research/rt/rust-actor-ecosystem/#architecture-highlights_2","title":"Architecture Highlights","text":"<pre><code>// Bastion lightproc definition\nuse bastion::prelude::*;\n\nfn worker_lightproc() -&gt; Lightproc {\n    Lightproc::new(async {\n        loop {\n            msg! {\n                msg: String =&gt; {\n                    // Handle string message\n                },\n                _: _ =&gt; {\n                    // Handle unknown message\n                },\n            }\n        }\n    })\n}\n</code></pre>"},{"location":"research/rt/rust-actor-ecosystem/#strengths_2","title":"Strengths","text":"<ul> <li>Fault tolerance: Primary focus on fault tolerance and recovery</li> <li>Supervision: Built-in supervision with OTP-style strategies</li> <li>Lightweight processes: Custom implementation of lightweight processes</li> <li>Message passing: Elegant message passing syntax with macros</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#limitations_2","title":"Limitations","text":"<ul> <li>Maintenance: Limited active development and maintenance</li> <li>Performance: Custom runtime has performance overhead</li> <li>Complexity: Complex internals with multiple abstraction layers</li> <li>Documentation: Incomplete documentation and examples</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#lessons-for-airssys-rt_2","title":"Lessons for airssys-rt","text":"<ul> <li>Fault tolerance should be a primary design consideration</li> <li>Macro-based APIs can provide ergonomic message handling</li> <li>Custom runtimes add complexity that may not be justified</li> <li>Long-term maintenance is crucial for framework adoption</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#4-riker-akka-inspired-framework","title":"4. Riker (Akka-Inspired Framework)","text":"<p>Repository: <code>riker-rs/riker</code> Status: Unmaintained Foundation: Custom async runtime</p>"},{"location":"research/rt/rust-actor-ecosystem/#architecture-highlights_3","title":"Architecture Highlights","text":"<pre><code>// Riker actor definition\nuse riker::prelude::*;\n\nstruct WorkerActor {\n    name: String,\n}\n\nimpl Actor for WorkerActor {\n    type Msg = WorkerMsg;\n\n    fn recv(&amp;mut self, ctx: &amp;Context&lt;Self::Msg&gt;, msg: Self::Msg, sender: Sender) {\n        match msg {\n            WorkerMsg::Work(data) =&gt; {\n                // Process work\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"research/rt/rust-actor-ecosystem/#strengths_3","title":"Strengths","text":"<ul> <li>Hierarchical supervision: Full supervision tree implementation</li> <li>Actor selection: Path-based actor addressing</li> <li>Event sourcing: Built-in event sourcing capabilities</li> <li>Clustering: Distributed actor system support (planned)</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#limitations_3","title":"Limitations","text":"<ul> <li>Abandoned: No longer maintained or developed</li> <li>Performance: Significant performance overhead</li> <li>Complexity: Complex API with steep learning curve</li> <li>Reliability: Stability issues in production use</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#lessons-for-airssys-rt_3","title":"Lessons for airssys-rt","text":"<ul> <li>Path-based addressing can be useful for large systems</li> <li>Event sourcing integration adds value for certain use cases</li> <li>Framework maintenance and long-term support are critical</li> <li>Performance optimization must be considered from the start</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#5-xactor-lightweight-alternative","title":"5. Xactor (Lightweight Alternative)","text":"<p>Repository: <code>sunli829/xactor</code> Status: Maintained Foundation: Built on async-std or Tokio</p>"},{"location":"research/rt/rust-actor-ecosystem/#architecture-highlights_4","title":"Architecture Highlights","text":"<pre><code>// Xactor definition\nuse xactor::prelude::*;\n\nstruct CounterActor {\n    count: i32,\n}\n\nimpl Actor for CounterActor {}\n\nimpl Handler&lt;Increment&gt; for CounterActor {\n    async fn handle(&amp;mut self, _ctx: &amp;mut Context&lt;Self&gt;, _msg: Increment) -&gt; i32 {\n        self.count += 1;\n        self.count\n    }\n}\n</code></pre>"},{"location":"research/rt/rust-actor-ecosystem/#strengths_4","title":"Strengths","text":"<ul> <li>Simplicity: Clean, minimal API surface</li> <li>Performance: Lightweight with minimal overhead</li> <li>Flexibility: Works with multiple async runtimes</li> <li>Supervision: Basic supervision capabilities</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#limitations_4","title":"Limitations","text":"<ul> <li>Limited features: Fewer features compared to full frameworks</li> <li>Documentation: Limited documentation and ecosystem</li> <li>Supervision: Basic supervision, not full OTP semantics</li> <li>Community: Smaller community and ecosystem</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#lessons-for-airssys-rt_4","title":"Lessons for airssys-rt","text":"<ul> <li>Simplicity can be a strength for many use cases</li> <li>Performance benefits of minimal framework overhead</li> <li>Runtime flexibility is valuable for library adoption</li> <li>Balance between features and simplicity is crucial</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#comparative-analysis","title":"Comparative Analysis","text":""},{"location":"research/rt/rust-actor-ecosystem/#performance-characteristics","title":"Performance Characteristics","text":"Framework Spawn Time Message Latency Memory Overhead Throughput Actix ~10\u03bcs ~1-5\u03bcs ~2KB/actor Very High Ractor ~50\u03bcs ~5-10\u03bcs ~4KB/actor High Bastion ~100\u03bcs ~10-20\u03bcs ~8KB/actor Medium Riker ~200\u03bcs ~20-50\u03bcs ~16KB/actor Low Xactor ~5\u03bcs ~1-3\u03bcs ~1KB/actor Very High"},{"location":"research/rt/rust-actor-ecosystem/#feature-comparison","title":"Feature Comparison","text":"Feature Actix Ractor Bastion Riker Xactor Type Safety \u2705 High \u2705 High \u26a0\ufe0f Medium \u26a0\ufe0f Medium \u2705 High Supervision \u26a0\ufe0f Basic \u2705 Full \u2705 Full \u2705 Full \u26a0\ufe0f Basic Distribution \u274c No \u2705 Yes \u26a0\ufe0f Planned \u26a0\ufe0f Planned \u274c No Hot Reload \u274c No \u274c No \u274c No \u274c No \u274c No Runtime Deps Tokio Tokio Custom Custom Flexible Maintenance \u2705 Active \u2705 Active \u26a0\ufe0f Limited \u274c Abandoned \u2705 Active"},{"location":"research/rt/rust-actor-ecosystem/#architectural-patterns-analysis","title":"Architectural Patterns Analysis","text":""},{"location":"research/rt/rust-actor-ecosystem/#scheduling-models","title":"Scheduling Models","text":""},{"location":"research/rt/rust-actor-ecosystem/#cooperative-scheduling-most-frameworks","title":"Cooperative Scheduling (Most Frameworks)","text":"<pre><code>// All frameworks rely on async/await cooperative scheduling\nasync fn actor_loop() {\n    loop {\n        let message = mailbox.recv().await; // Yield point\n        handle_message(message).await;      // Yield point\n    }\n}\n</code></pre> <p>Implications for airssys-rt: - Must work within cooperative scheduling constraints - CPU-bound tasks can starve other actors - Need strategies for fairness and responsiveness</p>"},{"location":"research/rt/rust-actor-ecosystem/#preemptive-scheduling-none-implemented","title":"Preemptive Scheduling (None Implemented)","text":"<pre><code>// No Rust actor framework implements true preemption\n// Would require custom runtime or sandboxing (like WASM)\n</code></pre> <p>Implications for airssys-rt: - True preemption would require significant complexity - Hybrid approaches may provide benefits - Consider WebAssembly for isolation and preemption</p>"},{"location":"research/rt/rust-actor-ecosystem/#message-passing-patterns","title":"Message Passing Patterns","text":""},{"location":"research/rt/rust-actor-ecosystem/#channel-based-most-common","title":"Channel-Based (Most Common)","text":"<pre><code>// Actors communicate via channels\nstruct ActorRef&lt;M&gt; {\n    sender: mpsc::UnboundedSender&lt;M&gt;,\n}\n\nimpl&lt;M&gt; ActorRef&lt;M&gt; {\n    async fn send(&amp;self, msg: M) -&gt; Result&lt;(), SendError&gt; {\n        self.sender.send(msg).map_err(|_| SendError::Disconnected)\n    }\n}\n</code></pre>"},{"location":"research/rt/rust-actor-ecosystem/#shared-state-some-frameworks","title":"Shared State (Some Frameworks)","text":"<pre><code>// Some frameworks allow shared state with careful synchronization\nstruct SharedActor {\n    shared_data: Arc&lt;RwLock&lt;Data&gt;&gt;,\n}\n</code></pre> <p>Implications for airssys-rt: - Channel-based approach is most common and proven - Shared state patterns can optimize performance in specific cases - Type safety is crucial for message passing correctness</p>"},{"location":"research/rt/rust-actor-ecosystem/#supervision-patterns","title":"Supervision Patterns","text":""},{"location":"research/rt/rust-actor-ecosystem/#library-level-supervision-actix-xactor","title":"Library-Level Supervision (Actix, Xactor)","text":"<pre><code>// Supervision implemented as library pattern\nstruct Supervisor {\n    children: Vec&lt;ActorRef&gt;,\n}\n\nimpl Supervisor {\n    async fn handle_child_failure(&amp;self, child: ActorRef) {\n        // Restart logic implemented in userland\n    }\n}\n</code></pre>"},{"location":"research/rt/rust-actor-ecosystem/#runtime-integrated-supervision-ractor-bastion","title":"Runtime-Integrated Supervision (Ractor, Bastion)","text":"<pre><code>// Supervision integrated into actor runtime\nimpl Actor for SupervisorActor {\n    async fn handle_child_exit(&amp;mut self, child: ActorId, reason: ExitReason) {\n        match self.strategy {\n            RestartStrategy::OneForOne =&gt; self.restart_child(child).await,\n            // Other strategies...\n        }\n    }\n}\n</code></pre> <p>Implications for airssys-rt: - Runtime-integrated supervision enables better optimization - Library-level supervision is simpler to implement - OTP-style supervision requires careful API design</p>"},{"location":"research/rt/rust-actor-ecosystem/#lessons-learned-for-airssys-rt","title":"Lessons Learned for airssys-rt","text":""},{"location":"research/rt/rust-actor-ecosystem/#1-api-design-principles","title":"1. API Design Principles","text":"<ul> <li>Type Safety First: Strong typing prevents runtime errors</li> <li>Ergonomic Macros: Well-designed macros improve developer experience</li> <li>Minimal Boilerplate: Reduce ceremony for common patterns</li> <li>Clear Error Handling: Explicit error types and propagation</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#2-performance-considerations","title":"2. Performance Considerations","text":"<ul> <li>Actor Spawn Overhead: Minimize memory allocation and initialization</li> <li>Message Passing: Zero-copy where possible, efficient serialization</li> <li>Scheduler Integration: Work with Tokio's scheduler, don't fight it</li> <li>Memory Management: Efficient cleanup and resource management</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#3-supervision-design","title":"3. Supervision Design","text":"<ul> <li>Runtime Integration: Deep integration enables optimization</li> <li>Strategy Flexibility: Support multiple restart strategies</li> <li>Error Propagation: Clear escalation and error handling</li> <li>Monitoring Integration: Built-in metrics and observability</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#4-ecosystem-integration","title":"4. Ecosystem Integration","text":"<ul> <li>Tokio Compatibility: Work seamlessly with async/await</li> <li>Minimal Dependencies: Reduce dependency bloat and conflicts</li> <li>Modular Architecture: Allow users to opt into features</li> <li>Documentation Quality: Comprehensive docs and examples</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#gaps-in-current-ecosystem","title":"Gaps in Current Ecosystem","text":""},{"location":"research/rt/rust-actor-ecosystem/#1-system-programming-focus","title":"1. System Programming Focus","text":"<ul> <li>Most frameworks target web applications or general concurrency</li> <li>Limited support for OS integration and system programming patterns</li> <li>Opportunity for <code>airssys-rt</code> to fill this niche</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#2-true-process-isolation","title":"2. True Process Isolation","text":"<ul> <li>No framework provides BEAM-level process isolation</li> <li>Memory safety relies on Rust's type system, not runtime boundaries</li> <li>WebAssembly sandboxing could address this gap</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#3-performance-at-scale","title":"3. Performance at Scale","text":"<ul> <li>Limited benchmarking and optimization for large-scale systems</li> <li>Few frameworks target &gt;10,000 concurrent actors</li> <li>Opportunity for focused performance optimization</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#4-hot-code-loading","title":"4. Hot Code Loading","text":"<ul> <li>No Rust actor framework supports hot code loading</li> <li>Fundamental limitation of statically compiled languages</li> <li>Research opportunity for novel approaches</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#recommendations-for-airssys-rt","title":"Recommendations for airssys-rt","text":""},{"location":"research/rt/rust-actor-ecosystem/#1-adopt-proven-patterns","title":"1. Adopt Proven Patterns","text":"<ul> <li>Use channel-based message passing (proven and efficient)</li> <li>Implement runtime-integrated supervision (enables optimization)</li> <li>Provide type-safe message handling (prevents common errors)</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#2-focus-on-differentiation","title":"2. Focus on Differentiation","text":"<ul> <li>System programming integration (airssys-osl integration)</li> <li>Performance at scale (&gt;10,000 actors)</li> <li>Tiered isolation (logical \u2192 sandboxed \u2192 process-based)</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#3-learn-from-failures","title":"3. Learn from Failures","text":"<ul> <li>Avoid complex custom runtimes without clear benefits</li> <li>Ensure long-term maintenance and community building</li> <li>Balance feature richness with API simplicity</li> </ul>"},{"location":"research/rt/rust-actor-ecosystem/#4-leverage-rust-strengths","title":"4. Leverage Rust Strengths","text":"<ul> <li>Zero-cost abstractions for actor overhead</li> <li>Type system for message safety and actor behavior</li> <li>Ownership system for memory-efficient message passing</li> <li>Async/await for ergonomic concurrent programming</li> </ul> <p>The analysis of the Rust actor ecosystem provides valuable insights for <code>airssys-rt</code>'s design, highlighting both successful patterns to adopt and pitfalls to avoid.</p>"}]}