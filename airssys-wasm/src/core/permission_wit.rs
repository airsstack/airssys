//! WIT Permission Integration Layer
//!
//! This module bridges generated WIT permission types with the existing Rust permission system.
//! It provides bidirectional type conversions and host function wrappers for permission checking.
//!
//! # Architecture
//!
//! The integration layer serves three purposes:
//! 1. **Type Conversions**: Convert between WIT record types and Rust structs
//! 2. **Host Functions**: Implement WIT-exported permission checking functions
//! 3. **Error Mapping**: Translate Rust errors to WIT permission-result variants
//!
//! # WIT Integration
//!
//! Maps WIT types from `permissions.wit` to Rust types in `permission.rs`:
//! - `permission-manifest` ↔ `PermissionManifest`
//! - `filesystem-permissions` ↔ `FilesystemPermissions`
//! - `network-permissions` ↔ `NetworkPermissions`
//! - `storage-permissions` ↔ `StoragePermissions`
//! - `network-endpoint` ↔ `NetworkEndpoint`
//!
//! # Examples
//!
//! ## Type Conversion (WIT → Rust)
//!
//! ```rust
//! use airssys_wasm::core::permission_wit::{
//!     WitPermissionManifest, WitFilesystemPermissions
//! };
//! use airssys_wasm::core::permission::PermissionManifest;
//!
//! // WIT types (would be generated from permissions.wit)
//! let wit_fs = WitFilesystemPermissions {
//!     read: vec!["/data/**".to_string()],
//!     write: vec!["/output/**".to_string()],
//!     delete: vec![],
//!     list_dir: vec!["/data".to_string()],
//! };
//!
//! let wit_manifest = WitPermissionManifest {
//!     filesystem: wit_fs,
//!     network: Default::default(),
//!     storage: Default::default(),
//! };
//!
//! // Convert to Rust types
//! let rust_manifest: PermissionManifest = wit_manifest.into();
//! assert_eq!(rust_manifest.filesystem.read.len(), 1);
//! ```
//!
//! ## Host Function Implementation
//!
//! ```rust
//! use airssys_wasm::core::permission_wit::{WitComponentId, WitPermissionResult};
//! use airssys_wasm::core::permission_checker::PermissionChecker;
//!
//! fn check_file_read_wit(
//!     checker: &PermissionChecker,
//!     component: WitComponentId,
//!     path: String,
//! ) -> WitPermissionResult {
//!     // Convert WIT component ID to Rust
//!     let rust_id = component.into();
//!     
//!     // Check permission using Rust checker
//!     match checker.can_read_file(&rust_id, &path) {
//!         Ok(()) => WitPermissionResult::Granted,
//!         Err(e) => WitPermissionResult::Denied(e.to_string()),
//!     }
//! }
//! ```
//!
//! # References
//!
//! - **WIT Definition**: `wit/core/permissions.wit`
//! - **Rust Types**: `core/permission.rs`
//! - **Runtime Checker**: `core/permission_checker.rs`
//! - **ADR-WASM-005**: Capability-Based Security Model

// Layer 1: Standard library imports
// (none currently needed)

// Layer 2: Third-party crate imports
// (none currently needed)

// Layer 3: Internal module imports
use crate::core::component::ComponentId;
use crate::core::permission::{
    FilesystemPermissions, NetworkEndpoint, NetworkPermissions, PermissionManifest,
    StoragePermissions,
};
use crate::core::permission_checker::PermissionChecker;

// ═════════════════════════════════════════════════════════════════════════════
// WIT TYPE DEFINITIONS (Matching permissions.wit)
// ═════════════════════════════════════════════════════════════════════════════
//
// These types represent the WIT interface definitions from permissions.wit.
// In a full WIT integration, these would be auto-generated by wit-bindgen.
// For this integration layer, we define them manually to match the WIT spec.

/// WIT component-id record (from types.wit)
///
/// Matches: `record component-id { namespace: string, name: string, version: string }`
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WitComponentId {
    pub namespace: String,
    pub name: String,
    pub version: String,
}

/// WIT permission-manifest record (from permissions.wit)
///
/// Matches: `record permission-manifest { ... }`
#[derive(Debug, Clone, PartialEq)]
pub struct WitPermissionManifest {
    pub filesystem: WitFilesystemPermissions,
    pub network: WitNetworkPermissions,
    pub storage: WitStoragePermissions,
}

/// WIT filesystem-permissions record (from permissions.wit)
///
/// Matches: `record filesystem-permissions { read: list<string>, ... }`
#[derive(Debug, Clone, Default, PartialEq)]
pub struct WitFilesystemPermissions {
    pub read: Vec<String>,
    pub write: Vec<String>,
    pub delete: Vec<String>,
    pub list_dir: Vec<String>, // Note: WIT uses list-dir, Rust uses list
}

/// WIT network-endpoint record (from permissions.wit)
///
/// Matches: `record network-endpoint { host: string, port: u16 }`
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WitNetworkEndpoint {
    pub host: String,
    pub port: u16,
}

/// WIT network-permissions record (from permissions.wit)
///
/// Matches: `record network-permissions { outbound: list<network-endpoint>, ... }`
#[derive(Debug, Clone, Default, PartialEq)]
pub struct WitNetworkPermissions {
    pub outbound: Vec<WitNetworkEndpoint>,
    pub inbound: Vec<u16>,
}

/// WIT storage-permissions record (from permissions.wit)
///
/// Matches: `record storage-permissions { namespaces: list<string>, max-size-mb: u64 }`
#[derive(Debug, Clone, Default, PartialEq)]
pub struct WitStoragePermissions {
    pub namespaces: Vec<String>,
    pub max_size_mb: u64,
}

/// WIT permission-result variant (from permissions.wit)
///
/// Matches: `variant permission-result { granted, denied(string) }`
#[derive(Debug, Clone, PartialEq)]
pub enum WitPermissionResult {
    Granted,
    Denied(String),
}

// ═════════════════════════════════════════════════════════════════════════════
// TYPE CONVERSIONS: WIT → RUST
// ═════════════════════════════════════════════════════════════════════════════

impl From<WitComponentId> for ComponentId {
    /// Convert WIT component-id to Rust ComponentId
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::permission_wit::WitComponentId;
    /// use airssys_wasm::core::component::ComponentId;
    ///
    /// let wit_id = WitComponentId {
    ///     namespace: "airssys".to_string(),
    ///     name: "test-component".to_string(),
    ///     version: "1.0.0".to_string(),
    /// };
    ///
    /// let rust_id: ComponentId = wit_id.into();
    /// assert_eq!(rust_id.as_str(), "airssys:test-component@1.0.0");
    /// ```
    fn from(wit: WitComponentId) -> Self {
        // ComponentId uses format: namespace:name@version
        ComponentId::new(format!("{}:{}@{}", wit.namespace, wit.name, wit.version))
    }
}

impl From<WitNetworkEndpoint> for NetworkEndpoint {
    /// Convert WIT network-endpoint to Rust NetworkEndpoint
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::permission_wit::WitNetworkEndpoint;
    /// use airssys_wasm::core::permission::NetworkEndpoint;
    ///
    /// let wit_endpoint = WitNetworkEndpoint {
    ///     host: "api.example.com".to_string(),
    ///     port: 443,
    /// };
    ///
    /// let rust_endpoint: NetworkEndpoint = wit_endpoint.into();
    /// assert_eq!(rust_endpoint.host, "api.example.com");
    /// assert_eq!(rust_endpoint.port, 443);
    /// ```
    fn from(wit: WitNetworkEndpoint) -> Self {
        NetworkEndpoint {
            host: wit.host,
            port: wit.port,
        }
    }
}

impl From<WitFilesystemPermissions> for FilesystemPermissions {
    /// Convert WIT filesystem-permissions to Rust FilesystemPermissions
    ///
    /// Note: WIT uses `list-dir` field name, Rust uses `list`
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::permission_wit::WitFilesystemPermissions;
    /// use airssys_wasm::core::permission::FilesystemPermissions;
    ///
    /// let wit_fs = WitFilesystemPermissions {
    ///     read: vec!["/data/**".to_string()],
    ///     write: vec!["/output/**".to_string()],
    ///     delete: vec![],
    ///     list_dir: vec!["/data".to_string()],
    /// };
    ///
    /// let rust_fs: FilesystemPermissions = wit_fs.into();
    /// assert_eq!(rust_fs.read.len(), 1);
    /// assert_eq!(rust_fs.list.len(), 1); // list_dir → list
    /// ```
    fn from(wit: WitFilesystemPermissions) -> Self {
        FilesystemPermissions {
            read: wit.read,
            write: wit.write,
            delete: wit.delete,
            list: wit.list_dir, // Field name mapping: list-dir → list
        }
    }
}

impl From<WitNetworkPermissions> for NetworkPermissions {
    /// Convert WIT network-permissions to Rust NetworkPermissions
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::permission_wit::{WitNetworkPermissions, WitNetworkEndpoint};
    /// use airssys_wasm::core::permission::NetworkPermissions;
    ///
    /// let wit_network = WitNetworkPermissions {
    ///     outbound: vec![WitNetworkEndpoint {
    ///         host: "api.example.com".to_string(),
    ///         port: 443,
    ///     }],
    ///     inbound: vec![8080],
    /// };
    ///
    /// let rust_network: NetworkPermissions = wit_network.into();
    /// assert_eq!(rust_network.outbound.len(), 1);
    /// assert_eq!(rust_network.inbound.len(), 1);
    /// ```
    fn from(wit: WitNetworkPermissions) -> Self {
        NetworkPermissions {
            outbound: wit.outbound.into_iter().map(Into::into).collect(),
            inbound: wit.inbound,
        }
    }
}

impl From<WitStoragePermissions> for StoragePermissions {
    /// Convert WIT storage-permissions to Rust StoragePermissions
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::permission_wit::WitStoragePermissions;
    /// use airssys_wasm::core::permission::StoragePermissions;
    ///
    /// let wit_storage = WitStoragePermissions {
    ///     namespaces: vec!["myapp:cache".to_string()],
    ///     max_size_mb: 100,
    /// };
    ///
    /// let rust_storage: StoragePermissions = wit_storage.into();
    /// assert_eq!(rust_storage.namespaces.len(), 1);
    /// assert_eq!(rust_storage.max_size_mb, 100);
    /// ```
    fn from(wit: WitStoragePermissions) -> Self {
        StoragePermissions {
            namespaces: wit.namespaces,
            max_size_mb: wit.max_size_mb,
        }
    }
}

impl From<WitPermissionManifest> for PermissionManifest {
    /// Convert WIT permission-manifest to Rust PermissionManifest
    ///
    /// This is the top-level conversion that combines all permission types.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::permission_wit::{
    ///     WitPermissionManifest, WitFilesystemPermissions,
    ///     WitNetworkPermissions, WitStoragePermissions,
    /// };
    /// use airssys_wasm::core::permission::PermissionManifest;
    ///
    /// let wit_manifest = WitPermissionManifest {
    ///     filesystem: WitFilesystemPermissions {
    ///         read: vec!["/data/**".to_string()],
    ///         write: vec![],
    ///         delete: vec![],
    ///         list_dir: vec![],
    ///     },
    ///     network: WitNetworkPermissions::default(),
    ///     storage: WitStoragePermissions::default(),
    /// };
    ///
    /// let rust_manifest: PermissionManifest = wit_manifest.into();
    /// assert_eq!(rust_manifest.filesystem.read.len(), 1);
    /// ```
    fn from(wit: WitPermissionManifest) -> Self {
        PermissionManifest {
            filesystem: wit.filesystem.into(),
            network: wit.network.into(),
            storage: wit.storage.into(),
        }
    }
}

// ═════════════════════════════════════════════════════════════════════════════
// TYPE CONVERSIONS: RUST → WIT
// ═════════════════════════════════════════════════════════════════════════════

impl From<ComponentId> for WitComponentId {
    /// Convert Rust ComponentId to WIT component-id
    ///
    /// Parses format: namespace:name@version
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::component::ComponentId;
    /// use airssys_wasm::core::permission_wit::WitComponentId;
    ///
    /// let rust_id = ComponentId::new("airssys:test-component@1.0.0");
    /// let wit_id: WitComponentId = rust_id.into();
    ///
    /// assert_eq!(wit_id.namespace, "airssys");
    /// assert_eq!(wit_id.name, "test-component");
    /// assert_eq!(wit_id.version, "1.0.0");
    /// ```
    fn from(rust: ComponentId) -> Self {
        let id_str = rust.as_str();

        // Parse format: namespace:name@version
        let parts: Vec<&str> = id_str.split([':', '@']).collect();

        if parts.len() >= 3 {
            WitComponentId {
                namespace: parts[0].to_string(),
                name: parts[1].to_string(),
                version: parts[2].to_string(),
            }
        } else {
            // Fallback: treat entire string as name with default namespace/version
            WitComponentId {
                namespace: "default".to_string(),
                name: id_str.to_string(),
                version: "0.0.0".to_string(),
            }
        }
    }
}

impl From<NetworkEndpoint> for WitNetworkEndpoint {
    /// Convert Rust NetworkEndpoint to WIT network-endpoint
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::permission::NetworkEndpoint;
    /// use airssys_wasm::core::permission_wit::WitNetworkEndpoint;
    ///
    /// let rust_endpoint = NetworkEndpoint {
    ///     host: "api.example.com".to_string(),
    ///     port: 443,
    /// };
    ///
    /// let wit_endpoint: WitNetworkEndpoint = rust_endpoint.into();
    /// assert_eq!(wit_endpoint.host, "api.example.com");
    /// ```
    fn from(rust: NetworkEndpoint) -> Self {
        WitNetworkEndpoint {
            host: rust.host,
            port: rust.port,
        }
    }
}

impl From<FilesystemPermissions> for WitFilesystemPermissions {
    /// Convert Rust FilesystemPermissions to WIT filesystem-permissions
    ///
    /// Note: Rust `list` field maps to WIT `list-dir` field
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::permission::FilesystemPermissions;
    /// use airssys_wasm::core::permission_wit::WitFilesystemPermissions;
    ///
    /// let mut rust_fs = FilesystemPermissions::new();
    /// rust_fs.read.push("/data/**".to_string());
    /// rust_fs.list.push("/data".to_string());
    ///
    /// let wit_fs: WitFilesystemPermissions = rust_fs.into();
    /// assert_eq!(wit_fs.read.len(), 1);
    /// assert_eq!(wit_fs.list_dir.len(), 1); // list → list_dir
    /// ```
    fn from(rust: FilesystemPermissions) -> Self {
        WitFilesystemPermissions {
            read: rust.read,
            write: rust.write,
            delete: rust.delete,
            list_dir: rust.list, // Field name mapping: list → list-dir
        }
    }
}

impl From<NetworkPermissions> for WitNetworkPermissions {
    /// Convert Rust NetworkPermissions to WIT network-permissions
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::permission::{NetworkPermissions, NetworkEndpoint};
    /// use airssys_wasm::core::permission_wit::WitNetworkPermissions;
    ///
    /// let mut rust_network = NetworkPermissions::new();
    /// rust_network.outbound.push(NetworkEndpoint {
    ///     host: "api.example.com".to_string(),
    ///     port: 443,
    /// });
    ///
    /// let wit_network: WitNetworkPermissions = rust_network.into();
    /// assert_eq!(wit_network.outbound.len(), 1);
    /// ```
    fn from(rust: NetworkPermissions) -> Self {
        WitNetworkPermissions {
            outbound: rust.outbound.into_iter().map(Into::into).collect(),
            inbound: rust.inbound,
        }
    }
}

impl From<StoragePermissions> for WitStoragePermissions {
    /// Convert Rust StoragePermissions to WIT storage-permissions
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::permission::StoragePermissions;
    /// use airssys_wasm::core::permission_wit::WitStoragePermissions;
    ///
    /// let mut rust_storage = StoragePermissions::new();
    /// rust_storage.namespaces.push("myapp:cache".to_string());
    /// rust_storage.max_size_mb = 100;
    ///
    /// let wit_storage: WitStoragePermissions = rust_storage.into();
    /// assert_eq!(wit_storage.namespaces.len(), 1);
    /// ```
    fn from(rust: StoragePermissions) -> Self {
        WitStoragePermissions {
            namespaces: rust.namespaces,
            max_size_mb: rust.max_size_mb,
        }
    }
}

impl From<PermissionManifest> for WitPermissionManifest {
    /// Convert Rust PermissionManifest to WIT permission-manifest
    ///
    /// # Examples
    ///
    /// ```rust
    /// use airssys_wasm::core::permission::PermissionManifest;
    /// use airssys_wasm::core::permission_wit::WitPermissionManifest;
    ///
    /// let mut rust_manifest = PermissionManifest::new();
    /// rust_manifest.filesystem.read.push("/data/**".to_string());
    ///
    /// let wit_manifest: WitPermissionManifest = rust_manifest.into();
    /// assert_eq!(wit_manifest.filesystem.read.len(), 1);
    /// ```
    fn from(rust: PermissionManifest) -> Self {
        WitPermissionManifest {
            filesystem: rust.filesystem.into(),
            network: rust.network.into(),
            storage: rust.storage.into(),
        }
    }
}

// ═════════════════════════════════════════════════════════════════════════════
// HOST FUNCTION IMPLEMENTATIONS
// ═════════════════════════════════════════════════════════════════════════════

/// Check if component can read a file (WIT host function implementation)
///
/// This function wraps the Rust PermissionChecker for use in WIT exports.
///
/// # Arguments
///
/// * `checker` - The Rust permission checker
/// * `component` - WIT component ID
/// * `path` - File path to check
///
/// # Returns
///
/// `WitPermissionResult::Granted` if allowed, `Denied(reason)` otherwise
///
/// # Examples
///
/// ```rust
/// use airssys_wasm::core::permission_wit::{check_file_read_wit, WitComponentId, WitPermissionResult};
/// use airssys_wasm::core::permission_checker::PermissionChecker;
/// use airssys_wasm::core::permission::PermissionManifest;
/// use airssys_wasm::core::component::ComponentId;
///
/// let mut checker = PermissionChecker::new();
/// let rust_id = ComponentId::new("default:test-component@0.0.0");
/// let mut perms = PermissionManifest::new();
/// perms.filesystem.read.push("/data/**".to_string());
/// checker.load_permissions(rust_id.clone(), &perms).unwrap();
///
/// let wit_id = WitComponentId {
///     namespace: "default".to_string(),
///     name: "test-component".to_string(),
///     version: "0.0.0".to_string(),
/// };
///
/// let result = check_file_read_wit(&checker, wit_id, "/data/input.txt");
/// assert!(matches!(result, WitPermissionResult::Granted));
/// ```
pub fn check_file_read_wit(
    checker: &PermissionChecker,
    component: WitComponentId,
    path: &str,
) -> WitPermissionResult {
    let rust_id: ComponentId = component.into();
    match checker.can_read_file(&rust_id, path) {
        Ok(()) => WitPermissionResult::Granted,
        Err(e) => WitPermissionResult::Denied(e.to_string()),
    }
}

/// Check if component can write a file (WIT host function implementation)
///
/// # Examples
///
/// ```rust
/// use airssys_wasm::core::permission_wit::{check_file_write_wit, WitComponentId, WitPermissionResult};
/// use airssys_wasm::core::permission_checker::PermissionChecker;
/// use airssys_wasm::core::permission::PermissionManifest;
/// use airssys_wasm::core::component::ComponentId;
///
/// let mut checker = PermissionChecker::new();
/// let rust_id = ComponentId::new("default:test-component@0.0.0");
/// let mut perms = PermissionManifest::new();
/// perms.filesystem.write.push("/output/**".to_string());
/// checker.load_permissions(rust_id, &perms).unwrap();
///
/// let wit_id = WitComponentId {
///     namespace: "default".to_string(),
///     name: "test-component".to_string(),
///     version: "0.0.0".to_string(),
/// };
///
/// let result = check_file_write_wit(&checker, wit_id, "/output/result.txt");
/// assert!(matches!(result, WitPermissionResult::Granted));
/// ```
pub fn check_file_write_wit(
    checker: &PermissionChecker,
    component: WitComponentId,
    path: &str,
) -> WitPermissionResult {
    let rust_id: ComponentId = component.into();
    match checker.can_write_file(&rust_id, path) {
        Ok(()) => WitPermissionResult::Granted,
        Err(e) => WitPermissionResult::Denied(e.to_string()),
    }
}

/// Check if component can delete a file (WIT host function implementation)
pub fn check_file_delete_wit(
    checker: &PermissionChecker,
    component: WitComponentId,
    path: &str,
) -> WitPermissionResult {
    let rust_id: ComponentId = component.into();
    match checker.can_delete_file(&rust_id, path) {
        Ok(()) => WitPermissionResult::Granted,
        Err(e) => WitPermissionResult::Denied(e.to_string()),
    }
}

/// Check if component can list a directory (WIT host function implementation)
pub fn check_directory_list_wit(
    checker: &PermissionChecker,
    component: WitComponentId,
    path: &str,
) -> WitPermissionResult {
    let rust_id: ComponentId = component.into();
    match checker.can_list_directory(&rust_id, path) {
        Ok(()) => WitPermissionResult::Granted,
        Err(e) => WitPermissionResult::Denied(e.to_string()),
    }
}

/// Check if component can make outbound network connection (WIT host function implementation)
pub fn check_network_outbound_wit(
    checker: &PermissionChecker,
    component: WitComponentId,
    host: &str,
    port: u16,
) -> WitPermissionResult {
    let rust_id: ComponentId = component.into();
    match checker.can_connect_outbound(&rust_id, host, port) {
        Ok(()) => WitPermissionResult::Granted,
        Err(e) => WitPermissionResult::Denied(e.to_string()),
    }
}

/// Check if component can access storage namespace (WIT host function implementation)
pub fn check_storage_access_wit(
    checker: &PermissionChecker,
    component: WitComponentId,
    namespace: &str,
) -> WitPermissionResult {
    let rust_id: ComponentId = component.into();
    match checker.can_access_storage(&rust_id, namespace) {
        Ok(()) => WitPermissionResult::Granted,
        Err(e) => WitPermissionResult::Denied(e.to_string()),
    }
}

#[allow(clippy::expect_used, clippy::unwrap_used, clippy::unwrap_err_used, clippy::expect_err_used, clippy::panic, clippy::unwrap_on_result, clippy::indexing_slicing, clippy::too_many_arguments, clippy::type_complexity, reason = "test code")]
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wit_component_id_conversion_roundtrip() {
        let original = ComponentId::new("airssys:test-component@1.0.0");
        let wit: WitComponentId = original.clone().into();
        let back: ComponentId = wit.into();

        // Note: ComponentId stores full string, so comparison should be on parsed fields
        assert_eq!(original.as_str(), back.as_str());
    }

    #[test]
    fn test_network_endpoint_conversion_roundtrip() {
        let original = NetworkEndpoint {
            host: "api.example.com".to_string(),
            port: 443,
        };
        let wit: WitNetworkEndpoint = original.clone().into();
        let back: NetworkEndpoint = wit.into();

        assert_eq!(original, back);
    }

    #[test]
    fn test_filesystem_permissions_conversion() {
        let mut rust_fs = FilesystemPermissions::new();
        rust_fs.read.push("/data/**".to_string());
        rust_fs.list.push("/data".to_string());

        let wit: WitFilesystemPermissions = rust_fs.clone().into();
        assert_eq!(wit.read.len(), 1);
        assert_eq!(wit.list_dir.len(), 1); // Field name mapping

        let back: FilesystemPermissions = wit.into();
        assert_eq!(back.read.len(), 1);
        assert_eq!(back.list.len(), 1);
    }

    #[test]
    fn test_permission_manifest_conversion() {
        let mut rust_manifest = PermissionManifest::new();
        rust_manifest.filesystem.read.push("/data/**".to_string());
        rust_manifest.network.inbound.push(8080);
        rust_manifest
            .storage
            .namespaces
            .push("myapp:cache".to_string());

        let wit: WitPermissionManifest = rust_manifest.clone().into();
        assert_eq!(wit.filesystem.read.len(), 1);
        assert_eq!(wit.network.inbound.len(), 1);
        assert_eq!(wit.storage.namespaces.len(), 1);

        let back: PermissionManifest = wit.into();
        assert_eq!(back.filesystem.read.len(), 1);
        assert_eq!(back.network.inbound.len(), 1);
        assert_eq!(back.storage.namespaces.len(), 1);
    }
}
