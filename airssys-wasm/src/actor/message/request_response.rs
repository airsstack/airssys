//! Request-response message types for correlation tracking.
//!
//! Implements request and response message wrappers with automatic correlation
//! ID management, timeout specification, and multicodec payload support.
//!
//! # Architecture
//!
//! Per ADR-WASM-009 "Pattern 2: Request-Response":
//! ```text
//! Component A: send_request(target, payload, timeout)
//!     ↓
//! RequestMessage { correlation_id, from, to, payload, timeout }
//!     ↓
//! MessageBroker.publish("requests", ...)
//!     ↓
//! Component B: handle_message() → returns response
//!     ↓
//! ResponseMessage { correlation_id, from, to, result }
//!     ↓
//! Component A: handle_callback(correlation_id, result)
//! ```
//!
//! # Examples
//!
//! ```rust,ignore
//! use airssys_wasm::actor::message::{RequestMessage, ResponseMessage, RequestError};
//! use uuid::Uuid;
//!
//! // Create request
//! let request = RequestMessage::new(
//!     comp_a,
//!     comp_b,
//!     payload,
//!     5000, // 5 second timeout
//! );
//!
//! // Create success response
//! let response = ResponseMessage::success(
//!     request.correlation_id,
//!     comp_b,
//!     request.from,
//!     response_payload,
//! );
//!
//! // Create error response
//! let error_response = ResponseMessage::error(
//!     request.correlation_id,
//!     comp_b,
//!     request.from,
//!     RequestError::ProcessingFailed("Invalid input".into()),
//! );
//! ```
//!
//! # References
//!
//! - **ADR-WASM-009**: Component Communication Model (Pattern 2: Request-Response)
//! - **ADR-WASM-001**: Multicodec Compatibility Strategy
//! - **WASM-TASK-004 Phase 5 Task 5.1**: Message Correlation Implementation

// Layer 1: Standard library imports
use std::fmt;

// Layer 2: Third-party crate imports
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// Layer 3: Internal module imports
use crate::core::ComponentId;

/// Correlation ID type (UUID v4).
///
/// UUIDs provide 122-bit entropy with collision probability of 1 in 10^36,
/// ensuring globally unique correlation tracking across distributed components.
pub type CorrelationId = Uuid;

/// Request message with correlation tracking.
///
/// Wraps a request payload with metadata for automatic correlation
/// and timeout enforcement by the host runtime.
///
/// # Examples
///
/// ```rust,ignore
/// use airssys_wasm::actor::message::{RequestMessage, CorrelationId};
/// use uuid::Uuid;
///
/// let request = RequestMessage::new(
///     ComponentId::new("requester"),
///     ComponentId::new("responder"),
///     encode_multicodec(&my_request)?,
///     5000, // 5 seconds
/// );
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RequestMessage {
    /// Unique correlation ID (auto-generated by new())
    pub correlation_id: CorrelationId,

    /// Source component ID
    pub from: ComponentId,

    /// Target component ID
    pub to: ComponentId,

    /// Request payload (multicodec-encoded)
    pub payload: Vec<u8>,

    /// Request timestamp
    pub timestamp: DateTime<Utc>,

    /// Timeout duration (milliseconds)
    pub timeout_ms: u32,
}

impl RequestMessage {
    /// Create new request message.
    ///
    /// Generates a new UUID v4 correlation ID and sets the current timestamp.
    ///
    /// # Arguments
    ///
    /// * `from` - Source component ID
    /// * `to` - Target component ID
    /// * `payload` - Multicodec-encoded request payload
    /// * `timeout_ms` - Timeout in milliseconds
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// let request = RequestMessage::new(
    ///     component_a,
    ///     component_b,
    ///     payload,
    ///     5000,
    /// );
    /// ```
    pub fn new(from: ComponentId, to: ComponentId, payload: Vec<u8>, timeout_ms: u32) -> Self {
        Self {
            correlation_id: Uuid::new_v4(),
            from,
            to,
            payload,
            timestamp: Utc::now(),
            timeout_ms,
        }
    }
}

/// Response message with correlation tracking.
///
/// Wraps a response payload or error with correlation metadata,
/// matching the original request for callback delivery.
///
/// # Examples
///
/// ```rust,ignore
/// let response = ResponseMessage::success(
///     request.correlation_id,
///     ComponentId::new("responder"),
///     request.from,
///     response_payload,
/// );
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResponseMessage {
    /// Correlation ID matching the original request
    pub correlation_id: CorrelationId,

    /// Responder component ID
    pub from: ComponentId,

    /// Original requester component ID
    pub to: ComponentId,

    /// Response payload (multicodec-encoded) or error
    pub result: Result<Vec<u8>, RequestError>,

    /// Response timestamp
    pub timestamp: DateTime<Utc>,
}

impl ResponseMessage {
    /// Create success response.
    ///
    /// # Arguments
    ///
    /// * `correlation_id` - Correlation ID from original request
    /// * `from` - Responder component ID
    /// * `to` - Original requester component ID
    /// * `payload` - Response payload (multicodec-encoded)
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// let response = ResponseMessage::success(
    ///     request.correlation_id,
    ///     component_b,
    ///     request.from,
    ///     response_payload,
    /// );
    /// ```
    pub fn success(
        correlation_id: CorrelationId,
        from: ComponentId,
        to: ComponentId,
        payload: Vec<u8>,
    ) -> Self {
        Self {
            correlation_id,
            from,
            to,
            result: Ok(payload),
            timestamp: Utc::now(),
        }
    }

    /// Create error response.
    ///
    /// # Arguments
    ///
    /// * `correlation_id` - Correlation ID from original request
    /// * `from` - Responder component ID
    /// * `to` - Original requester component ID
    /// * `error` - Request error
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// let response = ResponseMessage::error(
    ///     request.correlation_id,
    ///     component_b,
    ///     request.from,
    ///     RequestError::ProcessingFailed("Invalid input".into()),
    /// );
    /// ```
    pub fn error(
        correlation_id: CorrelationId,
        from: ComponentId,
        to: ComponentId,
        error: RequestError,
    ) -> Self {
        Self {
            correlation_id,
            from,
            to,
            result: Err(error),
            timestamp: Utc::now(),
        }
    }
}

/// Request-response error types.
///
/// Represents failure modes in request-response communication:
/// - Timeout: Request exceeded timeout duration
/// - ComponentNotFound: Target component not registered
/// - ProcessingFailed: Target component returned error
/// - InvalidPayload: Malformed request payload
///
/// # Stability
///
/// This enum is marked `#[non_exhaustive]` to allow adding new error
/// variants in the future without breaking changes. Always use a wildcard
/// pattern when matching:
///
/// ```rust,ignore
/// match error {
///     RequestError::Timeout => { /* handle timeout */ },
///     RequestError::ComponentNotFound(id) => { /* handle not found */ },
///     _ => { /* handle unknown errors */ },
/// }
/// ```
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[non_exhaustive]
pub enum RequestError {
    /// Request timed out before response arrived
    Timeout,

    /// Target component not found in registry
    ComponentNotFound(ComponentId),

    /// Target component failed to process request
    ProcessingFailed(String),

    /// Invalid request payload (deserialization failed)
    InvalidPayload(String),
}

impl fmt::Display for RequestError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            RequestError::Timeout => write!(f, "Request timed out"),
            RequestError::ComponentNotFound(id) => {
                write!(f, "Component not found: {}", id.as_str())
            }
            RequestError::ProcessingFailed(msg) => {
                write!(f, "Processing failed: {}", msg)
            }
            RequestError::InvalidPayload(msg) => {
                write!(f, "Invalid payload: {}", msg)
            }
        }
    }
}

impl std::error::Error for RequestError {}

#[cfg(test)]
#[expect(clippy::unwrap_used, reason = "unwrap acceptable in test code")]
mod tests {
    use super::*;

    #[test]
    fn test_request_message_new() {
        let from = ComponentId::new("comp-a");
        let to = ComponentId::new("comp-b");
        let payload = vec![1, 2, 3, 4];

        let request = RequestMessage::new(from.clone(), to.clone(), payload.clone(), 5000);

        assert_eq!(request.from, from);
        assert_eq!(request.to, to);
        assert_eq!(request.payload, payload);
        assert_eq!(request.timeout_ms, 5000);
        // Correlation ID is auto-generated (UUID v4)
        assert_ne!(request.correlation_id, Uuid::nil());
    }

    #[test]
    fn test_response_message_success() {
        let corr_id = Uuid::new_v4();
        let from = ComponentId::new("comp-b");
        let to = ComponentId::new("comp-a");
        let payload = vec![5, 6, 7, 8];

        let response = ResponseMessage::success(corr_id, from.clone(), to.clone(), payload.clone());

        assert_eq!(response.correlation_id, corr_id);
        assert_eq!(response.from, from);
        assert_eq!(response.to, to);
        assert!(response.result.is_ok());
        assert_eq!(response.result.unwrap(), payload);
    }

    #[test]
    fn test_response_message_error() {
        let corr_id = Uuid::new_v4();
        let from = ComponentId::new("comp-b");
        let to = ComponentId::new("comp-a");
        let error = RequestError::Timeout;

        let response = ResponseMessage::error(corr_id, from.clone(), to.clone(), error.clone());

        assert_eq!(response.correlation_id, corr_id);
        assert_eq!(response.from, from);
        assert_eq!(response.to, to);
        assert!(response.result.is_err());
        assert_eq!(response.result.unwrap_err(), error);
    }

    #[test]
    fn test_request_error_display() {
        assert_eq!(RequestError::Timeout.to_string(), "Request timed out");
        assert_eq!(
            RequestError::ComponentNotFound(ComponentId::new("test")).to_string(),
            "Component not found: test"
        );
        assert_eq!(
            RequestError::ProcessingFailed("test error".into()).to_string(),
            "Processing failed: test error"
        );
        assert_eq!(
            RequestError::InvalidPayload("bad data".into()).to_string(),
            "Invalid payload: bad data"
        );
    }

    #[test]
    fn test_request_message_serialization() {
        let request = RequestMessage::new(
            ComponentId::new("comp-a"),
            ComponentId::new("comp-b"),
            vec![1, 2, 3],
            5000,
        );

        // Test JSON serialization round-trip
        let json = serde_json::to_string(&request).unwrap();
        let deserialized: RequestMessage = serde_json::from_str(&json).unwrap();

        assert_eq!(deserialized.correlation_id, request.correlation_id);
        assert_eq!(deserialized.from, request.from);
        assert_eq!(deserialized.to, request.to);
        assert_eq!(deserialized.payload, request.payload);
        assert_eq!(deserialized.timeout_ms, request.timeout_ms);
    }

    #[test]
    fn test_response_message_serialization() {
        let response = ResponseMessage::success(
            Uuid::new_v4(),
            ComponentId::new("comp-b"),
            ComponentId::new("comp-a"),
            vec![4, 5, 6],
        );

        // Test JSON serialization round-trip
        let json = serde_json::to_string(&response).unwrap();
        let deserialized: ResponseMessage = serde_json::from_str(&json).unwrap();

        assert_eq!(deserialized.correlation_id, response.correlation_id);
        assert_eq!(deserialized.from, response.from);
        assert_eq!(deserialized.to, response.to);
        assert!(deserialized.result.is_ok());
    }

    #[test]
    fn test_request_error_serialization() {
        let errors = vec![
            RequestError::Timeout,
            RequestError::ComponentNotFound(ComponentId::new("test")),
            RequestError::ProcessingFailed("error".into()),
            RequestError::InvalidPayload("bad".into()),
        ];

        for error in errors {
            let json = serde_json::to_string(&error).unwrap();
            let deserialized: RequestError = serde_json::from_str(&json).unwrap();
            assert_eq!(deserialized, error);
        }
    }
}
