//! Request-response message types for correlation tracking.
//!
//! Implements request and response message wrappers with automatic correlation
//! ID management, timeout specification, and multicodec payload support.
//!
//! # Architecture
//!
//! Per ADR-WASM-009 "Pattern 2: Request-Response":
//! ```text
//! Component A: send_request(target, payload, timeout)
//!     ↓
//! RequestMessage { correlation_id, from, to, payload, timeout }
//!     ↓
//! MessageBroker.publish("requests", ...)
//!     ↓
//! Component B: handle_message() → returns response
//!     ↓
//! ResponseMessage { correlation_id, from, to, result }
//!     ↓
//! Component A: handle_callback(correlation_id, result)
//! ```
//!
//! # Examples
//!
//! ```rust,ignore
//! use airssys_wasm::actor::message::{RequestMessage, ResponseMessage, RequestError};
//! use uuid::Uuid;
//!
//! // Create request
//! let request = RequestMessage::new(
//!     comp_a,
//!     comp_b,
//!     payload,
//!     5000, // 5 second timeout
//! );
//!
//! // Create success response
//! let response = ResponseMessage::success(
//!     request.correlation_id,
//!     comp_b,
//!     request.from,
//!     response_payload,
//! );
//!
//! // Create error response
//! let error_response = ResponseMessage::error(
//!     request.correlation_id,
//!     comp_b,
//!     request.from,
//!     RequestError::ProcessingFailed("Invalid input".into()),
//! );
//! ```
//!
//! # References
//!
//! - **ADR-WASM-009**: Component Communication Model (Pattern 2: Request-Response)
//! - **ADR-WASM-001**: Multicodec Compatibility Strategy
//! - **WASM-TASK-004 Phase 5 Task 5.1**: Message Correlation Implementation

// Layer 1: Standard library imports

// Layer 2: Third-party crate imports
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

// Layer 3: Internal module imports
use crate::core::messaging::CorrelationId;
use crate::core::ComponentId;

/// Request message with correlation tracking.
///
/// Wraps a request payload with metadata for automatic correlation
/// and timeout enforcement by the host runtime.
///
/// # Examples
///
/// ```rust,ignore
/// use airssys_wasm::actor::message::{RequestMessage, CorrelationId};
/// use uuid::Uuid;
///
/// let request = RequestMessage::new(
///     ComponentId::new("requester"),
///     ComponentId::new("responder"),
///     encode_multicodec(&my_request)?,
///     5000, // 5 seconds
/// );
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RequestMessage {
    /// Unique correlation ID (auto-generated by new())
    pub correlation_id: CorrelationId,

    /// Source component ID
    pub from: ComponentId,

    /// Target component ID
    pub to: ComponentId,

    /// Request payload (multicodec-encoded)
    pub payload: Vec<u8>,

    /// Request timestamp
    pub timestamp: DateTime<Utc>,

    /// Timeout duration (milliseconds)
    pub timeout_ms: u32,
}

impl RequestMessage {
    /// Create new request message.
    ///
    /// Generates a new UUID v4 correlation ID and sets the current timestamp.
    ///
    /// # Arguments
    ///
    /// * `from` - Source component ID
    /// * `to` - Target component ID
    /// * `payload` - Multicodec-encoded request payload
    /// * `timeout_ms` - Timeout in milliseconds
    ///
    /// # Examples
    ///
    /// ```rust,ignore
    /// let request = RequestMessage::new(
    ///     component_a,
    ///     component_b,
    ///     payload,
    ///     5000,
    /// );
    /// ```
    pub fn new(from: ComponentId, to: ComponentId, payload: Vec<u8>, timeout_ms: u32) -> Self {
        Self {
            correlation_id: Uuid::new_v4(),
            from,
            to,
            payload,
            timestamp: Utc::now(),
            timeout_ms,
        }
    }
}

#[allow(
    clippy::expect_used,
    clippy::unwrap_used,
    clippy::panic,
    clippy::indexing_slicing,
    clippy::too_many_arguments,
    clippy::type_complexity,
    reason = "test code"
)]
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_request_message_new() {
        let from = ComponentId::new("comp-a");
        let to = ComponentId::new("comp-b");
        let payload = vec![1, 2, 3, 4];

        let request = RequestMessage::new(from.clone(), to.clone(), payload.clone(), 5000);

        assert_eq!(request.from, from);
        assert_eq!(request.to, to);
        assert_eq!(request.payload, payload);
        assert_eq!(request.timeout_ms, 5000);
        // Correlation ID is auto-generated (UUID v4)
        assert_ne!(request.correlation_id, Uuid::nil());
    }

    #[test]
    fn test_request_message_serialization() {
        let request = RequestMessage::new(
            ComponentId::new("comp-a"),
            ComponentId::new("comp-b"),
            vec![1, 2, 3],
            5000,
        );

        // Test JSON serialization round-trip
        let json = serde_json::to_string(&request).unwrap();
        let deserialized: RequestMessage = serde_json::from_str(&json).unwrap();

        assert_eq!(deserialized.correlation_id, request.correlation_id);
        assert_eq!(deserialized.from, request.from);
        assert_eq!(deserialized.to, request.to);
        assert_eq!(deserialized.payload, request.payload);
        assert_eq!(deserialized.timeout_ms, request.timeout_ms);
    }
}
