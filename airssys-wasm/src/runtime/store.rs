//! WASM store management.
//!
//! StoreManager owns a WASM store and its component instance, providing
//! typed export dispatch via the `RuntimeHost` bindings generated by
//! `wasmtime::component::bindgen!`. Each StoreManager manages exactly
//! one component instance.
//!
//! Per ADR-WASM-034: StoreManager uses `RuntimeHost` for typed export
//! dispatch, async instantiation via `instantiate_async`, and bridges
//! between internal types and WIT-generated types.

// Layer 1: Standard library imports (per PROJECTS_STANDARD.md ยง2.1)
// (none)

// Layer 2: Third-party crate imports (per PROJECTS_STANDARD.md ยง2.1)
use wasmtime::component::{Component, Linker};
use wasmtime::Store;

// Layer 3: Internal module imports (per PROJECTS_STANDARD.md ยง2.1)
use crate::core::component::id::ComponentId;
use crate::core::component::message::{ComponentMessage, MessageMetadata, MessagePayload};
use crate::core::runtime::errors::WasmError;
use crate::RuntimeHost;

// WIT-generated types (aliased to avoid name collision per PROJECTS_STANDARD.md ยง2.2)
use crate::airssys::core::errors::WasmError as WitWasmError;
use crate::airssys::core::types::ComponentId as WitComponentId;
use crate::airssys::core::types::ComponentMessage as WitComponentMessage;
use crate::airssys::core::types::MessageMetadata as WitMessageMetadata;
use crate::airssys::core::types::Timestamp as WitTimestamp;
use crate::exports::airssys::core::component_lifecycle::GuestPre;

use super::engine::HostState;

/// Manages a WASM store and its associated component instance.
///
/// Per ADR-WASM-034 Decision 4, StoreManager stores a `RuntimeHost`
/// (from `wasmtime::component::bindgen!`) instead of a raw
/// `wasmtime::component::Instance`. This provides type-safe,
/// compiler-checked access to guest exports.
pub struct StoreManager {
    store: Store<HostState>,
    component: Component,
    binding: Option<RuntimeHost>,
}

impl StoreManager {
    /// Create a new StoreManager.
    ///
    /// The component is NOT initialized until `initialize()` is called.
    /// Calling dispatch methods before initialization returns
    /// `WasmError::StoreNotInitialized`.
    pub fn new(store: Store<HostState>, component: Component) -> Self {
        Self {
            store,
            component,
            binding: None,
        }
    }

    /// Initialize the component instance asynchronously.
    ///
    /// Per ADR-WASM-034 Decision 2 and KNOWLEDGE-WASM-048:
    /// WasmtimeEngine configures `async_support(true)`, so synchronous
    /// `linker.instantiate()` panics. This method uses
    /// `instance_pre.instantiate_async()` to perform async instantiation
    /// and then constructs the `RuntimeHost` binding from the resulting
    /// instance.
    pub async fn initialize(&mut self, linker: &Linker<HostState>) -> Result<(), WasmError> {
        let pre = linker
            .instantiate_pre(&self.component)
            .map_err(|e| WasmError::InstantiationFailed(e.to_string()))?;

        let guest_pre =
            GuestPre::new(pre.component()).map_err(|e| WasmError::ExportNotFound(e.to_string()))?;

        let instance = pre
            .instantiate_async(&mut self.store)
            .await
            .map_err(|e| WasmError::InstantiationFailed(e.to_string()))?;

        let interface0 = guest_pre
            .load(&mut self.store, &instance)
            .map_err(|e| WasmError::ExportNotFound(e.to_string()))?;

        self.binding = Some(RuntimeHost { interface0 });
        Ok(())
    }

    /// Check if the instance is initialized.
    pub fn is_initialized(&self) -> bool {
        self.binding.is_some()
    }

    /// Call handle-message on the component.
    ///
    /// Per ADR-WASM-034 Decision 5: Uses the generated export accessor
    /// to invoke the guest's `handle-message` function via the
    /// `component-lifecycle` interface.
    ///
    /// Since `async_support(true)` is enabled on the engine, wasmtime
    /// requires async function calls. The generated `call_handle_message`
    /// returns a Future which is bridged to sync via
    /// `futures::executor::block_on`.
    pub fn call_handle_message(
        &mut self,
        msg: &ComponentMessage,
    ) -> Result<Option<MessagePayload>, WasmError> {
        let binding = self
            .binding
            .as_ref()
            .ok_or(WasmError::StoreNotInitialized)?;

        // Get typed export accessor
        let lifecycle = binding.airssys_core_component_lifecycle();

        // Convert internal type to WIT type
        let wasm_msg = to_wasm_component_message(msg);

        // Call the actual guest export (async bridged to sync)
        let result =
            futures::executor::block_on(lifecycle.call_handle_message(&mut self.store, &wasm_msg))
                .map_err(|e| WasmError::RuntimeError(e.to_string()))?;

        // Convert WIT result back to internal type
        match result {
            Ok(opt_payload) => Ok(opt_payload.map(from_wasm_message_payload)),
            Err(wasm_err) => Err(from_wasm_error(wasm_err)),
        }
    }

    /// Call handle-callback on the component.
    ///
    /// Same pattern as `call_handle_message` but for callback dispatch.
    pub fn call_handle_callback(&mut self, msg: &ComponentMessage) -> Result<(), WasmError> {
        let binding = self
            .binding
            .as_ref()
            .ok_or(WasmError::StoreNotInitialized)?;

        let lifecycle = binding.airssys_core_component_lifecycle();
        let wasm_msg = to_wasm_component_message(msg);

        // Call the actual guest export (async bridged to sync)
        let result =
            futures::executor::block_on(lifecycle.call_handle_callback(&mut self.store, &wasm_msg))
                .map_err(|e| WasmError::RuntimeError(e.to_string()))?;

        match result {
            Ok(()) => Ok(()),
            Err(wasm_err) => Err(from_wasm_error(wasm_err)),
        }
    }

    /// Get the store.
    pub fn store(&self) -> &Store<HostState> {
        &self.store
    }

    /// Get mutable store.
    pub fn store_mut(&mut self) -> &mut Store<HostState> {
        &mut self.store
    }

    /// Get the component.
    pub fn component(&self) -> &Component {
        &self.component
    }
}

// ============================================================================
// Type conversion functions (ADR-WASM-034 Decision 3)
//
// Bridge between internal types (crate::core::*) and WIT-generated types
// (crate::airssys::core::types::*). These are private functions co-located
// with the only code that needs them.
// ============================================================================

/// Convert internal ComponentMessage to WIT-generated ComponentMessage.
fn to_wasm_component_message(msg: &ComponentMessage) -> WitComponentMessage {
    WitComponentMessage {
        sender: to_wasm_component_id(&msg.sender),
        payload: msg.payload.as_bytes().to_vec(),
        metadata: to_wasm_message_metadata(&msg.metadata),
    }
}

/// Convert internal ComponentId to WIT-generated ComponentId.
fn to_wasm_component_id(id: &ComponentId) -> WitComponentId {
    WitComponentId {
        namespace: id.namespace.clone(),
        name: id.name.clone(),
        instance: id.instance.clone(),
    }
}

/// Convert internal MessageMetadata to WIT-generated MessageMetadata.
fn to_wasm_message_metadata(meta: &MessageMetadata) -> WitMessageMetadata {
    WitMessageMetadata {
        correlation_id: meta.correlation_id.clone(),
        reply_to: meta.reply_to.as_ref().map(to_wasm_component_id),
        timestamp: WitTimestamp {
            seconds: meta.timestamp_ms / 1000,
            nanoseconds: ((meta.timestamp_ms % 1000) * 1_000_000) as u32,
        },
        content_type: meta.content_type.clone(),
    }
}

/// Convert WIT MessagePayload (Vec<u8>) back to internal MessagePayload.
fn from_wasm_message_payload(payload: Vec<u8>) -> MessagePayload {
    MessagePayload::new(payload)
}

/// Convert WIT WasmError variant to internal WasmError.
fn from_wasm_error(err: WitWasmError) -> WasmError {
    match err {
        WitWasmError::ComponentNotFound(s) => WasmError::ComponentNotFound(s),
        WitWasmError::InstantiationFailed(s) => WasmError::InstantiationFailed(s),
        WitWasmError::ExportNotFound(s) => WasmError::ExportNotFound(s),
        WitWasmError::Timeout => WasmError::Timeout,
        WitWasmError::ResourceLimitExceeded(s) => WasmError::ResourceLimitExceeded(s),
        WitWasmError::InvalidComponent(s) => WasmError::InvalidComponent(s),
        WitWasmError::RuntimeError(s) => WasmError::RuntimeError(s),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::runtime::host_functions::marker_traits::register_host_functions;
    use std::path::Path;
    use wasmtime::{Config, Engine, StoreLimitsBuilder};

    /// Create an engine with async_support and component model enabled,
    /// matching the production WasmtimeEngine configuration.
    fn create_async_engine() -> Engine {
        let mut config = Config::new();
        config.wasm_component_model(true);
        config.async_support(true);
        Engine::new(&config).unwrap()
    }

    /// Create a linker with all host functions registered.
    fn create_linker_with_host_functions(engine: &Engine) -> Linker<HostState> {
        let mut linker = Linker::new(engine);
        register_host_functions(&mut linker).unwrap();
        linker
    }

    /// Create a store for a given component ID.
    fn create_store(engine: &Engine, component_id: &ComponentId) -> Store<HostState> {
        let host_state = HostState {
            component_id: component_id.clone(),
            message_router: None,
            store_limits: StoreLimitsBuilder::new().build(),
        };
        Store::new(engine, host_state)
    }

    /// Load a WASM fixture by name.
    fn load_fixture_wasm(name: &str) -> Vec<u8> {
        let fixture_path = Path::new(env!("CARGO_MANIFEST_DIR"))
            .join("tests")
            .join("fixtures")
            .join(name)
            .with_extension("wasm");

        std::fs::read(&fixture_path)
            .unwrap_or_else(|_| panic!("Failed to read fixture: {}", fixture_path.display()))
    }

    fn create_test_message() -> ComponentMessage {
        let sender = ComponentId::new("test", "comp", "0");
        let payload = MessagePayload::new(vec![1, 2, 3]);
        let metadata = MessageMetadata::default();
        ComponentMessage::new(sender, payload, metadata)
    }

    #[test]
    fn test_store_manager_creation() {
        let engine = create_async_engine();
        let component_id = ComponentId::new("test", "comp", "0");
        let store = create_store(&engine, &component_id);

        let wasm_bytes = load_fixture_wasm("echo");
        let component = Component::from_binary(&engine, &wasm_bytes).unwrap();

        let manager = StoreManager::new(store, component);
        assert!(!manager.is_initialized());
    }

    #[test]
    fn test_store_manager_not_initialized_error() {
        let engine = create_async_engine();
        let component_id = ComponentId::new("test", "comp", "0");
        let store = create_store(&engine, &component_id);

        let wasm_bytes = load_fixture_wasm("echo");
        let component = Component::from_binary(&engine, &wasm_bytes).unwrap();

        let mut manager = StoreManager::new(store, component);
        let msg = create_test_message();

        // Should return StoreNotInitialized error
        let result = manager.call_handle_message(&msg);
        assert!(result.is_err());
        assert!(matches!(
            result.unwrap_err(),
            WasmError::StoreNotInitialized
        ));
    }

    #[test]
    fn test_call_callback_not_initialized() {
        let engine = create_async_engine();
        let component_id = ComponentId::new("test", "comp", "0");
        let store = create_store(&engine, &component_id);

        let wasm_bytes = load_fixture_wasm("echo");
        let component = Component::from_binary(&engine, &wasm_bytes).unwrap();

        let mut manager = StoreManager::new(store, component);
        let msg = create_test_message();

        // Should return StoreNotInitialized error
        let result = manager.call_handle_callback(&msg);
        assert!(result.is_err());
        assert!(matches!(
            result.unwrap_err(),
            WasmError::StoreNotInitialized
        ));
    }

    #[test]
    fn test_store_manager_initialization_success() {
        let engine = create_async_engine();
        let component_id = ComponentId::new("test", "echo", "0");
        let store = create_store(&engine, &component_id);
        let linker = create_linker_with_host_functions(&engine);

        let wasm_bytes = load_fixture_wasm("echo");
        let component = Component::from_binary(&engine, &wasm_bytes).unwrap();

        let mut manager = StoreManager::new(store, component);

        // Initialize with async bridge (using futures::executor for test)
        let result = futures::executor::block_on(manager.initialize(&linker));
        assert!(result.is_ok(), "Initialization failed: {:?}", result.err());
        assert!(manager.is_initialized());
    }

    #[test]
    fn test_call_handle_message_with_echo_wasm() {
        let engine = create_async_engine();
        let component_id = ComponentId::new("test", "echo", "0");
        let store = create_store(&engine, &component_id);
        let linker = create_linker_with_host_functions(&engine);

        let wasm_bytes = load_fixture_wasm("echo");
        let component = Component::from_binary(&engine, &wasm_bytes).unwrap();

        let mut manager = StoreManager::new(store, component);
        futures::executor::block_on(manager.initialize(&linker)).unwrap();

        // Call handle_message with payload [1, 2, 3]
        let msg = create_test_message();
        let result = manager.call_handle_message(&msg);

        // echo.wasm returns the payload unchanged
        assert!(result.is_ok(), "call_handle_message failed: {:?}", result);
        let payload = result.unwrap();
        assert!(
            payload.is_some(),
            "echo.wasm should return Some(payload), got None"
        );
        assert_eq!(
            payload.unwrap().as_bytes(),
            &[1, 2, 3],
            "echo.wasm should return the same payload that was sent"
        );
    }

    #[test]
    fn test_call_handle_message_echo_empty_payload() {
        let engine = create_async_engine();
        let component_id = ComponentId::new("test", "echo", "0");
        let store = create_store(&engine, &component_id);
        let linker = create_linker_with_host_functions(&engine);

        let wasm_bytes = load_fixture_wasm("echo");
        let component = Component::from_binary(&engine, &wasm_bytes).unwrap();

        let mut manager = StoreManager::new(store, component);
        futures::executor::block_on(manager.initialize(&linker)).unwrap();

        // Call with empty payload
        let sender = ComponentId::new("test", "comp", "0");
        let msg = ComponentMessage::new(
            sender,
            MessagePayload::new(vec![]),
            MessageMetadata::default(),
        );

        let result = manager.call_handle_message(&msg);
        assert!(result.is_ok());
        let payload = result.unwrap();
        assert!(
            payload.is_some(),
            "echo.wasm should return Some even for empty payload"
        );
        assert!(
            payload.unwrap().is_empty(),
            "echo.wasm should return empty payload for empty input"
        );
    }

    #[test]
    fn test_call_handle_callback_with_echo_wasm() {
        let engine = create_async_engine();
        let component_id = ComponentId::new("test", "echo", "0");
        let store = create_store(&engine, &component_id);
        let linker = create_linker_with_host_functions(&engine);

        let wasm_bytes = load_fixture_wasm("echo");
        let component = Component::from_binary(&engine, &wasm_bytes).unwrap();

        let mut manager = StoreManager::new(store, component);
        futures::executor::block_on(manager.initialize(&linker)).unwrap();

        let msg = create_test_message();
        let result = manager.call_handle_callback(&msg);

        assert!(
            result.is_ok(),
            "call_handle_callback should succeed: {:?}",
            result
        );
    }

    #[test]
    fn test_call_handle_message_with_counter_wasm() {
        let engine = create_async_engine();
        let component_id = ComponentId::new("test", "counter", "0");
        let store = create_store(&engine, &component_id);
        let linker = create_linker_with_host_functions(&engine);

        let wasm_bytes = load_fixture_wasm("counter");
        let component = Component::from_binary(&engine, &wasm_bytes).unwrap();

        let mut manager = StoreManager::new(store, component);
        futures::executor::block_on(manager.initialize(&linker)).unwrap();

        // counter.wasm increments on each message, returning the count
        let msg = create_test_message();

        let result1 = manager.call_handle_message(&msg);
        assert!(result1.is_ok());
        let payload1 = result1.unwrap();
        assert!(payload1.is_some(), "counter.wasm should return a payload");

        let result2 = manager.call_handle_message(&msg);
        assert!(result2.is_ok());
        let payload2 = result2.unwrap();
        assert!(
            payload2.is_some(),
            "counter.wasm should return a payload on second call"
        );

        // Verify the payloads are different (counter increments)
        assert_ne!(
            payload1.unwrap().as_bytes(),
            payload2.unwrap().as_bytes(),
            "counter.wasm should return different values on successive calls"
        );
    }

    #[test]
    fn test_store_accessors() {
        let engine = create_async_engine();
        let component_id = ComponentId::new("test", "comp", "0");
        let store = create_store(&engine, &component_id);

        let wasm_bytes = load_fixture_wasm("echo");
        let component = Component::from_binary(&engine, &wasm_bytes).unwrap();

        let mut manager = StoreManager::new(store, component);

        // Test store accessors
        let _store_ref = manager.store();
        let _store_mut = manager.store_mut();
        let _component_ref = manager.component();

        // Should not panic
    }

    #[test]
    fn test_type_conversion_round_trip() {
        // Verify internal->WIT type conversion preserves data
        let sender = ComponentId::new("ns", "comp", "inst");
        let metadata = MessageMetadata {
            correlation_id: Some("corr-123".to_string()),
            reply_to: Some(ComponentId::new("ns2", "comp2", "inst2")),
            timestamp_ms: 1234567890,
            content_type: Some("application/json".to_string()),
        };
        let msg = ComponentMessage::new(
            sender.clone(),
            MessagePayload::new(vec![10, 20, 30]),
            metadata,
        );

        let wasm_msg = to_wasm_component_message(&msg);

        assert_eq!(wasm_msg.sender.namespace, "ns");
        assert_eq!(wasm_msg.sender.name, "comp");
        assert_eq!(wasm_msg.sender.instance, "inst");
        assert_eq!(wasm_msg.payload, vec![10, 20, 30]);
        assert_eq!(
            wasm_msg.metadata.correlation_id,
            Some("corr-123".to_string())
        );
        assert_eq!(
            wasm_msg.metadata.reply_to.as_ref().unwrap().namespace,
            "ns2"
        );
        assert_eq!(wasm_msg.metadata.timestamp.seconds, 1234567);
        assert_eq!(wasm_msg.metadata.timestamp.nanoseconds, 890_000_000);
        assert_eq!(
            wasm_msg.metadata.content_type,
            Some("application/json".to_string())
        );
    }

    #[test]
    fn test_from_wasm_error_conversion() {
        // Verify WIT error -> internal error conversion
        let err = from_wasm_error(WitWasmError::ComponentNotFound("comp-1".to_string()));
        assert!(matches!(err, WasmError::ComponentNotFound(ref s) if s == "comp-1"));

        let err = from_wasm_error(WitWasmError::Timeout);
        assert!(matches!(err, WasmError::Timeout));

        let err = from_wasm_error(WitWasmError::RuntimeError("oops".to_string()));
        assert!(matches!(err, WasmError::RuntimeError(ref s) if s == "oops"));
    }

    #[test]
    fn test_from_wasm_message_payload_conversion() {
        let payload = from_wasm_message_payload(vec![1, 2, 3, 4, 5]);
        assert_eq!(payload.len(), 5);
        assert_eq!(payload.as_bytes(), &[1, 2, 3, 4, 5]);
    }
}
