//! Unit tests for ActorSystemSubscriber and UnifiedRouter.
#![allow(clippy::expect_used, clippy::unwrap_used, reason = "test code")]//!
//! This test suite validates Task 4.3 implementation:
//! - ActorSystem subscribes to MessageBroker as primary subscriber
//! - UnifiedRouter centralizes routing logic
//! - Routing statistics tracking
//! - Error handling for unreachable components
//!
//! # Test Coverage
//!
//! 1. Subscription lifecycle (start/stop)
//! 2. Message routing to mailboxes
//! 3. Unified router centralization
//! 4. Routing statistics accuracy
//! 5. Error handling
//! 6. Concurrent routing
//! 7. Target extraction from messages
//! 8. Sequential message processing
//! 9. Routing task cleanup
//!
//! # References
//!
//! - **WASM-TASK-004 Phase 4 Task 4.3**: ActorSystem as Primary Subscriber
//! - **ADR-WASM-009**: Component Communication Model
//! - **ADR-WASM-018**: Three-Layer Architecture

#![allow(clippy::expect_used)] // Test code: expect is acceptable for clear error messages

// Layer 1: Standard library imports
#![allow(clippy::clone_on_ref_ptr)]

use std::sync::Arc;
use std::time::Duration;

// Layer 2: Third-party crate imports
// (none)

// Layer 3: Internal module imports
use airssys_rt::broker::{InMemoryMessageBroker, MessageBroker};
use airssys_wasm::actor::{
    ActorSystemSubscriber, ComponentMessage, ComponentRegistry, RoutingStats, SubscriberManager,
    UnifiedRouter,
};
use airssys_wasm::core::ComponentId;

/// Test 1: ActorSystem subscribes to broker
#[tokio::test]
async fn test_actor_system_subscribes_to_broker() {
    let broker = Arc::new(InMemoryMessageBroker::new());
    let registry = ComponentRegistry::new();
    let subscriber_manager = Arc::new(SubscriberManager::new());

    let mut subscriber = ActorSystemSubscriber::new(broker.clone(), registry, subscriber_manager);

    // Start subscription
    let result = subscriber.start().await;
    assert!(
        result.is_ok(),
        "Failed to start subscriber: {:?}",
        result.err()
    );

    // Verify subscription active
    assert!(subscriber.is_running(), "Subscriber should be running");

    // Stop subscription
    let result = subscriber.stop().await;
    assert!(
        result.is_ok(),
        "Failed to stop subscriber: {:?}",
        result.err()
    );

    // Verify stopped
    assert!(!subscriber.is_running(), "Subscriber should be stopped");
}

/// Test 2: Message routes to mailbox (simplified - validates routing logic)
#[tokio::test]
async fn test_message_routes_to_mailbox() {
    let broker = Arc::new(InMemoryMessageBroker::new());
    let registry = ComponentRegistry::new();
    let subscriber_manager = Arc::new(SubscriberManager::new());

    let mut subscriber =
        ActorSystemSubscriber::new(broker.clone(), registry.clone(), subscriber_manager.clone());

    // Start subscriber
    subscriber
        .start()
        .await
        .expect("Failed to start subscriber");

    // Create test message
    let component_id = ComponentId::new("test-component");
    let message = ComponentMessage::InterComponent {
        sender: component_id.clone(),
        to: ComponentId::new("target"), // TODO(WASM-TASK-006): Use actual target
        payload: vec![1, 2, 3],
    };

    // Publish message
    let envelope = airssys_rt::message::MessageEnvelope::new(message);
    broker.publish(envelope).await.expect("Failed to publish");

    // Give routing task time to process
    tokio::time::sleep(Duration::from_millis(50)).await;

    // Cleanup
    subscriber.stop().await.expect("Failed to stop subscriber");

    // Note: Full end-to-end delivery testing requires spawned ComponentActors
    // This test validates the subscription and routing infrastructure
}

/// Test 3: UnifiedRouter centralizes routing
#[tokio::test]
async fn test_unified_router_centralizes_routing() {
    let broker = Arc::new(InMemoryMessageBroker::new());
    let registry = ComponentRegistry::new();

    let router = UnifiedRouter::new(broker, registry);

    // Start router
    let result = router.start().await;
    assert!(result.is_ok(), "Failed to start router: {:?}", result.err());

    // Verify running
    assert!(router.is_running().await, "Router should be running");

    // Route message (simplified routing)
    let source = ComponentId::new("source");
    let target = ComponentId::new("target");
    let message = ComponentMessage::InterComponent {
        sender: source.clone(),
        to: ComponentId::new("target"), // TODO(WASM-TASK-006): Use actual target
        payload: vec![1, 2, 3],
    };

    let result = router.route(source, target, message).await;
    assert!(
        result.is_ok(),
        "Failed to route message: {:?}",
        result.err()
    );

    // Check stats
    let stats = router.stats().await;
    assert_eq!(stats.total_messages, 1, "Should have 1 message");
    assert_eq!(stats.successful_routes, 1, "Should have 1 success");

    // Stop router
    router.stop().await.expect("Failed to stop router");
}

/// Test 4: Routing stats tracking
#[tokio::test]
async fn test_routing_stats_tracking() {
    let mut stats = RoutingStats::new();

    // Initial state
    assert_eq!(stats.total_messages, 0);
    assert_eq!(stats.successful_routes, 0);
    assert_eq!(stats.failed_routes, 0);
    assert_eq!(stats.average_latency_ns, 0);

    // Record successful routing
    stats.record_route_attempt();
    stats.record_success(100);

    assert_eq!(stats.total_messages, 1);
    assert_eq!(stats.successful_routes, 1);
    assert_eq!(stats.average_latency_ns, 100);
    assert_eq!(stats.success_rate(), 100.0);

    // Record another success
    stats.record_route_attempt();
    stats.record_success(200);

    assert_eq!(stats.total_messages, 2);
    assert_eq!(stats.successful_routes, 2);
    assert_eq!(stats.average_latency_ns, 150); // (100 + 200) / 2
}

/// Test 5: Error handling unreachable component
#[tokio::test]
async fn test_error_handling_unreachable_component() {
    let broker = Arc::new(InMemoryMessageBroker::new());
    let registry = ComponentRegistry::new();
    let subscriber_manager = Arc::new(SubscriberManager::new());

    let mut subscriber = ActorSystemSubscriber::new(broker.clone(), registry, subscriber_manager);

    // Start subscriber
    subscriber.start().await.expect("Failed to start");

    // Publish message for nonexistent component
    let message = ComponentMessage::InterComponent {
        sender: ComponentId::new("nonexistent"),
        to: ComponentId::new("target"), // TODO(WASM-TASK-006): Use actual target
        payload: vec![1, 2, 3],
    };
    let envelope = airssys_rt::message::MessageEnvelope::new(message);
    broker.publish(envelope).await.expect("Failed to publish");

    // Give time for processing (error should be logged, not crash)
    tokio::time::sleep(Duration::from_millis(50)).await;

    // Subscriber should still be running despite error
    assert!(
        subscriber.is_running(),
        "Subscriber should still be running"
    );

    subscriber.stop().await.expect("Failed to stop");
}

/// Test 6: Concurrent routing
#[tokio::test]
async fn test_concurrent_routing() {
    let broker = Arc::new(InMemoryMessageBroker::new());
    let registry = ComponentRegistry::new();

    let router = UnifiedRouter::new(broker.clone(), registry);
    router.start().await.expect("Failed to start router");

    // Spawn multiple concurrent routing tasks
    let mut handles = vec![];
    for i in 0..10 {
        let router_clone = router.clone();
        let handle = tokio::spawn(async move {
            let source = ComponentId::new(format!("source-{}", i));
            let target = ComponentId::new(format!("target-{}", i));
            let message = ComponentMessage::InterComponent {
                sender: source.clone(),
                to: ComponentId::new("target"), // TODO(WASM-TASK-006): Use actual target
                payload: vec![i as u8],
            };
            router_clone.route(source, target, message).await
        });
        handles.push(handle);
    }

    // Wait for all to complete
    for handle in handles {
        let result = handle.await.expect("Task panicked");
        assert!(result.is_ok(), "Routing failed: {:?}", result.err());
    }

    // Check stats
    let stats = router.stats().await;
    assert_eq!(stats.total_messages, 10, "Should have 10 messages");
    assert_eq!(stats.successful_routes, 10, "Should have 10 successes");

    router.stop().await.expect("Failed to stop router");
}

/// Test 7: Subscriber start-stop lifecycle
#[tokio::test]
async fn test_subscriber_start_stop_lifecycle() {
    let broker = Arc::new(InMemoryMessageBroker::new());
    let registry = ComponentRegistry::new();
    let subscriber_manager = Arc::new(SubscriberManager::new());

    let mut subscriber = ActorSystemSubscriber::new(broker, registry, subscriber_manager);

    // Initially not running
    assert!(!subscriber.is_running());

    // Start
    subscriber.start().await.expect("Failed to start");
    assert!(subscriber.is_running());

    // Stop
    subscriber.stop().await.expect("Failed to stop");
    assert!(!subscriber.is_running());

    // Can restart
    subscriber.start().await.expect("Failed to restart");
    assert!(subscriber.is_running());

    subscriber.stop().await.expect("Failed to stop again");
}

/// Test 8: Target extraction from message
#[tokio::test]
async fn test_target_extraction_from_message() {
    let component_id = ComponentId::new("test-component");

    // InterComponent message
    let message = ComponentMessage::InterComponent {
        sender: component_id.clone(),
        to: component_id.clone(), // TODO(WASM-TASK-006): Use actual target
        payload: vec![1, 2, 3],
    };
    let result =
        ActorSystemSubscriber::<InMemoryMessageBroker<ComponentMessage>>::extract_target(&message);
    assert!(result.is_ok());
    assert_eq!(
        result.expect("target extraction should succeed"),
        component_id
    );

    // InterComponentWithCorrelation message
    let message = ComponentMessage::InterComponentWithCorrelation {
        sender: component_id.clone(),
        to: component_id.clone(), // TODO(WASM-TASK-006): Use actual target
        payload: vec![1, 2, 3],
        correlation_id: uuid::Uuid::new_v4(),
    };
    let result =
        ActorSystemSubscriber::<InMemoryMessageBroker<ComponentMessage>>::extract_target(&message);
    assert!(result.is_ok());
    assert_eq!(
        result.expect("target extraction should succeed"),
        component_id
    );

    // Invalid message type
    let message = ComponentMessage::Shutdown;
    let result =
        ActorSystemSubscriber::<InMemoryMessageBroker<ComponentMessage>>::extract_target(&message);
    assert!(result.is_err());
}

/// Test 9: Multiple messages sequential
#[tokio::test]
async fn test_multiple_messages_sequential() {
    let broker = Arc::new(InMemoryMessageBroker::new());
    let registry = ComponentRegistry::new();
    let subscriber_manager = Arc::new(SubscriberManager::new());

    let mut subscriber = ActorSystemSubscriber::new(broker.clone(), registry, subscriber_manager);

    subscriber.start().await.expect("Failed to start");

    // Publish multiple messages sequentially
    for i in 0..5 {
        let message = ComponentMessage::InterComponent {
            sender: ComponentId::new(format!("component-{}", i)),
            to: ComponentId::new("target"), // TODO(WASM-TASK-006): Fix target
            payload: vec![i as u8],
        };
        let envelope = airssys_rt::message::MessageEnvelope::new(message);
        broker.publish(envelope).await.expect("Failed to publish");
    }

    // Give time for processing
    tokio::time::sleep(Duration::from_millis(100)).await;

    // Subscriber should still be running
    assert!(subscriber.is_running());

    subscriber.stop().await.expect("Failed to stop");
}

/// Test 10: Routing task cleanup
#[tokio::test]
async fn test_routing_task_cleanup() {
    let broker = Arc::new(InMemoryMessageBroker::new());
    let registry = ComponentRegistry::new();
    let subscriber_manager = Arc::new(SubscriberManager::new());

    {
        let mut subscriber = ActorSystemSubscriber::new(broker, registry, subscriber_manager);

        subscriber.start().await.expect("Failed to start");
        assert!(subscriber.is_running());

        // Drop without explicit stop (tests Drop implementation)
    } // subscriber dropped here

    // Give time for cleanup
    tokio::time::sleep(Duration::from_millis(50)).await;

    // Test passes if no panics or resource leaks
}
